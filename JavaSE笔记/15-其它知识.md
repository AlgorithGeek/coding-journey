# `ArraysSupport`类

## 简述

- `ArraysSupport` 是一个位于 **`jdk.internal.util`** 包中的工具类，属于 JDK 内部实现的一部分，**不直接暴露给开发者使用**。它的主要目的是为 **`java.util.Arrays`** 类和其他需要高性能数组操作的地方(比如我发现的**`ArrayList`**中的扩容那里)**提供底层数组操作的支持**，尤其是在处理基本类型数组（如 **`int[]`**、**`long[]`** 等）时进行优化



## 一些方法

```java
 public static int newLength(int oldLength, int minGrowth, int prefGrowth)	//计算扩容后的数组长度(用于动态扩容)
                        	//oldLength：当前底层数组的容量(oldCapacity)
                        	//minGrowth：理论上最少需要新增的容量，即 minCapacity - oldCapacity
     							//(例如添加元素后超出当前容量时，需至少扩容到 minCapacity)
 							//prefGrowth:首选增长量,ArrayList中是oldCapacity >> 1(即当前容量的 50%,如 10 → 15)
     //核心思想如下
     //确保新容量满足最小需求(minGrowth)
	 //尽可能按“首选增长量”(prefGrowth)扩容(通常是当前容量的一半)
     //避免溢出或超过数组最大长度限制(Integer.MAX_VALUE - 8)
```



## 一些方法的底层源码

- **`newLength()`方法**的底层源码

```java
public static int newLength(int oldLength, int minGrowth, int prefGrowth) {
    						//oldLength：当前底层数组的容量(oldCapacity)
                        	//minGrowth：理论上最少需要新增的容量，
    							//即 minCapacity - oldCapacity
     							//(例如添加元素后超出当前容量时，需至少扩容到 minCapacity)
 							//prefGrowth:首选增长量,ArrayList中是oldCapacity >> 1
    							//(即当前容量的 50%,如 10 → 15)
    								
    int prefLength = oldLength + Math.max(minGrowth, prefGrowth);
    					//这里判断的原因是可能至少增加的元素比首选增长量大
    					//导致首选增长量还是不够容纳
    if (0 < prefLength && prefLength <= SOFT_MAX_ARRAY_LENGTH) {
        return prefLength;
    } else {
        return hugeLength(oldLength, minGrowth);
    }
}
```



# 关于编译运行啥的

- 软件IDEA(编译器)可以在你写代码的过程中就帮你按照你设定的**语法版本**帮你检查错误，比如你设置的是**Java 8**，如果你写了**更高版本(如Java17)才允许的代码**，就会**报错**
- IDEA会把一些参数化的东西，放到设置里或别的地方，方便操作



## 流程

- **Java程序从编写到运行的完整流程**,我个人的理解是(经查无错)：

  **编写`.java`源码 → 编译（没有错误则生成`.class`字节码） → 使用JVM运行`.class`文件**



## 编译细节

- 编译会**检查语法**以及**生成字节码文件等**

- 在编译的时候，其中有很多细节
  - 编译的**`javac`命令**是有参数的，参数可以控制代码的 **语法检查标准**、**字节码版本** 和 **API 兼容性**，IDEA中也有**这方面的**很多设置供我们去实现特定的需求
    - **`-source`参数(JDK1.3+)**控制**源代码的语法版本**，用指定版本进行检查**源代码中语法是否有问题**，**如果用了比指定Java版本高的语法则会报错**
      - IDEA中写代码，编译器进行**语法检查**的时候实际上是根据这个参数检查的
      - 这个可以通过IDEA中**Project Structure**里的几处设置来指定**(优先级从低到高)**
        - **Project中的** **Project SDK处**指定
        - **Project中的** **Language level处**指定
        - **Modules中选择要设置的模块**，之后在**Dependencies的 Module SDK处**指定
        - **Modules中选择要设置的模块**，之后在**Sources中的Language level处**指定
    - **`-target`参数(JDK1.3+)**控制**生成的字节码版本**，进行设置生成的**`.class`文件对应的Java版本**，**如果试图使用一个包含高版本代码的源代码来生成低版本的字节码文件，则会出错**
      - IDEA中写代码，编译器**编译成功后生成字节码文件`.class`**的时候的时候实际上是根据这个参数检查的
      - 这个可以通过IDEA中的一处设置来指定**(优先级从低到高)**
        - **Project Structure里的Project中的** **Project SDK处**指定
        - **Project Structure里，Modules中选择要设置的模块**，之后在**Dependencies的 Module SDK处**指定
        - **Settings中Build, Execution, Deployment里，Compiler下，Java Compiler中的Project bytecode version**处指定**(可以设置为Same as language level)**
    - **`--release`(JDK9+)**控制**语法 + 字节码 + 核心库版本**，用这个参数统一进行设置，使代码同时满足多个要求，**完全兼容**某个Java版本环境
      - **`--release` 参数的三重保障机制**
        1. 语法检查（等同**`-source`**）
        2. 字节码版本（等同**`-target`**}
        3. 核心库版本（自动匹配指定版本的**rt.jar**）
      - 这个也可以通过IDEA的设置来指定**(优先级从低到高)**
        - **Project Structure里的Project中的** **Project SDK处**指定
        - **Project Structure里，Modules中选择要设置的模块**，之后在**Dependencies的 Module SDK处**指定



# 一些常用操作

## 导入第三方jar包

- 将 **jar包** 放到与 **src** 目录平级的 **lib** 文件夹下，右键点击后点击**Add as Library**就OK了