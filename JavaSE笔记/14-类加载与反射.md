# 类加载

- **类加载**是Java虚拟机在运行时，根据**“按需加载”**的原则，将描述类的数据从 **`.class` 文件**（或其他来源）加载到内存，并对数据进行校验、转换、解析和初始化，最终形成可以被虚拟机直接使用的Java类型的过程
- 类加载过程：**加载→ 验证→ 准备→ 解析→ 初始化**
  - 类的生命周期：**加载→ 验证→ 准备→ 解析→ 初始化→ 使用 → 卸载**




## 类加载器

### 概念

- 是 Java 虚拟机（JVM）中一个非常基础但又极其强大的组件，核心职责就是**根据类的全限定名（例如 `java.lang.String`）来加载类的二进制数据（`.class` 文件）**

### 一些种类

#### 启动类加载器(Bootstrap ClassLoader)

- **实现方式**：由 C++ 实现，是 JVM 自身的一部分，因此在 Java 代码中无法直接获取到它的引用，尝试获取它的结果会是 **`null`**。
- **加载范围**：负责加载 Java 最核心的库。具体来说，是 **`<JAVA_HOME>/lib`** 目录下的类库，或者被 **`-Xbootclasspath`** 参数指定的路径下的类库（例如 **`rt.jar`**）。像 **`java.lang.Object`**、**`java.lang.String`** 等都是由它加载的。
- **层级关系**：它是所有类加载器的“祖先”，但它没有父加载器



#### 平台类加载器(Platform ClassLoader)

- **出现版本**：自 Java 9 开始引入
- **前身**：在 Java 8 及更早的版本中，这个角色由 **扩展类加载器** 担任。从 Java 9 开始，由于引入了模块化系统，扩展机制被移除，取而代之的是**平台类加载器**
- **加载范围**：负责加载一些平台相关的模块，例如 **`java.sql`**、**`java.xml`** 等。可以通过 **`ClassLoader.getPlatformClassLoader()`** 获取
- **父加载器**：**启动类加载器**



#### 应用程序类加载器(Application ClassLoader)

- **也称**：**系统类加载器(System ClassLoader)**
- **加载范围**：它负责**加载我们自己编写的**、位于应用程序**类路径**（**`Classpath`**）上的类。这是**程序中默认的类加载器**。可以通过 **`ClassLoader.getSystemClassLoader()`** 获取
- **父加载器**：**平台类加载器**。在 Java 8 及之前，其父加载器是扩展类加载器



#### 用户自定义类加载器

- **实现方式**：由 Java 开发者通过继承 **`java.lang.ClassLoader`** 类来创建。
- **目的**：为了满足一些特殊的需求，例如：
  - **动态加载**：从网络、数据库或其他非标准来源加载类的字节码。
  - **代码加密**：对 **`.class`** 文件进行加密，在加载时再进行解密，保护代码不被反编译。
  - **热部署**：允许在不重启应用的情况下，重新加载修改后的类，这在 Web 服务器（如 Tomcat）和大型框架中非常常见。
  - **隔离性**：创建隔离的命名空间，防止不同模块间的类冲突。例如，Tomcat 为每个 Web 应用都创建一个独立的类加载器。



## 类的生命周期

### 相关知识与概念

- 一个类的完整生命周期包括七个阶段
  - **加载（Loading）**
  - **验证（Verification）**
  - **准备（Preparation）**
  - **解析（Resolution）**
  - **初始化（Initialization）**
  - **使用（Using）**
  - **卸载（Unloading）**

- 其中，**验证、准备、解析** 这三个部分统称为 **链接（Linking）**
- **加载、验证、准备、解析、初始化 是 类加载过程**



### 类加载的过程

- 阶段的执行过程允许重叠和交叉，但是**阶段开始的顺序是固定的**

  

#### 加载

- 这是类加载过程的第一个阶段。在这个阶段，JVM 需要完成以下三件事情：

  1. **获取字节码流**：通过一个类的全限定名(例如 **`com.example.MyClass`**），找到对应的 **`.class`** 文件，并获取定义这个类的二进制字节码流。这个字节码流可以来自多种来源，如本地文件系统、网络、JAR/WAR 包、甚至是运行时动态生成(例如动态代理) .

  2. **转换成方法区结构**：将这个**字节码流**所代表的静态存储结构**转化**为 JVM 方法区中的**运行时数据结构**

  3. **生成 Class 对象**：在 Java **堆中生成**一个**代表这个类的 `java.lang.Class` 对象**，**作为方法区这个类的各种数据的访问入口**

     > 这是反射机制的入口和基石

**注意：** **加载阶段和链接阶段**的部分内容是**交叉进行**的，加载阶段尚未完成，**链接阶段**可能已经开始。但是**阶段开始的顺序是固定的**



#### 链接

- 链接阶段负责将创建的类合并到 JVM 的运行时状态中

##### 验证

- 这是链接的第一步，目的是确保被加载的 **`.class` 文件**的字节码流中包含的信息符合当前虚拟机的要求，并且不会危害虚拟机自身的安全。如果验证失败，会抛出 **`VerifyError`**

- 验证过程主要包括四个方面的检查：

  - **文件格式验证**：检查字节码流是否符合 **`Class` 文件**格式的规范（例如，是否以 **`0xCAFEBABE`** 开头，主次版本号是否在当前 JVM 处理范围之内等）

  - **元数据验证**：对字节码描述的信息进行语义分析，以保证其描述的信息符合 Java 语言规范的要求（例如，这个类是否有父类，是否继承了 **`final` 类**等）

  - **字节码验证**：通过数据流和控制流分析，确定程序语义是合法的、符合逻辑的。这是整个验证过程中最复杂的一个阶段，保证了方法体内的代码不会做出任何危害虚拟机的行为

  - **符号引用验证**：发生在解析阶段，确保后续的解析动作能正常执行

##### 准备

- 准备阶段是正式为 **类变量（静态变量，即被 `static` 修饰的变量）** 分配内存并设置其 **初始值** 的阶段。

  - **内存分配**：这些变量所使用的内存都将在 **方法区** 中进行分配

  - **初始值**：**这里说的初始值通常是数据类型的“零值”**，**而不是代码中显式赋予的值**
    - 例如 **`public static int value = 123;`**，在准备阶段后，**`value`** 的值是 **`0`**，而不是 **`123`**。将 **`value`** 赋值为 **`123`** 的 **`putstatic`** 指令是在**初始化阶段**才会执行
    - 但对于常量（**`public static final int CONST_VALUE = 123;`**），在准备阶段就会被直接赋值为 **`123`**



##### 解析

- 解析阶段是 JVM 将常量池内的 **符号引用（Symbolic References）** 替换为 **直接引用（Direct References）** 的过程

  > 把不知道的符号替换成确认的东西？

  - **符号引用**：**以一组符号来描述所引用的目标**，例如类的全限定名、字段或方法的名称和描述符等。它和虚拟机的内存布局无关。

  - **直接引用**：可以直接指向目标的指针、相对偏移量或者是一个能间接定位到目标的句柄。它和虚拟机的内存布局是相关的。

- 这个过程主要针对类或接口、字段、类方法、接口方法、方法类型等	



#### 初始化

- 这是类加载过程的最后一步。到了这个阶段，JVM 才**真正开始执行类中定义的 Java 程序代码（或者说字节码）**

  - 初始化阶段就是执行 **类构造器 `<clinit>()` 方法** 的过程

    >简单来说，**初始化阶段就是执行类构造器 `<clinit>()` 方法的过程**。这个阶段的目标是为类中的静态变量赋予开发者指定的初始值，并执行静态代码块中的逻辑
    >
    >- **`<clinit>()` 方法**并不是由你直接编写的，而是由 Java 编译器自动收集类中的所有 **静态变量的赋值动作** 和 **静态代码块（`static {}` 块）** 中的语句合并产生的

    - **`<clinit>()` 方法**是由编译器自动收集类中的所有 **类变量的赋值动作** 和 **静态语句块（`static{}` 块）** 中的语句合并产生的。编译器收集的顺序是由语句在源文件中出现的顺序决定的。

    - JVM 会保证在子类的 **`<clinit>()` 方法**执行前，父类的 **`<clinit>()` 方法**已经执行完毕。因此在 JVM 中，第一个被执行的 **`<clinit>()` 方法**的类肯定是 **`java.lang.Object`**

    - **`<clinit>()` 方法**对于类或接口来说并不是必需的，如果一个类中没有静态语句块，也没有对变量的赋值操作，那么编译器可以不为这个类生成 **`<clinit>()` 方法**

    - JVM 会保证一个类的 **`<clinit>()` 方法**在多线程环境中被正确地加锁、同步。如果多个线程同时去初始化一个类，那么只会有一个线程去执行这个类的 **`<clinit>()` 方法**，其他线程都需要阻塞等待，直到活动线程执行 **`<clinit>()` 方法**完毕



## 类加载的时机

- 这个标题有点问题，但是很好：

  - Java 中类的**生命周期**中，虽然**“加载”**是第一步，但 JVM 规范并没有强制规定类必须在什么时候完成“加载”。但是，它严格规定了在什么情况下必须对一个类进行“**初始化**”。而**初始化阶段是类加载过程的最后一步，一旦一个类被初始化，那么它之前的加载、验证、准备等阶段必然已经完成**

    >类的生命周期：**加载→ 验证→ 准备→ 解析→ 初始化→ 使用 → 卸载**
    >
    >类加载过程：**加载→ 验证→ 准备→ 解析→ 初始化**

    - Java 虚拟机规范 **严格规定**了**有且只有六种情况** **必须立即对类进行“初始化”**，这被称为 **主动引用**。当一个类被主动引用时，如果它还没有被初始化，JVM 就会立即对其进行初始化
    - 反之，所有其他引用类的方式，都不会触发初始化，称为 **被动引用**

### 主动引用六种情况

#### 1.创建类的实例（`new`）

- 这是最常见的情况。当使用 **`new` 关键字**创建一个类的对象时，这个类必须被初始化。

  ```java
  // 这行代码会触发 MyClass 的初始化
  MyClass myObject = new MyClass();
  ```

#### 2.访问类的静态变量（读取或赋值）

- 当读取或设置一个类的静态字段（**`static` 变量**）时，会触发该类的初始化。

  ```Java
  // 读取静态变量，会触发 MyClass 的初始化
  int value = MyClass.staticVar;
  
  // 设置静态变量，也会触发 MyClass 的初始化
  MyClass.staticVar = 100;
  ```

  - **例外**：如果这个静态变量是 **`static final` 的常量**，并且它的**值在编译期就可以确定**，那么**对它的访问不会触发类的初始化**，因为它的**值已经被内联到调用方的常量池中了**。

  ```Java
  // MyClass 中定义: public static final int CONSTANT = 123;
  // 下面的代码不会触发 MyClass 的初始化
  int constValue = MyClass.CONSTANT;
  ```

#### 3.调用类的静态方法

- 当**调用一个类的静态方法（`static` 方法）**时，会触发该类的初始化。

  ```java
  // 调用静态方法，会触发 MyClass 的初始化
  MyClass.staticMethod();
  ```

#### 4.**使用反射** 

- 当使用 **`java.lang.reflect` 包的方法** **对类进行反射调用**时，**如果类没有被初始化，则需要先触发其初始化**。最典型的就是 **`Class.forName()`**

  ```Java
  // Class.forName("com.example.MyClass") 会触发 MyClass 的初始化
  Class.forName("com.example.MyClass");
  ```

#### 5.初始化子类时，父类必须先被初始化

- 当**初始化一个子类时**，JVM 会**确保其所有父类都已经被初始化**。这是一个**递归**的过程。

  ```Java
  // 假设 SubClass 继承自 SuperClass
  // new SubClass() 会先触发 SuperClass 的初始化，然后再触发 SubClass 的初始化
  SubClass sub = new SubClass();
  ```

#### 6.启动类

- 当**虚拟机启动时**，用户需要**指定一个要执行的主类**（**包含 `main()` 方法的那个类**），**虚拟机会先初始化这个主类**



### 被动引用几个例子

#### **子类引用父类的静态字段**

- 通过子类来引用父类中定义的静态字段，只会触发父类的初始化，而不会触发子类的初始化。

```Java
// SuperClass 中定义: public static int value = 10;
// SubClass 继承 SuperClass
// 下面的代码只会触发 SuperClass 的初始化，不会触发 SubClass 的初始化
System.out.println(SubClass.value);
```

#### **通过数组定义来引用类**

- 定义一个类的数组，并不会触发该类的初始化。

```Java
// 这行代码不会触发 MyClass 的初始化
MyClass[] array = new MyClass[10];
```

- 这行代码只会创建一个名为 **`[Lcom.example.MyClass;`** 的数组类，但 **`MyClass` 本身没有被初始化**

#### **引用编译期常量**

- 如前所述，当一个**常量的值在编译阶段就已经确定并存入调用方的常量池**时，对**该常量的引用等同于直接引用常量值**，**不会触发定义该常量的类的初始化**。



## 双亲委派模型(Parents Delegation Model)

- **双亲委派模型**并不是一个强制性的技术规范，而是 Java 设计者推荐并内置在 JDK 中的一种 **类加载器工作机制**

### 核心思想

- 当一个类加载器收到加载类的请求时，它首先不会自己去尝试加载这个类，而是把这个请求 **层层向上委派给父加载器** 去完成，直到委派到最顶层的**启动类加载器**. **只有当父加载器反馈自己无法完成这个加载请求时**(即在它的搜索范围内找不到所需的类），**子加载器才会尝试自己去加载**
  - 这里的**“双亲”并非指继承关系**，而是一种**组合关系**，用于**表示类加载器之间的层级结构**。除了**最顶层的启动类加载器**，**每个加载器都有一个直接的父加载器**。
    - **应用程序类加载器的父加载器是** **平台类加载器**。
    - **平台类加载器** 的父加载器是 **启动类加载器**



### 作用

- **保证类的唯一性，避免重复加载**

  - 这是**最核心的好处**。通过委派机制，可以确保任何一个类在 JVM 中都只对应一个唯一的 **`Class` 对象**。

  > **经典例子：`java.lang.Object`** 试想，如果没有双亲委派模型，每个类加载器都自己加载。那么应用程序类加载器可以加载一个 **`java.lang.Object`**，你依赖的某个框架的自定义加载器也可以加载一个 **`java.lang.Object`**。此时，JVM 中就会存在多个 **`Object`** 类的 **`Class`** 对象。 这将导致灾难性的后果：

  - 类型体系会完全混乱，因为一个对象 **`instanceof Object`** 的结果可能会是 **`false`**。
  - 类型转换会失败，整个 Java 的基石都会崩塌。

  而在双亲委派模型下，任何对 **`java.lang.Object`** 的加载请求，**最终都会被委派到最顶层的启动类加载器**，由它统一加载 JDK 核心库中的那个 **`Object` 类**。因此，无论在程序的任何角落，获取到的 **`Object`** 都是同一个。

- 保证核心库的安全性，防止核心 API 被篡改

  - 这个模型可以保护 Java 核心类库不被恶意代码污染。

  >**安全例子：自定义 `java.lang.String`** 假设一个黑客编写了一个恶意的 **`java.lang.String`** 类，其中包含了一些危险代码，并把它放在了应用的 Classpath 下，企图替换掉 JDK 原生的 **`String`** 类。
  >
  >在双亲委派模型下，当程序需要加载 **`java.lang.String`** 时：
  >
  >1. 应用程序类加载器收到请求，向上委派。
  >2. 平台类加载器收到请求，继续向上委派。
  >3. 启动类加载器收到请求，它在自己的搜索路径（核心库 **`rt.jar`** 或 **`java.base`** 模块）中找到了正版的 **`java.lang.String`** 并成功加载。
  >4. 加载成功后，**`Class`** 对象被返回，加载过程结束。
  >
  >因此，黑客编写的那个恶意 **`String` 类**根本**没有机会被加载**，从而保证了 Java 平台和用户代码的安全。



### 代码实现

- 双亲委派模型的逻辑主要实现在 **`java.lang.ClassLoader`** 的 **`loadClass()` 方法**中。我们可以看一下其简化后的逻辑：

```Java
protected Class<?> loadClass(String name, boolean resolve) throws ClassNotFoundException {
    // 1. 检查这个类是否已经被加载过了
    Class<?> c = findLoadedClass(name);
    if (c == null) {
        // 如果没有加载过
        try {
            // 2. 尝试委派给父加载器去加载
            if (parent != null) {
                c = parent.loadClass(name, false);
            } else {
                // 如果没有父加载器，则委派给启动类加载器
                c = findBootstrapClassOrNull(name);
            }
        } catch (ClassNotFoundException e) {
            // 父加载器抛出异常，说明它找不到这个类
            // 这个 catch 块是空的，因为这是预期行为，我们将继续向下执行
        }
        if (c == null) {
            // 3. 如果所有父加载器都找不到，最后才由自己来加载
            // findClass() 方法会调用我们自己实现的类查找逻辑
            c = findClass(name);
        }
    }
    return c;
}
```

- 从代码中可以清晰地看到“**检查已加载 → 委派父类 → 自己加载**”这个标准流程。因此，如果我们想自定义类加载器，**推荐重写 `findClass()` 方法**，而不是破坏委派模型的 **`loadClass()` 方法**



###  打破双亲委派模型的场景

- 虽然双亲委派模型很优秀，但在某些场景下，它也需要被“打破”才能满足需求，最典型的就是 **SPI（Service Provider Interface）机制**，例如 **JDBC**。

  - **问题**：**JDBC 的接口**（如 **`java.sql.Driver`**）由 Java 核心库提供，由启动类加载器加载。而具体的实现（如 MySQL、Oracle 的驱动 `jar` 包）是由第三方厂商提供的，位于应用的 Classpath 下，由**应用程序类加载器加载**。启动类加载器无法“向下”看到并加载这些实现类。

  - **解决方案**：引入 **线程上下文类加载器（Thread Context ClassLoader）**。Java 核心代码（如 **`DriverManager`**）在需要加载驱动实现时，会从当前线程获取**上下文类加载器**（通常是应用程序类加载器），然后用这**个加载器去加载驱动类**，这实际上是一种“反向委派”，打破了严格的向上委派规则

#### 上下文类加载器

- 线程上下文类加载器（Thread Context ClassLoader）**不是一种特殊类型的ClassLoader**。它只是 **`java.lang.Thread` 类**的一个**成员变量**而已
  - Java中线程的创建有**继承性**。当一个新线程被创建时，它会**自动继承其父线程的上下文类加载器**
  - 上下文加载器是线程中的，一般是应用程序加载器，但是如果我们想要指定加载器，就需要把上下文加载器进行赋值，赋值为我们想要指定的加载器，之后手动调用这个改过的上下文加载器进行加载某个类
  - 默认加载器：当一个类 A 需要加载另一个类 B 时，默认情况下，JVM会使用【加载了类A的那个类加载器】去加载类B



## 相关类

### `java.lang.ClassLoader`

- 一个**抽象类**，是**所有类加载器的基类**。它**定义了类加载器的基本行为**，最重要的方法就是 **`loadClass(String name, boolean resolve)`**，该方法**实现了双亲委派模型的逻辑**。**开发者通过继承这个类来实现自定义的类加载器**

#### 构造方法

```java
protected ClassLoader()
							// 使用 getSystemClassLoader() 的返回值作为父加载器来创建一个新的类加载器
protected ClassLoader(String name, ClassLoader parent)
							// (Java 9+) 创建一个具有指定名称和指定父加载器的新类加载器
protected ClassLoader(ClassLoader parent)
							// 使用指定的父加载器来创建一个新的类加载器
```

#### 方法

```java
public Class<?> 			loadClass(String name)
								// 使用指定的二进制名称加载类。这是双亲委派模型的入口，一般不应被重写。
protected Class<?> 			loadClass(String name, boolean resolve)
								// (已废弃) 使用指定的二进制名称加载类。
protected Class<?> 			findClass(String name)
								// [子类实现的关键] 查找具有指定二进制名称的类。子类应重写此方法以实现自定义的类查找逻辑。
protected Class<?> 			findClass(String moduleName, String name)
								// (Java 9+) 在为此类加载器定义的特定模块中查找具有给定二进制名称的类。
protected final Class<?> 	findLoadedClass(String name)
								// 检查此加载器是否已将具有该二进制名称的类加载为初始加载器。用于“缓存检查”。
protected final Class<?> 	findSystemClass(String name)
								// (已废弃) 查找具有指定二进制名称的系统类。
protected final Class<?> 	defineClass(byte[] b, int off, int len)
								// (已废弃) 被 defineClass(String, byte[], int, int) 替代。
protected final Class<?> 	defineClass(String name, byte[] b, int off, int len)
								// 将一个字节数组转换为 Class 类的实例。
protected final Class<?> 	defineClass(String name, byte[] b, int off, int len, ProtectionDomain protectionDomain)
								// 使用给定的 ProtectionDomain 将字节数组转换为 Class 类的实例。
protected final Class<?> 	defineClass(String name, ByteBuffer b, ProtectionDomain protectionDomain)
								// (Java 9+) 使用给定的 ProtectionDomain 将 ByteBuffer 转换为 Class 类的实例。
protected final void 		resolveClass(Class<?> c)
								// 链接指定的类。这个操作会验证、准备类，并解析其符号引用。
```

```java
public URL 					getResource(String name)
								// 查找具有给定名称的资源。此方法会先委托给父加载器。
public Enumeration<URL> 	getResources(String name)
								// 查找所有具有给定名称的资源。会从父加载器和自身加载器中查找所有匹配项。
public Stream<URL> 			resources(String name)
								// (Java 9+) 返回一个 Stream，其元素是具有给定名称的所有资源的 URL。
public InputStream 			getResourceAsStream(String name)
								// 返回用于读取指定资源的输入流。
protected URL 				findResource(String name)
								// [子类实现的关键] 查找具有给定名称的资源。这是 getResource 的实现部分。
protected URL 				findResource(String moduleName, String name)
								// (Java 9+) 返回指向此类加载器定义的模块中资源的 URL。
protected Enumeration<URL> 	findResources(String name)
								// [子类实现的关键] 返回代表具有给定名称的所有资源的 URL 枚举。
```

```java
public final ClassLoader 	getParent()
								// 返回用于委派的父类加载器
public static ClassLoader 	getSystemClassLoader()
								// 返回系统（应用程序）类加载器
public static ClassLoader 	getPlatformClassLoader()
								// (Java 9+) 返回平台类加载器
public static URL 			getSystemResource(String name)
								// 从系统类加载器的搜索路径中查找指定名称的资源
public static Enumeration<URL> getSystemResources(String name)
								// 从系统类加载器的搜索路径中查找所有同名资源
public static InputStream 	getSystemResourceAsStream(String name)
								// 从系统类加载器的搜索路径中打开指定资源的输入流
```

```java
protected Package 			definePackage(String name, ...)
								// 在此 ClassLoader 中定义一个包及其属性（版本、供应商等）。
protected Package 			getPackage(String name)
								// (已废弃) 返回此加载器或其祖先定义的包。因在委托链中可能产生歧义而被废弃。
public Package[] 			getPackages()
								// 返回此加载器及其祖先定义的所有 Package。
public final Package 		getDefinedPackage(String name)
								// (Java 9+) 返回已由此类加载器（且仅此加载器）定义的 Package。
public final Package[] 		getDefinedPackages()
								// (Java 9+) 返回已由此类加载器（且仅此加载器）定义的所有 Package。
```

```java
public void 				clearAssertionStatus()
								// 清除此类加载器的所有断言状态设置。
public void 				setDefaultAssertionStatus(boolean enabled)
								// 设置此类加载器的默认断言状态。
public void 				setPackageAssertionStatus(String packageName, boolean enabled)
								// 为指定的包设置默认断言状态。
public void 				setClassAssertionStatus(String className, boolean enabled)
								// 为指定的顶级类及其内部类设置断言状态。
```

```java
public String 				getName()
								// (Java 9+) 返回此类加载器的名称，如果未命名则返回 null。
protected Object 			getClassLoadingLock(String className)
								// (Java 7+) 返回用于类加载操作的锁对象，用于支持并行加载。
protected static boolean 	registerAsParallelCapable()
								// (Java 7+) 将调用此方法的类加载器注册为支持并行加载。
public final boolean 		isRegisteredAsParallelCapable()
								// (Java 7+) 如果此类加载器支持并行加载，则返回 true。
public final Module 		getUnnamedModule()
								// (Java 9+) 返回此加载器的未命名模块。
```

```java
protected String 			findLibrary(String libname)
								// [子类实现的关键] 返回本机库（如 .dll, .so）的绝对路径名。
protected final void 		setSigners(Class<?> c, Object[] signers)
								// 设置一个类的签名者。
```



### `java.net.URLClassLoader`

-  **`ClassLoader`** 的一个**重要且常用的具体实现类**。它**可以从本地文件系统或网络的 URL 路径中加载类和资源**
-  在 Java 9 模块化系统之前，**`AppClassLoader`** 和 **`ExtClassLoader`** 都是**继承自它**的。现在，它仍然是**实现自定义类加载器时一个非常方便的基类**

#### 构造方法

```java
public URLClassLoader(URL[] urls)
					// 使用默认的父加载器（getSystemClassLoader()）为给定的 URL 创建一个新的 URLClassLoader。
public URLClassLoader(URL[] urls, ClassLoader parent)
					// 为给定的 URL 和指定的父加载器创建一个新的 URLClassLoader。
public URLClassLoader(URL [] urls, ClassLoader  parent, URLStreamHandlerFactory  factory)
    				//为指定的 URL、父类加载器和 URLStreamHandlerFactory 构造一个新的 URLClassLoader
    
public URLClassLoader(String  name, URL [] urls, ClassLoader  parent)
    				//为指定的 URL 构造一个新的命名 URLClassLoader
public URLClassLoader(String  name, URL [] urls, ClassLoader  parent, URLStreamHandlerFactory  factory)
    				//为指定的 URL、父类加载器和 URLStreamHandlerFactory 构造一个新的名为 URLClassLoader 的对象
```

#### 方法

```java
public static URLClassLoader newInstance(URL[] urls)
					// (已废弃) 为指定的 URL 和默认父类加载器创建一个 URLClassLoader 的新实例
public static URLClassLoader newInstance(URL[] urls, ClassLoader parent)
					// (已废弃) 为指定的 URL 和父类加载器创建一个 URLClassLoader 的新实例
```

```java
protected Class<?> 			findClass(String name)
					// 在此加载器的 URL 搜索路径中查找并加载具有指定名称的类。这是其核心实现
public URL 					findResource(String name)
					// 在 URL 搜索路径上查找具有指定名称的第一个资源，并返回其 URL
public Enumeration<URL> 	findResources(String name)
					// 返回一个 URL 枚举，表示在 URL 搜索路径上具有指定名称的所有资源
public InputStream 			getResourceAsStream(String name)
					// 返回用于读取指定资源的输入流。此方法会覆盖父类实现以优化资源查找
```

```java
public URL[] 				getURLs()
					// 返回用于加载类和资源的 URL 搜索路径数组
protected void 				addURL(URL url)
					// [重要] 将指定的 URL 附加到此类加载器的 URL 搜索路径中，从而在运行时动态扩展 classpath
```

```java
protected Package 				definePackage(String name, Manifest man, URL url)
					// 在此 URLClassLoader 中按名称定义新包，其属性从提供的 Manifest 中获取
protected PermissionCollection 	getPermissions(CodeSource codesource)
					// 返回此加载器授予给定代码源（CodeSource）的权限集合
```

```java
public void 					close()
//(实现了Closeable接口)关闭此 URLClassLoader，释放其打开的资源(例如，它可能已缓存的 JAR 文件).关闭后不能再用于加载新类
```



### `jdk.internal.loader.PlatformClassLoader`

- JDK 内部对平台类加载器加载器的具体实现

### `jdk.internal.loader.AppClassLoader`

- JDK 内部对应用程序类加载器的具体实现



## 类路径

> 类路径就是给 JVM 用的，让 JVM 知道去哪里加载这个 **`.class` 文件**

### 简介

- 从技术上讲，**类路径是一个由一个或多个路径组成的列表**，**Java 虚拟机 (JVM) 和 Java 编译器 (javac) 都使用它来查找所需的类文件 (`.class` 文件)**
  - 这个**列表**中的每一项可以是：
    - **一个目录的路径**：例如 **`C:\Projects\MyProject\bin`** 或 **`/home/user/myproject/classes`**。JVM 会在这个目录下查找 **`.class`** 文件
    - **一个 JAR 文件的路径**：例如 **`C:\libs\mysql-connector-java.jar`** 或 **`/home/user/libs/log4j.jar`**。JVM 会在这个 JAR 文件内部查找 **`.class`** 文件。
      - **JAR文件本质上是一个 ZIP 压缩包**，里面包含了包结构和对应的 **`.class`** 文件
    - **一个包含 JAR 文件的目录**：使用通配符 **`*`**，例如 **`C:\libs\*`** 或 **`/home/user/libs/*`**。这会让 JVM 加载该目录下所有 **`.jar`** 文件（注意：这不会递归搜索子目录）。



### 为什么需要类路径

- Java 的核心优势之一是“一次编译，到处运行”。这意味着你的代码可以依赖很多其他的代码（无论是你自己写的，还是第三方的库）。当你的程序运行时，JVM 需要一种机制来定位并加载所有这些依赖的类

  - **如果没有类路径**： 当你运行 **`java com.myapp.Main`** 时，JVM 怎么知道 **`com.myapp.Main.class`** 文件在哪里？它又怎么知道 **`Main`** 类引用的 **`org.apache.logging.log4j.Logger`** 这个类在哪里？

  - **有了类路径**，JVM 就有了明确的搜索指南。它会按照类路径中指定的顺序，逐个位置查找，直到找到第一个匹配的类为止



### 类路径的根路径

- “类路径的根路径”不是一个地方，而是一个**应用在类路径列表每一个条目上的“起点”概念**
  - 一般情况下， **`target/classes` 目录，就是这个类路径列表的第一个、也是最重要的条目**。这是所有查找的“起点”



### 我们和类路径

- 我们**程序员和类路径打交道**

  1. **决定输出位置**：我们程序员首先规划好，编译后的 **`.class` 文件**要放在哪个目录，比如 **`bin`** 或者 **`target/classes`**。这个目录**将会成为**我们**类路径**的一部分

     > 这个target/classes是

  2. **编译并输出到该位置**：我们使用 **`javac -d bin ...`** 这样的命令，明确告诉编译器：“请把生成的字节码文件放到 **`bin`** 目录下”

  3. **组合类路径并告诉JVM**：在运行程序时，我们使用 **`java -cp ...`** 命令，把**第1步中规划的目录**（现在已经有 **`.class` 文件**了）**以及所有需要的第三方 JAR 包的路径**，**组合起来形成一个完整的类路径**，告诉 JVM

  4. **JVM按图索骥**：JVM 拿到我们给的这个**类路径“地址列表”**，严格地按照列表中的顺序去寻找并加载它**需要的所有字节码文件**

  > 如果像上面纯手工，不仅非常非常繁琐，还极其容易出错，现在都是用IDEA和Maven这些工具，不会有人自己哇啦哇啦一顿写的



### 项目中对类路径的操作

#### 项目中的一些路径选择

- **Maven项目中**一般不用**绝对路径和相对路径**

  - 绝对路径：这是**硬编码**，可移植性为零。这段代码只能在您的电脑上运行。当项目交给同事、部署到 Linux 服务器、或者在持续集成（CI/CD）服务器上构建时，这个路径百分之百会失效，因为他们的文件系统结构和您完全不同。这是软件开发中的大忌
  - 相对路径：相对路径是相对于 **“当前工作目录” (Current Working Directory)** 的，但是**“当前工作目录”** 是一个非常不稳定的、善变的东西，有时候是相对于这个，有时候是相对于那个，我真服了

- **Maven项目中**一般使用**类路径**

  - **位置稳定**：无论项目**在哪里运行**，**资源或配置文件的目录都是稳定的**，比如**`config.properties`** 相对于**类路径根的位置**永远是 **`/config.properties`**
  - **打包后依然有效**：当您把项目打包成 **`myapp.jar` 文件**时，**`target/classes`** 里的所有内容都会被打包到 **JAR 文件的根目录**。**JVM 的类加载器足够智能**，它**既能从文件系统的目录中加载资源**，**也能从 JAR 文件的内部加载资源**，而我们程序员使用的代码是**完全一样**的

  

#### 关于Maven中使用类路径

- Maven 的一个**核心约定**

  - Maven 会将 **`src/main/resources`** 目录下的所有内容，在**构建时原封不动地复制到编译输出目录的根路径下**，**和编译好的 `.class` 文件放在一起**

    > 示例：
    >
    > 你的Java代码和路径:
    >
    > ```java
    > 项目名/
    > └── src/
    > └── main/
    >   ├── java/
    >   │   └── com/
    >   │       └── myapp/
    >   │           └── MyService.java			//代码
    >   └── resources/						//资源文件夹
    >       ├── config.properties				//配置文件
    >       └── images/							//图片文件夹
    >           └── logo.png					//图片
    > ```
    >
    > 编译后生成的**类路径**：
    >
    > ```java
    > target/
    > └── classes/
    > ├── com/
    > │   └── myapp/
    > │       └── MyService.class   <-- MyService.java 编译后的结果
    > ├── config.properties         <-- 从 src/main/resources/ 直接复制过来
    > └── images/
    >   └── logo.png              <-- 同样，目录结构被完整保留并复制过来
    > ```

  - 当然啊，**Maven的这个生成路径**也**可以更改**的

    - 但是不建议更改哈，我这里不写步骤了，实在想改就很麻烦的去网上搜吧，因为我不建议更改

    

#### 使用类路径获取资源

- 获取类路径下的资源，最常用和推荐的方式是使用 **`Class`** 或 **`ClassLoader`** 对象的 **`getResourceAsStream()`** 方法。它会返回一个 **`InputStream`**，可以用它来读取文件内容



### 类路径资源查找机制

#### 核心原则：直接拼接定位查找

- Java 虚拟机 (JVM) 在查找类路径下的资源时，采用的是一种高效的**“路径拼接定位”**模式，而不是低效的“递归遍历搜索”模式

  > 我的口语化总结：类路径只会遍历根目录和 用根目录进行 拼接，拼接上有就是有，没有就是没有，不会一个一个文件夹去找
  >
  > >这个“根路径”不是一个地方，而是一个**应用在类路径列表每一个条目上的“起点”概念**
  > >
  > >- 一般情况下， **`target/classes` 目录，就是这个类路径列表的第一个、也是最重要的条目**。这是所有查找的“起点”



#### 查找过程的步骤

- Java 类路径 是一个包含多个路径条目（目录或 JAR 文件）的有序列表。当 JVM 类加载器查找资源时，会遵循以下技术步骤：
  1. **解析请求**： 当一个资源加载请求（如 `MyClass.class.getResourceAsStream("/config/db.properties")`）被调用时，类加载器会解析出要查找的资源内部路径，即 `config/db.properties`
  2. **顺序遍历类路径条目**： 类加载器会严格按照类路径列表的顺序，从第一个路径条目（一般是`target/classes/` 目录）开始处理
  3. **路径拼接与验证**： 它将当前遍历到的类路径条目与请求的资源内部路径进行字符串拼接，形成一个完整的、可供文件系统或 JAR 文件内部访问的候选路径。
     - **拼接示例**：`target/classes/` + `config/db.properties` → `target/classes/config/db.properties`
     - 随后，JVM 会验证这个拼接后的路径是否真实存在且可读。
  4. **返回或继续**：
     1. **查找成功**：一旦在某个类路径条目中验证到资源存在(如果路径写对一般在这里都能找到)，查找过程立即停止，并返回该资源的输入流
     2. **查找失败**：如果在当前条目中未找到，则继续处理类路径列表中的下一个路径条目（例如一个 JAR 文件），并重复步骤 3。
     3. **最终结果**：如果遍历完所有类路径条目后仍未找到资源，方法将返回 `null`



### 如何在代码中获取资源

- 结论：使用不同的**`getResourceAsStream()`方法**

#### 方法1: `Class对象.getResourceAsStream()` (推荐)

- **`Class`类**中的方法签名：

  ```java
  public InputStream 				getResourceAsStream(String name)
  									// 通过此类的类加载器查找并打开指定资源的输入流
  ```

- 这是最常用的方式。

  - **`Class.getResourceAsStream()`** 的文档明确规定了两种**路径写法**：

    - **以 `/` 开头**(推荐)：表示从**类路径的根**开始查找。**这是最推荐、最不容易出错的方式**

    - **不以 `/` 开头**(**几乎必报错**)：表示从**当前类所在的包**的路径开始查找。这绝对会有问题的，资源一般都在resource下

- **示例代码：**

```java
package com.myapp;

import java.io.InputStream;
import java.nio.charset.StandardCharsets;
import java.util.Properties;
import java.util.Scanner;

public class MyService {

    public void loadConfig() {
        // 推荐: 使用斜杠(/)从类路径根加载 config.properties
        try (InputStream input = MyService.class.getResourceAsStream("/config.properties")) {
            if (input == null) {
                System.out.println("Sorry, unable to find config.properties");
                return;
            }

            Properties prop = new Properties();
            prop.load(input); // 加载属性文件

            System.out.println("Database URL: " + prop.getProperty("db.url"));
            System.out.println("Database User: " + prop.getProperty("db.user"));

        } catch (Exception e) {
            e.printStackTrace();
        }
    }

    public void readImageInfo() {
        // 推荐: 使用斜杠(/)从类路径根加载 images/logo.png
        try (InputStream input = MyService.class.getResourceAsStream("/images/logo.png")) {
            if (input == null) {
                System.out.println("Sorry, unable to find logo.png");
                return;
            }
            // 只是演示，我们并不真的读取图片，而是打印它的大小（假设）
            System.out.println("Found logo.png, available bytes: " + input.available());

        } catch (Exception e) {
            e.printStackTrace();
        }
    }
}
```



#### 方法2: `ClassLoader对象.getResourceAsStream()`

- 也可以通过类加载器来获取资源

  - **`CLassLoader`接口**中的方法签名

    ```JAVA
    public InputStream 				getResourceAsStream(String name)
    									// 通过此类的类加载器查找并打开指定资源的输入流。
    ```

  - **注意**：**`ClassLoader`** 的 **`getResourceAsStream()`** **总是** **从类路径的根开始查找**，并且路径**不能以 `/` 开头**。

- **示例代码**

  ```JAVA
  public void loadConfigWithClassLoader() {
      try (InputStream input = MyService.class.getClassLoader().getResourceAsStream("config.properties")) {
          // 注意：这里的路径没有开头的斜杠！
          if (input == null) {
              System.out.println("Sorry, unable to find config.properties via ClassLoader");
              return;
          }
          Properties prop = new Properties();
          prop.load(input);
          System.out.println("Loaded via ClassLoader: " + prop.getProperty("db.url"));
      } catch (Exception e) {
          e.printStackTrace();
      }
  }
  ```



#### 最佳实践与总结

1. **最推荐的方式**：为了避免混淆和路径错误，**始终使用 `Class` 对象并配合以 `/` 开头的绝对路径**。这种方式语义最清晰，代码最健壮。

   ```java
   // 明确从类路径根开始查找，无论当前类在哪个包下
   InputStream in = YourClass.class.getResourceAsStream("/config/app.properties");
   ```

2. **Spring 框架的方式**：在 Spring 环境中，更推荐使用其统一的 `ResourceLoader` 接口，并配合 `classpath:` 前缀

   - `classpath:` 是 Spring 框架提供的一个**伪协议前缀 (pseudo-protocol prefix)**，它明确指示 Spring 的资源加载器 (ResourceLoader) 从**类路径的根**开始查找指定的资源

   ```java
   @Autowired
   private ResourceLoader resourceLoader;
   
   public void loadResource() {
       // "classpath:" 前缀的语义与 Class.getResourceAsStream("/") 完全一致
       Resource resource = resourceLoader.getResource("classpath:config/app.properties");
   }
   ```





# 反射

- 反射 是 Java 语言中一个强大且重要的特性。它允许运行中的 Java 程序对自身进行检查和操作，例如在**运行时获取任意一个类的完整结构信息**，并能够**动态地调用其方法、访问其字段**。这种“反向”探查和操作的能力，使得 Java 代码具有了更高的灵活性和动态性，是**许多高级框架和功能实现的基石**
- 反射的核心是 **`java.lang.Class` 类**以及 **`java.lang.reflect` 包**中的一系列类，如 **`Method`, `Field`, `Constructor`** 等



## 反射的绝对核心——`Class`对象

- 反射的**绝对核心**：**`java.lang.Class`对象**
- **在 Java 的世界里，不存在一个“纯粹的”、不绑定任何具体类的 `Class` 对象**
  - 这个**绑定了某个类**的**`Class`对象**里面有着这个类的**”一切“**
- **一个类在JVM中只有一个`Class`对象**，不要因为**创建了很多这个类的【实例】**，而产生了**`Class`对象也有很多个的这种错觉**
  - 一个类
- 这个**`Class`对象**除了**“某2种情况”**之外，剩余的所有情况下，**`Class `对象**  **一定**   是在 **类加载阶段** 的 **“加载”阶段** **被创建**的
  - **“某两种情况”**如下
    1. **基本数据类型**和 **`void`**的**`Class`对象**
       - **`int.class`, `float.class`, `boolean.class`, `void.class`** 等
       - 它们的 **`Class` 对象**并**不是在某个 “加载” 阶段被创建的，而是在 Java 虚拟机启动和引导的过程中，由 JVM 自己预先创建好的**
    2. **数组类型**
       - **`String[].class`, `int[][].class`** 等
       - 数组**没有对应的 `.class` 文件**。它们的 **`Class` 对象**也**不是通过标准的类加载流程创建的**
         - JVM 的做法是“**按需动态创建**”。当程序第一次在代码中需要**用到某个数组类型时**（例如 **`new String[10]`**，或者 **`Class.forName("[Ljava.lang.String;")`**），JVM 会在内部**即时创建**出这个数组类型对应的 **`Class` 对象**。如果已经创建过了，就直接返回
         - **它是一个由 JVM 直接处理的、特殊的内部流程，而非 `ClassLoader` 去解析一个文件的标准“加载”阶段**
- **如果一个类尚未加载，反射至少是会触发“类加载”阶段中的“加载”的**



## 获取`Class`类的方式

### 通过类名`.class` (静态语法)

- **这是最直接、最安全，也是性能最好的一种方式**

- 当你在**编译时就已经明确知道**要操作哪个类时，这应该是你的**首选**方式

  ```java
  // 对于引用类型
  Class<String> stringClass = String.class;
  Class<Thread> threadClass = Thread.class;
  
  // 对于基本数据类型
  Class<Integer> intClass = int.class;
  Class<Boolean> booleanClass = boolean.class;
  
  // 对于void
  Class<Void> voidClass = void.class;
  ```

  - 特点
    - **编译时安全**：在编译代码的时候，编译器会检查这个类是否存在。如果**类名写错了**（例如 **`Stirng.class`**），在**编译阶段就会直接报错**，而不是等到程序运行时
    - **不触发初始化**：这是它非常重要的一个特性。使用 **`.class`** 获取 **`Class` 对象**时，**只会触发类的加载和链接，但不会触发类的初始化**。这意味着类的静态代码块（**`static {}`**）不会被执行，**静态变量也不会被赋值**
    - **性能最高**：由于在编译时就已经确定，无需在运行时进行方法调用或字符串查找，所以它的执行效率是最高的

  - 应用场景
    - **编译时就已经明确知道**要操作哪个类时，这是**首选**



### 通过对象实例的`getClass()`方法

- 这种方式**从一个已经存在的对象实例出发**

  ```java
  String str = "Hello";
  Class<?> strClass = str.getClass(); // 使用通配符?，因为编译时无法确定具体类型
  
  Date date = new Date();
  Class<?> dateClass = date.getClass();
  ```

  - 特点

    - **运行时确定**：你从一个具体的对象获取它的类型信息。这在**多态场景下非常有用**
    - **类已初始化**：能够调用 **`getClass()`** 的前提是你已经有了一个对象实例 。而创建实例的过程本身就已经触发了类的加载、链接和**初始化**。所以，**`getClass()` 方法**本身**不会触发初始化**，但**它操作的对象所属的类一定是已经初始化过的**。
    - **类型不确定**：返回的 **`Class<?>` 对象类型**在**编译时是不确定**的，**取决于运行时对象的实际类型**。

  - 应用场景

    - 当你手头有一个对象，需要根据它的**运行时实际类型**来进行不同的操作时。

      - 最典型的就是**多态**和**`equals`方法**的实现

        ```java
        // 判断两个对象的运行时类型是否完全相同
        public boolean isSameType(Object obj1, Object obj2) {
            if (obj1 == null || obj2 == null) return false;
            return obj1.getClass() == obj2.getClass();	//这里
        }
        ```



### 通过`Class.forName("全限定类名")`

- 这是最能体现反射**动态性**的方式，也是框架开发中最常用的方式

- 这种方式最能体现反射的动态性，因为你可以传入一个字符串变量来决定加载哪个类

  - 在框架设计中非常常见（比如JDBC加载驱动）

  ```java
  try {
      // 需要提供类的完整包名+类名
      Class<?> driverClass = Class.forName("com.mysql.cj.jdbc.Driver");
      Class<?> personClass = Class.forName("com.example.Person");
  } catch (ClassNotFoundException e) {
      // 如果找不到这个类，会抛出异常
      e.printStackTrace();
  }
  ```

  - 特点
    - **高度动态**：类名是一个字符串，这个字符串可以来自配置文件、用户输入、网络请求等，在程序运行前完全可以是未知的
    - **默认触发初始化**：单参数的 **`Class.forName(String className)`** 不仅会加载类，**默认还会立即执行类的初始化**。这是它和 **`.class` 方式**最本质的区别
    - **可控的初始化**：它有一个重载方法 **`Class.forName(String name, boolean initialize, ClassLoader loader)`**，**允许你手动控制是否要初始化类**。如果 **`initialize`** 设置为 **`false`**，它的行为就和 **`.class`** 类似，**只加载不初始化**
    - **性能开销**：由于涉及到字符串查找、可能的磁盘I/O（查找**`.class`文件**）和类加载过程，性能相较于前两种方式要低

  - 应用场景
    - 在需要**根据外部配置动态加载和使用类**的场景。
      - **JDBC加载驱动**：**`Class.forName("com.mysql.cj.jdbc.Driver");`** 这行代码的目的就是为了加载并**初始化**驱动类，让它把自己注册到**`DriverManager`**中。
      - **Spring等框架**：从XML或注解中读取类名字符串，然后通过 **`Class.forName()`** 加载这些类来创建和管理Bean



### 通过类加载器`ClassLoader.loadClass()`

- 这种方式比较底层，主要由框架和服务器开发者使用

  ```JAVA
  ClassLoader classLoader = this.getClass().getClassLoader();
  try {
      Class<?> personClass = classLoader.loadClass("com.example.Person");
  } catch (ClassNotFoundException e) {
      e.printStackTrace();
  }
  ```

  - 特点
    - **只加载，不链接和初始化**：这是它和 **`Class.forName`** 的核心区别。**`loadClass` 方法**执行后，只完成了**“加载”**阶段，甚至**不会进行链接**。初始化只有在类被首次主动使用时才会发生。
    - **懒加载**：它提供了**最大程度的延迟加载**，只有在绝对必要时才会进行后续步骤

  - 应用场景
    - 需要对类的加载过程进行精细控制的场景，例如实现自定义的类加载逻辑、热部署、代码隔离等。普通应用开发中很少直接使用









## 反射的一些常见操作

### 创建对象

- 反射允许你在**不使用`new`关键字的情况下**，**动态地创建任何类的实例**，**即使是调用私有构造器**



#### 核心类和关键方法

- 核心类：**`java.lang.reflect.Constructor`**
- **关键方法**：
  - **`clazz.getConstructor(paramTypes...)`**：获取匹配参数的**公共**构造器。
  - **`clazz.getDeclaredConstructor(paramTypes...)`**：获取匹配参数的**任意**构造器（包括`private`, `protected`, `default`）。
  - **`constructor.setAccessible(true)`**：**“暴力破解”**，关闭访问权限检查，允许调用私有构造器。
  - **`constructor.newInstance(args...)`**：使用此构造器创建实例，并传入构造参数。



#### 操作示例

```java
Class<Person> personClass = Person.class;

// 1. 调用公共有参构造器
System.out.println("--- 调用公共构造器 ---");
Constructor<Person> publicConstructor = personClass.getConstructor(String.class, int.class);
Person p1 = publicConstructor.newInstance("Alice", 25);
p1.showInfo("p1"); // 输出: p1 -> Name: Alice, Age: 25

// 2. 调用私有构造器
System.out.println("\n--- 调用私有构造器 ---");
Constructor<Person> privateConstructor = personClass.getDeclaredConstructor(String.class);
privateConstructor.setAccessible(true); // 关键一步：解除私有限制
Person p2 = privateConstructor.newInstance("Bob");
p2.showInfo("p2"); // 输出: p2 -> Name: Bob, Age: 0
```



### 操作字段

- 可以动态地读取和修改一个对象的任意字段值，包括私有字段和静态字段



#### 核心类和关键方法

- **核心类**：**`java.lang.reflect.Field`**

- **关键方法**：

  - **`clazz.getField(name)`**：获取一个**公共**字段。

  - **`clazz.getDeclaredField(name)`**：获取此类中声明的**任意**字段。

  - **`field.setAccessible(true)`**：关闭私有字段的访问权限检查。

  - **`field.get(objectInstance)`**：获取指定对象的该字段的值。

  - **`field.set(objectInstance, value)`**：设置指定对象的该字段的值。



#### 操作示例

```JAVA
Class<Person> personClass = Person.class;
Person person = new Person("David", 40);

// 1. 操作公共字段 age
System.out.println("--- 操作公共字段 ---");
Field ageField = personClass.getField("age");
int currentAge = (int) ageField.get(person);
System.out.println("Original age: " + currentAge); // 40
ageField.set(person, 41);
person.showInfo("After age set"); // Age: 41

// 2. 操作私有字段 name
System.out.println("\n--- 操作私有字段 ---");
Field nameField = personClass.getDeclaredField("name");
nameField.setAccessible(true); // 解除私有限制
String currentName = (String) nameField.get(person);
System.out.println("Original name: " + currentName); // David
nameField.set(person, "David Copperfield");
person.showInfo("After name set"); // Name: David Copperfield

// 3. 操作私有静态字段 species
System.out.println("\n--- 操作私有静态字段 ---");
Field speciesField = personClass.getDeclaredField("species");
speciesField.setAccessible(true);
// 访问静态字段，对象实例传 null
String speciesValue = (String) speciesField.get(null);
System.out.println("Species: " + speciesValue); // Homo sapiens
```



### 调用方法

- 可以动态调用一个对象的任意方法，包括私有方法和静态方法



#### 核心类和关键方法

- **核心类**：**`java.lang.reflect.Method`**

- **关键方法**：

  - **`clazz.getMethod(name, paramTypes...)`**：获取一个**公共**方法（包括从父类继承的）。

  - **`clazz.getDeclaredMethod(name, paramTypes...)`**：获取此类中声明的**任意**方法（不包括父类的）。

  - **`method.setAccessible(true)`**：关闭私有方法的访问权限检查。

  - **`method.invoke(objectInstance, args...)`**：调用方法。
    - **`objectInstance`**：要调用哪个对象的方法。**如果方法是静态的，此参数传 `null`**。
    - **`args...`**：方法的参数列表。



#### 操作示例

```java
Class<Person> personClass = Person.class;
Person person = new Person("Charlie", 30);

// 1. 调用公共方法
System.out.println("--- 调用公共方法 ---");
Method showInfoMethod = personClass.getMethod("showInfo", String.class);
showInfoMethod.invoke(person, "Public Call"); // 输出: Public Call -> Name: Charlie, Age: 30

// 2. 调用私有方法
System.out.println("\n--- 调用私有方法 ---");
Method getSecretMethod = personClass.getDeclaredMethod("getSecret");
getSecretMethod.setAccessible(true); // 解除私有限制
String secret = (String) getSecretMethod.invoke(person);
System.out.println("Secret from private method: " + secret); // 输出: My secret is Charlie

// 3. 调用静态方法
System.out.println("\n--- 调用静态方法 ---");
Method staticMethod = personClass.getMethod("staticMethod");
staticMethod.invoke(null, null); // 调用静态方法，对象实例为null
```



### 处理数组

- 反射提供了一个专门的**`Array`类**来动态地创建和操作数组



#### 核心类和关键方法

- **核心类**：**`java.lang.reflect.Array`**

- **关键方法**：
  - **`Array.newInstance(componentType, length)`**：创建一个新数组。

  - **`Array.get(arrayObject, index)`**：获取数组中指定索引的元素。

  - **`Array.set(arrayObject, index, value)`**：设置数组中指定索引的元素。

  - **`Array.getLength(arrayObject)`**：获取数组长度。



#### 操作示例

```java
// 动态创建一个 String 数组，长度为 5
Object array = Array.newInstance(String.class, 5);

// 动态设置数组元素
Array.set(array, 0, "Hello");
Array.set(array, 1, "World");

// 动态获取数组元素
String firstElement = (String) Array.get(array, 0);
System.out.println("First element: " + firstElement); // Hello

// 获取数组长度
System.out.println("Array length: " + Array.getLength(array)); // 5
```



### 获取注解

- 现代框架（如Spring, Mybatis)的基石。反射可以在运行时检查类、方法、字段上是否存在某个注解，并读取注解的属性值。



#### 核心方法

- **`element.isAnnotationPresent(Annotation.class)`**：检查是否存在指定注解。
- **`element.getAnnotation(Annotation.class)`**：获取指定的注解对象。
- **`element.getDeclaredAnnotations()`**：获取元素上声明的所有注解。



#### 操作示例

```java
Class<Person> personClass = Person.class;

// 1. 获取类上的注解
if (personClass.isAnnotationPresent(MyInfo.class)) {
    MyInfo classInfo = personClass.getAnnotation(MyInfo.class);
    System.out.println("Class Annotation Value: " + classInfo.value()); // A sample class
}

// 2. 获取方法上的注解
Method showInfoMethod = personClass.getMethod("showInfo", String.class);
if (showInfoMethod.isAnnotationPresent(MyInfo.class)) {
    MyInfo methodInfo = showInfoMethod.getAnnotation(MyInfo.class);
    System.out.println("Method Annotation Value: " + methodInfo.value()); // A public method
}
```



## 动态代理

### 代理

- 所有优秀软件设计都在追求的一个目标——**开闭原则（Open-Closed Principle）**：**对扩展开放，对修改关闭**

- **代理模式**是一种设计模式。简单来说，就是**我们不直接访问目标对象，而是通过一个中介（代理对象）去访问**。这个中介可以在我们访问目标前后，做一些**“额外”的事情**

- 代理模式和装饰器模式在**代码结构**上确实**极其相似**，以至于很多人都会把它们**混淆**。它们都遵循了**“包裹”原始对象**的思想，并且通常都**基于共同的接口**

  - 但是，它们的**设计意图 (Intent)** 是完全不同的

    |              | 代理模式                                                     | 装饰器模式                                                   |
    | ------------ | ------------------------------------------------------------ | ------------------------------------------------------------ |
    | 核心意图     | 控制访问                                                     | 增强功能                                                     |
    | 关注点       | 关注**过程**。代理不关心目标对象的功能是什么，它只关心在调用这个功能**前后**，它需要做什么控制（如权限、缓存、网络连接） | 关注**内容**。装饰器就是为了给目标对象**添加新的、额外的功能**，让它变得更强大。 |
    | 与目标的关系 | 代理类和真实类在功能上通常是**一对一**的。一个代理类通常只代理一种类型的对象。 | 装饰器和真实类可以**自由组合、层层包裹**。一个对象可以被一个或多个不同的装饰器动态地、任意地增强。 |
    | 对客户端     | 代理对客户端是**透明的**。客户端通常不知道自己在使用代理，它以为自己直接在和真实对象交互。 | 装饰器对客户端**通常不是透明的**。客户端需要主动地用装饰器去“包装”一个对象，以获得增强后的功能。 |

  - 代理模式的根本意图是**“控制”**，在这个控制的过程中，常常会表现出**“添加功能”**的现象，但这只是实现控制时**附带的产物**；而装饰器模式的根本意图就是**“增强功能”**本身，它就是为了**添加功能**而生的

    - 代理模式的**“添加功能”**，很多时候是它在完成自己“核心使命”时的一种**自然结果或附带效应**，而不是它的出发点



### 静态代理

- 在动态代理出现之前，我们只能手动编写代理类，我们称之为**“静态代理”**
- 静态代理**不修改原始代码**，而是通过**新增一个代理类**，让这个新类**实现**与目标类相同的接口（或**继承**目标类）。在这个新类的方法中，我们可以自由地**添加**各种增强逻辑，同时在内部**包裹并调用**原始目标对象来完成核心任务。整个过程，原始代码保持不变。
- **静态代理的特点**：代理类是在**编译时**就已经创建好的，它的**`.class`文件**是实实在在存在于硬盘上的
- 缺点：代码冗余、不易维护



### 动态代理

- 动态代理是基于接口的

  > 因为Java是单继承的，你通过动态代理中的**`newProxyInstance(ClassLoader loader, Class<?>[] interfaces, InvocationHandler h)`方法**创建的**类**因为需要具备代理的功能，是继承了**`Proxy`类**的。
  >
  > 而创建的这个类又必须能被当作你的业务对象来使用，所以它必须实现你指定的业务接口.
  >
  > 当然在**`Proxy`类**中创建代理的方法中也要求了让你传入要代理的接口，是强制的，你不行也得行，密码的

- 代理类是在程序**运行时**动态生成的，而不是在编译期就写好的

- 我们只需要编写一个**“处理器”**（Handler），在这个**处理器里**定义通用的**代理逻辑**（例如打印日志、权限校验等）

- 代理类不是我们手动编写的，而是在**程序运行时**，由JVM根据我们提供的信息**动态生成**的。它没有**`.java`源文件**，直接在内存中生成**`.class`字节码**

- 非常灵活，可以为任意接口的实现类生成代理，极大地减少了代码量，实现了业务逻辑与非业务逻辑（如日志、事务）的解耦

- 动态代理**不能**直接**“伸入”到原始方法内部更改内部逻辑**，但是**可以重写整个逻辑**

- 在获取类加载器时，使用**`被代理的对象名.getClass().getClassLoader()`** 比 **`代理的接口名.class.getClassLoader()`**更具普适性。因为这能确保代理类和**被代理的目标实例**使用同一个类加载器，这在更复杂的类加载环境中会更健壮



#### 核心组件

##### **`java.lang.reflect.Proxy`代理类**

- 这是一个**工厂类**，专门用来创建代理对象。最核心的方法是 
  **`newProxyInstance(ClassLoader loader, Class<?>[] interfaces, InvocationHandler h)`**

  ```java
  public static Object newProxyInstance(ClassLoader loader, Class<?>[] interfaces, InvocationHandler h)
  				//返回一个代理类的实例，该代理类会自动实现我们指定的接口数组(即第二个参数)中的所有接口，
      			//并将方法调用分派给指定的调用处理器 h
  ```

- **`Proxy.newProxyInstance(ClassLoader loader, Class<?>[] interfaces, InvocationHandler h)`**

  - **`loader`**: 类加载器，用于**加载动态生成的代理类**。通常用目标类的加载器即可。
  - **`interfaces`**: 一个接口数组，告诉代理对象它需要**实现哪些接口**的代理
  - **`h`**: 一个 **`InvocationHandler` 对象**，它是代理的“大脑”，所有的调用都会被转发给它。



##### **`java.lang.reflect.InvocationHandler`调用处理器** 接口

- 这是一个**接口**，只包含一个方法 **`invoke(Object proxy, Method method, Object[] args)`**。

  ```java
  public Object 			invoke(Object proxy, Method method, Object[] args)
  							// 处理代理实例上的方法调用并返回结果。这是实现所有代理逻辑的核心方法。
  							// proxy: 调用该方法的代理实例。Java运行时系统自动传入的、最终创建好的那个代理对象实例
  							// method: 被调用的 Method 实例。
  							// args: 传递给方法的参数数组；如果方法没有参数，则为 null。
  ```

  

- 当我们调用代理对象的**任何方法**时，这个调用都会被拦截下来，转而执行**`InvocationHandler`**的**`invoke`**方法

- **参数详解**：

  - **`proxy`**: 动态生成的那个代理对象本身。**Java运行时系统自动传入的、最终创建好的那个代理对象实例**
  - **`method`**: 被调用的方法对象（**`Method`类**的实例），比如**`addUser`**方法
  - **`args`**: 调用方法时传入的参数数组

  

#### 动态代理示例

##### 1.定义想被代理的接口

```java
public interface Star {
    //想被代理的接口
    //唱歌
    public String sing(String name);

    //跳舞
    public void dance();
}
```

##### 2.创建接口的实现类

```java
public class BigStar implements Star {
    private String name;

    public BigStar() {
    }

    public BigStar(String name) {
        this.name=name;
    }

    //唱歌
    @Override
    public String sing(String name) {
        System.out.println(this.name + "正在唱 " + name + " 歌曲");
        return "你干嘛";
    }

    //跳舞
    @Override
    public void dance() {
        System.out.println(this.name + "正在跳舞");
    }


    /**
     * 获取
     * @return name
     */
    public String getName() {
        return name;
    }

    /**
     * 设置
     * @param name
     */
    public void setName(String name) {
        this.name = name;
    }

    public String toString() {
        return "BigStar{name = " + name + "}";
    }
}
```

##### 3.创建调用处理器`InvocationHandler`

- 定义代理逻辑

  - 可以写匿名内部类，也可以标准普通写

    > **`java.lang.reflect.Proxy`代理类**
    >
    > ```java
    > public static Object newProxyInstance
    > 						(ClassLoader loader, Class<?>[] interfaces, InvocationHandler h)
    > 				//返回一个代理类的实例，该代理类会自动实现我们指定的接口数组(即第二个参数)中的所有接口，
    >  			//并将方法调用分派给指定的调用处理器 h
    > ```
    >
    > **`java.lang.reflect.InvocationHandler`调用处理器** 接口
    >
    > ```java
    > public Object 		invoke(Object proxy, Method method, Object[] args)
    > 						// 处理代理实例上的方法调用并返回结果。这是实现所有代理逻辑的核心方法。
    > 						// proxy: 调用该方法的代理实例。Java运行时系统自动传入的、最终创建好的那个代理对象实例
    > 						// method: 被调用的 Method 实例。
    > 						// args: 传递给方法的参数数组；如果方法没有参数，则为 null。
    > ```

    

    ```java
    public static Star createProxy(BigStar bg) throws Exception {
        Star s = (Star) Proxy.newProxyInstance(//调用Proxy实例化一个代理类的对象，
            							//该代理类会自动实现我们指定的接口数组(即第二个参数)中的所有接口
            							//并将方法调用分派给指定的调用处理器 h
            bg.getClass().getClassLoader(), //传入类加载器
        	new Class[]{Star.class} ,	//传入接口数组，告诉代理对象它需要实现哪些接口的代理
           	new InvocationHandler() {//匿名内部类实现调用处理器，调用处理器是代理的“大脑”，所有的调用都会被转发给它
            @Override
            public Object invoke(Object proxy, Method method, Object[] args) throws Throwable {
                	//这个invoke是具体的逻辑，处理代理实例上的方法调用并返回结果。这是实现所有代理逻辑的核心方法
                if("sing".equals(method.getName())){
                    System.out.println("唱歌");
                    System.out.println("收钱");
                }else if("dance".equals(method.getName())){
                    System.out.println("跳舞");
                    System.out.println("发钱");
                }
                //这里单纯展示一下还能调用里面的别的方法，不过不能深入进去直接修改已有逻辑，你可以替代，不能直接那样
                return method.invoke(bg, args);//Method中的invoke方法
                		//表示在指定的参数一对象上，传入 指定的 可变参数二 来调用此 Method 对象所表示的方法
            }
        });
        return s;//方法返回一个Star代理类的实例
    }
    ```

    

## 相关类与体系

- 反射相关类是 **`java.lang.Class` 类**以及 **`java.lang.reflect` 包**中的一系列类



### 反射体系图

![image-20250725024137671](./assets/image-20250725024137671.png)



### 一些重要的类与接口

#### 1

- **`Constructor`**、**`Method`**、**`Field`**

  - **干嘛的？**：这“三巨头”分别代表了类的**构造器**、**方法**和**字段**。它们是反射操作的具体承载者。
    - 用 `Constructor` 对象来 `newInstance()` 创建实例。
    - 用 `Method` 对象来 `invoke()` 调用方法。
    - 用 `Field` 对象来 `get()` 和 `set()` 读写字段值。

  - **`AccessibleObject`**
    - **干嘛的？**：它是 `Constructor`、`Method`、`Field` 这三个类的**父类**。它提供了一个非常重要的方法：`setAccessible(boolean flag)`。我们用它来“暴力破解”私有成员的访问限制，这正是反射强大威力的体现。

- **`Array`**

  - **干嘛的？**：一个专门用来通过反射**动态创建和操作数组**的工具类。比如 `Array.newInstance(componentType, length)` 可以在运行时创建一个指定类型和长度的数组。

- **`Modifier`**

  - **干嘛的？**：一个工具类，里面全是静态方法，用来**解析修饰符**。比如 `Method` 对象有一个 `getModifiers()` 方法返回一个`int`值，你可以用 `Modifier.isPublic(int mod)`、`Modifier.isStatic(int mod)` 等方法来判断这个方法是不是`public`的、是不是`static`的。

- **`InvocationTargetException`**

  - **干嘛的？**：一个特殊的**异常**。当你通过反射调用一个方法（`method.invoke()`）时，如果**被调用的那个方法本身**抛出了一个异常，那么反射机制会把这个原始异常**包装**在 `InvocationTargetException` 里面再抛出来。你需要调用 `getCause()` 方法才能拿到真正的原始异常。

#### 2

- **`Proxy`**

  - **干嘛的？**：用于创建**动态代理**对象。它可以在运行时为一个或多个接口动态地生成一个实现类，让你能够在不修改原有代码的情况下，拦截和增强方法调用（AOP思想）。

  - **重要性**：**非常重要**。是Spring AOP等框架的底层技术基石之一。

- **`InvocationHandler`**

  - **干嘛的？**：它是一个接口，与 `Proxy` 配合使用。`Proxy` 创建出来的代理对象的**所有方法调用**，都会被转发到 `InvocationHandler` 的 `invoke` 方法中。你在这个方法里编写你的增强逻辑（比如打印日志、事务控制）。

  - **重要性**：**非常重要**。`Proxy` 的灵魂伴侣，学 `Proxy` 必学它。

#### 3

- **`Type`**：一个顶层接口，代表Java中所有的类型。它是下面所有`...Type`接口的父接口。

  - **`ParameterizedType`**：代表一个**参数化类型**，比如 `List<String>`。通过它可以拿到尖括号里的实际类型参数（`String`）。

  - **`TypeVariable`**：代表一个**类型变量**，比如 `class MyList<T> {}` 里面的 `T`。

  - **`WildcardType`**：代表一个**通配符类型**，比如 `List<? extends Number>` 里面的 `? extends Number`。

  - **`GenericArrayType`**：代表一个**泛型数组**，比如 `T[]` 或者 `List<String>[]`。

- **`Annotated...` 系列**（`AnnotatedElement`, `AnnotatedType`, `AnnotatedArrayType` 等）
  - **干嘛的？**：`AnnotatedElement` 是一个非常重要的接口，`Class`, `Method`, `Field`等都实现了它，提供了获取**注解**的能力（如`getAnnotation`）。而其他 `Annotated...Type` 接口则允许你获取到更细粒度的注解，比如标注在泛型类型参数上的注解。



### `java.lang.Class`类

#### 方法

- **静态工厂方法**

```java
public static Class<?> 		forName(String className)
								// 返回与具有给定字符串名称的类或接口关联的 Class 对象。
public static Class<?> 		forName(String name, boolean initialize, ClassLoader loader)
								// 使用给定的类加载器返回与给定字符串名称关联的 Class 对象。可指定是否初始化类。
public static Class<?> 		forName(Module module, String name)
								// (Java 9+) 返回给定模块中具有给定二进制名称的 Class。
```



- **类基本信息**

```java
public String 					getName()
									// 返回此 Class 对象表示的实体（类、接口、数组、原始类型或 void）的名称。
public String 					getSimpleName()
									// 返回源代码中给出的基础类的简单名称。
public String 					getCanonicalName()
									// 返回 Java 语言规范定义的基础类的规范名称。
public String 					getTypeName()
									// 返回此类型的名称的信息字符串（可能包含泛型信息）。
public int 						getModifiers()
									// 以整数形式返回此类或接口的 Java 语言修饰符（如 public, static, final）。
public Package 					getPackage()
									// 获取此类的包。
public String 					getPackageName()
									// (Java 9+) 返回此类的包的全限定名。
public ClassLoader 				getClassLoader()
									// 返回此类的类加载器。对于启动类加载器加载的类，可能返回 null。
public Module 					getModule()
									// (Java 9+) 返回此类或接口所属的模块。
public ProtectionDomain 		getProtectionDomain()
									// 返回此类的 ProtectionDomain。
```



- **反射：获取构造方法**

```java
public Constructor<T> 			getConstructor(Class<?>... parameterTypes)
									// 返回指定的公共构造方法对象。
public Constructor<?>[] 		getConstructors()
									// 返回此类所有公共构造方法对象的数组。
public Constructor<T> 			getDeclaredConstructor(Class<?>... parameterTypes)
									// 返回指定的构造方法对象（无论访问修饰符）。
public Constructor<?>[] 		getDeclaredConstructors()
									// 返回此类声明的所有构造方法对象的数组（无论访问修饰符），不包括继承的。
```



- **反射：获取字段**

```java
public Field 					getField(String name)
									// 返回指定的公共字段对象（包括从父类继承的）。
public Field[] 					getFields()
									// 返回此类所有公共字段对象的数组（包括从父类继承的）。
public Field 					getDeclaredField(String name)
									// 返回指定的字段对象（在此类中声明，无论访问修饰符）。
public Field[] 					getDeclaredFields()
									// 返回在此类中声明的所有字段对象的数组（无论访问修饰符），不包括继承的。
```



- **反射：获取方法**

```java
public Method 					getMethod(String name, Class<?>... parameterTypes)
									// 返回指定的公共方法对象（包括从父类和接口继承的）。
public Method[] 				getMethods()
									// 返回此类所有公共方法对象的数组（包括从父类和接口继承的）。
public Method 					getDeclaredMethod(String name, Class<?>... parameterTypes)
									// 返回指定的方法对象（在此类或接口中声明，无论访问修饰符）。
public Method[] 				getDeclaredMethods()
									// 返回在此类或接口中声明的所有方法对象的数组（无论访问修饰符），不包括继承的。
```



- **类层次结构与继承**

```java
public Class<? super T> 		getSuperclass()
									// 返回此类的直接超类的 Class 对象。
public Type 					getGenericSuperclass()
									// 返回此类的直接超类的 Type（包含泛型信息）。
public Class<?>[] 				getInterfaces()
									// 返回此类直接实现的接口的 Class 对象数组。
public Type[] 					getGenericInterfaces()
									// 返回此类直接实现的接口的 Type 数组（包含泛型信息）。
public Class<?>[] 				getClasses()
									//返回所有公共的成员类和接口（包括继承的）。
public Class<?>[] 				getDeclaredClasses()
									//返回所有直接声明的成员类和接口（无论访问修饰符，不含继承的）。
public Class<?> 				getDeclaringClass()
									// 如果此类是内部类，则返回其声明所在的外部类的 Class 对象。
public Class<?> 				getEnclosingClass()
									// 返回此类的直接外层类（如果它是内部类）。
public Method 					getEnclosingMethod()
									// 如果此类是定义在方法内的本地类或匿名类，则返回其外层方法。
public Constructor<?> 			getEnclosingConstructor()
									// 如果此类是定义在构造方法内的本地或匿名类，则返回其外层构造方法。
```



- **注解处理** 

```java
public boolean 						isAnnotationPresent(Class<? extends Annotation> annotationClass)
										// 检查是否存在指定类型的注解。
public<A extends Annotation> A 		getAnnotation(Class<A> annotationClass)
										// 如果存在指定类型的注解，则返回该注解，否则返回 null。
public Annotation[] 				getAnnotations()
										// 返回此元素上存在的所有注解。
public <A extends Annotation> A[] 	getAnnotationsByType(Class<A> annotationClass)
										// 返回此元素上存在的所有指定类型的注解（包括重复注解）。
public <A extends Annotation> A 	getDeclaredAnnotation(Class<A> annotationClass)
										// 如果直接存在指定类型的注解，则返回该注解，否则返回 null（不检查父类）。
public Annotation[] 				getDeclaredAnnotations()
										// 返回直接在此元素上声明的所有注解（不检查父类）。
public <A extends Annotation> A[] 	getDeclaredAnnotationsByType(Class<A> annotationClass)
									//(已核对加入)返回此元素直接或间接存在的所有指定类型注解(用于可重复注解，不检查父类)
public AnnotatedType 				getAnnotatedSuperclass()
										// (Java 8+) 返回一个表示超类的 AnnotatedType 对象（包含类型注解）。
public AnnotatedType[] 				getAnnotatedInterfaces()
										// (Java 8+) 返回表示超接口的 AnnotatedType 对象数组。
```



- **类型检查与转换**

```java
public boolean 						isInstance(Object obj)
										// 判断指定对象是否是此 Class 表示的类或其子类的实例（等价于 instanceof）。
public boolean 						isAssignableFrom(Class<?> cls)
										// 判断此 Class 是否是指定 Class 的父类或父接口。
public<U> Class<? extends U> 		asSubclass(Class<U> clazz)
										// 将此 Class 对象向下转型为其指定子类类型。
public T 							cast(Object obj)
										// 将一个对象强制类型转换为此 Class 表示的类型。
public boolean 						isInterface()
										// 判断此 Class 是否表示一个接口。
public boolean 						isArray()
										// 判断此 Class 是否表示一个数组。
public boolean 						isPrimitive()
										// 判断此 Class 是否表示一个原始类型（如 int, float 等）。
public boolean 						isAnnotation()
										// 判断此 Class 是否表示一个注解接口。
public boolean 						isEnum()
										// 判断此 Class 是否表示一个枚举。
public boolean 						isRecord()
										// (Java 16+) 判断此 Class 是否表示一个记录类。
public boolean 						isSealed()
										// (Java 17+) 判断此 Class 是否表示一个密封类或接口。
public boolean 						isAnonymousClass()
										// 判断此 Class 是否是匿名类。
public boolean 						isLocalClass()
										// 判断此 Class 是否是本地类（方法内定义的类）。
public boolean 						isMemberClass()
										// 判断此 Class 是否是成员内部类。
public boolean 						isSynthetic()
										// 判断此 Class 是否是编译器生成的合成类。
public boolean 						isHidden()
										// (Java 15+) 判断此类是否是隐藏类
```



- **数组、枚举、记录、签名**

```java
public Class<?> 			getComponentType()
								// 如果此类是数组，则返回其组件类型的 Class 对象。
public Class<?> 			componentType()
								// (Java 12+) 功能同 getComponentType()。
public Class<?> 			arrayType()
								// (Java 12+) 返回一个数组类型，其组件类型为此 Class。
public T[] 					getEnumConstants()
								// 如果此类是枚举，则返回其所有枚举实例的数组。
public RecordComponent[] 	getRecordComponents()
								// (Java 16+) 如果此类是记录类，则返回其所有记录组件的数组。
public Object[] 			getSigners()
								// 获取此类的签名者信息（用于安全校验）。
```



- **嵌套、密封类与泛型**

```java
public Class<?> 				getNestHost()
									// (Java 11+) 返回此成员所属的嵌套结构的宿主类。
public Class<?>[] 				getNestMembers()
									// (Java 11+) 返回此宿主类中的所有嵌套成员。
public boolean 					isNestmateOf(Class<?> c)
									// (Java 11+) 判断指定的类是否与此类是同一个嵌套结构的成员。
public Class<?>[] 				getPermittedSubclasses()
									// (Java 17+) 如果此类是密封类，则返回其允许的直接子类/子接口数组。
public TypeVariable<Class<T>>[] getTypeParameters()
									// 返回此泛型声明所声明的类型变量的 TypeVariable 数组。
```



- **资源、实例化与断言**

```java
public URL 						getResource(String name)
									// 通过此类的类加载器查找具有给定名称的资源。
public InputStream 				getResourceAsStream(String name)
									// 通过此类的类加载器查找并打开指定资源的输入流。
public T 						newInstance()
									//(已废弃)调用类的无参构造方法创建新实例.推荐使用getConstructor().newInstance()
public boolean 					desiredAssertionStatus()
									// (已核对加入) 返回此类在初始化时将被分配的断言状态
```



- **字符串与描述符**

```java
public String 					toString()
									// 返回此 Class 对象的字符串表示形式(如 "class java.lang.String")
public String 					toGenericString()
									// 返回描述此 Class 的字符串，包含修饰符和类型参数信息
public String 					descriptorString()
									//(Java 12+)返回此实体(类、接口、数组等)的JVM描述符字符串
public boolean 					desiredAssertionStatus()
									// 返回在调用此方法时，如果此类将被初始化，那么将分配给该类的断言状态。
									// 它的返回值取决于一系列设置和命令行参数的组合（例如 -ea 或 -da）
    								//可以让你在类真正初始化之前，预先判断它的断言开关是打开还是关闭
```



### `java.lang.reflect`包

#### `AnnotatedElement`接口

- **`AnnotatedElement` 接口**代表了在当前 Java 虚拟机中一个“可被注解”的程序元素。所有希望能够存储和反射性地读取注解的程序元素（如 **`Class`, `Method`, `Field`, `Constructor`, `Package`** 等）都实现了这个接口

##### 方法

- **获取存在的注解**

```java
public <T extends Annotation> T 			getAnnotation(Class<T> annotationClass)
												// 如果此元素上存在指定类型的注解，则返回该注解，否则返回 null
public Annotation[] 						getAnnotations()
												// 返回此元素上存在的所有注解的数组
public default <T extends Annotation> T[] 	getAnnotationsByType(Class<A> annotationClass)
												// 返回与此元素关联的所有指定类型的注解（支持可重复注解）。
public default boolean 						isAnnotationPresent(Class<? extends Annotation> annotationClass)
												// 如果指定类型的注解在此元素上存在，则返回 true，否则返回 false。
```



- **获取直接声明的注解**

```java
public Annotation[] 						getDeclaredAnnotations()
												// 返回直接声明在此元素上的所有注解的数组
public default <T extends Annotation> T 	getDeclaredAnnotation(Class<T> annotationClass)
												// 如果指定类型的注解直接存在于此元素上，则返回该注解，否则返回null
public default <T extends Annotation> T[] 	getDeclaredAnnotationsByType(Class<A> annotationClass)
												// 返回直接或间接存在于此元素的指定类型的所有注解（支持可重复注解）
```



#### `AccessibleObject`类

- 基类，为 **`Field`, `Method`, `Constructor`** 提供了共同的核心功能

##### 方法

- **访问控制**

```java
public void 				setAccessible(boolean flag)
								// 设置此反射对象的 accessible 标志。
								// true 表示抑制 Java 语言的访问控制检查，允许访问私有、受保护成员。
								// false 表示实施 Java 语言的访问控制检查。
public final boolean 		trySetAccessible()
								// (Java 9+) 尝试将此反射对象的 accessible 标志设置为 true 并返回操作是否成功。
								// 这是一个更安全的操作，尤其是在有安全管理器（SecurityManager）的环境下。
public final boolean 		canAccess(Object obj)
								// (Java 9+) 测试此反射对象是否可以被调用者访问。这是一个实例级别的检查。
public boolean 				isAccessible()
								// (已废弃) 返回此反射对象的 accessible 标志的值。
								// 废弃原因：方法名有误导性。它并不检查成员是否“可访问”，而是检查“访问控制检查是否被抑制”。
public static void 			setAccessible(AccessibleObject[] array, boolean flag)
								// 一个便捷方法，用一次安全检查来为一组反射对象设置 accessible 标志，效率更高。
```



- **注解处理**

```java
public <T extends Annotation> T 	getAnnotation(Class<T> annotationClass)
										// 如果此元素上存在指定类型的注解，则返回该注解，否则返回 null（会检查继承）。
public Annotation[] 				getAnnotations()
										// 返回此元素上存在的所有注解的数组（会检查继承）。
public <T extends Annotation> T[] 	getAnnotationsByType(Class<T> annotationClass)
										// 返回与此元素关联的所有指定类型的注解（支持可重复注解，会检查继承）。
public <T extends Annotation> T 	getDeclaredAnnotation(Class<T> annotationClass)
										// 如果指定类型的注解直接存在于此元素上，则返回该注解，否则返回 null(不检查继承)
public Annotation[] 				getDeclaredAnnotations()
										// 返回直接声明在此元素上的所有注解的数组（不检查继承）
public <T extends Annotation> T[] 	getDeclaredAnnotationsByType(Class<T> annotationClass)
										// 返回直接或间接存在于此元素的指定类型的所有注解（支持可重复注解，不检查继承）
public boolean 						isAnnotationPresent(Class<? extends Annotation> annotationClass)
										// 如果指定类型的注解在此元素上存在，则返回 true，否则返回 false（会检查继承）
```



#### `Executable`抽象类

- **`Method` 和 `Constructor` 的共享基类**。它提供了**用于分析方法和构造函数的参数、返回类型、异常、修饰符等信息的通用 API**

##### 方法

- **基本信息**

```java
public abstract Class<?> 	getDeclaringClass()
								// 返回声明此可执行文件（方法或构造函数）的类或接口的 Class 对象。
public abstract String 		getName()
								// 返回此可执行文件的名称（对于构造函数，是其类的全限定名）。
public abstract int 		getModifiers()
								// 以整数形式返回此可执行文件的 Java 语言修饰符。
```



- **参数信息**

```java
public int 						getParameterCount()
					// 返回此可执行文件的形式参数数量
public Parameter[] 				getParameters()
					// (Java 8+)返回一个Parameter对象数组，表示此可执行文件的所有参数
public abstract Class<?>[] 		getParameterTypes()
					// 返回一个Class对象数组，表示此可执行文件的所有形式参数类型
public Type[] 					getGenericParameterTypes()
					// 返回一个Type对象数组，表示此可执行文件的所有形式参数类型（包含泛型信息）
public abstract Annotation[][] 	getParameterAnnotations()
					// 返回一个二维数组，表示此可执行文件所有参数上的注解。array[i][j]是第i个参数上的第j个注解
public AnnotatedType[]		 	getAnnotatedParameterTypes()
					// (Java 8+) 返回一个AnnotatedType对象数组，表示此可执行文件所有形式参数的类型(包含类型注解)
public AnnotatedType 			getAnnotatedReceiverType()
					// (Java 8+) 返回一个AnnotatedType对象，表示此可执行文件的接收者类型(即this的类型，包含类型注解)
```



- **返回类型信息**

```java
public abstract AnnotatedType 	getAnnotatedReturnType()
				// (Java 8+) 返回一个 AnnotatedType 对象，表示此可执行文件的返回类型（包含类型注解）。
```



-  **异常信息**

```java
public abstract Class<?>[] 		getExceptionTypes()
						// 返回一个 Class 对象数组，表示此可执行文件声明要抛出的异常类型。
public Type[] 					getGenericExceptionTypes()
						// 返回一个 Type 对象数组，表示此可执行文件声明要抛出的异常类型（包含泛型信息）。
public AnnotatedType[] 			getAnnotatedExceptionTypes()
						// (Java 8+) 返回一个 AnnotatedType 对象数组,表示此可执行文件声明要抛出的异常类型(包含类型注解)
```



-  **其他属性与泛型**

```java
public abstract TypeVariable<?>[] 	getTypeParameters()
						// 返回一个 TypeVariable 对象数组，表示此可执行文件声明的泛型类型参数。
public boolean 						isVarArgs()
						// 如果此可执行文件被声明为接受可变数量的参数（varargs），则返回 true。
public boolean 						isSynthetic()
						// 如果此可执行文件是编译器生成的合成构造，则返回 true。
```



- **注解与字符串表示**

```java
public <T extends Annotation> T 	getAnnotation(Class<T> annotationClass)
						// 如果此元素上存在指定类型的注解，则返回该注解，否则返回 null。
public Annotation[] 				getAnnotations()
						// (已补充) 返回此元素上存在的所有注解的数组。
public <T extends Annotation> T[] 	getAnnotationsByType(Class<T> annotationClass)
						// 返回与此元素关联的所有指定类型的注解（支持可重复注解）。
public Annotation[] 				getDeclaredAnnotations()
						// 返回直接声明在此元素上的所有注解的数组。
public <T extends Annotation> T 	getDeclaredAnnotation(Class<T> annotationClass)
						//如果指定类型的注解直接存在于此元素上，则返回该注解，否则返回 null。
public <T extends Annotation> T[] 	getDeclaredAnnotationsByType(Class<T> annotationClass)
						//返回直接或间接存在于此元素的指定类型的所有注解（支持可重复注解）。
public boolean 						isAnnotationPresent(Class<? extends Annotation> annotationClass)
						//如果指定类型的注解在此元素上存在，则返回 true，否则返回 false。
```



#### `Member`接口

- **`Member`**是一个接口，它反映了单个成员（字段或方法）或构造函数的基本信息。**`Field`**, **`Method`**, 和 **`Constructor`**类都实现了这个接口

##### 常量

```java
public static final int 	DECLARED
					// 标识类或接口的已声明成员的集合。供 Class.getDeclaredClasses() 等方法内部使用。
public static final int 	PUBLIC
					// 标识类或接口的所有公共成员的集合，包括继承的成员。供 Class.getClasses() 等方法内部使用。
```



##### 方法

```java
public Class<?> 			getDeclaringClass()
						// 返回表示声明此成员或构造函数的类或接口的 Class 对象。
public int 					getModifiers()
						// 以整数形式返回此成员或构造函数的 Java 语言修饰符。
public String 				getName()
						// 返回此成员或构造函数的基础简单名称。
public boolean 				isSynthetic()
						// 如果此成员是由编译器引入的合成构造，则返回 true；否则返回 false。
```



#### `Constructor`类

- **构造函数访问**

##### 方法

- **实例化对象**

```java
public T 			newInstance(Object... initargs)
				// 使用此 Constructor 对象表示的构造函数，通过指定的初始化参数来创建并初始化一个新的实例。
```

- **独有方法与重写方法**

```java
public Class<T> 						getDeclaringClass()
				// (重写 Executable) 返回表示声明此构造函数的类的 Class 对象。
public String 							getName()
				// (重写 Executable) 以字符串形式返回此构造函数的名称（即其类的全限定名）。
public int 								getModifiers()
				// (重写 Executable) 以整数形式返回此构造函数的 Java 语言修饰符。
public TypeVariable<Constructor<T>>[] 	getTypeParameters()
				// (重写 Executable) 返回一个 TypeVariable 对象数组，表示此构造函数声明的泛型类型参数。
public AnnotatedType 					getAnnotatedReturnType()
				// (重写 Executable) 返回一个 AnnotatedType 对象，表示此构造函数的返回类型（总是 void）。
public boolean 							equals(Object obj)
				// 比较此 Constructor 与指定对象是否相等。
public int 								hashCode()
				// 返回此 Constructor 的哈希码。
public String 							toString()
				// 返回描述此 Constructor 的字符串。
public String 							toGenericString()
				// (重写 Executable) 返回描述此 Constructor 的字符串，包括其泛型参数。
```



#### `Method`类

- **方法**

##### 方法

- **调用方法**

```java
public Object 			invoke(Object obj, Object... args)
								// 在指定的对象 obj 上，使用指定的参数 args 来调用此 Method 对象所表示的方法。
								// 如果方法是静态的，则 obj 参数应为 null。								
```

- **独有或重写方法**

```java
public Class<?> 		getReturnType()
							// 返回一个 Class 对象，该对象表示此 Method 对象所表示的方法的正式返回类型。
public Type 			getGenericReturnType()
							// 返回一个 Type 对象，该对象表示此 Method 对象所表示的方法的正式返回类型（包含泛型信息）。
public AnnotatedType 	getAnnotatedReturnType()
							// (重写 Executable) 返回一个 AnnotatedType 对象，表示此方法的返回类型（包含类型注解）。
public Object 			getDefaultValue()
							// 返回此 Method 实例所表示的注解成员的默认值。如果成员不是注解类型或没有默认值，则返回 null
public boolean 			isBridge()
							// 如果此方法是编译器生成的桥接方法，则返回 true。
public boolean 			isDefault()
							// 如果此方法是接口中的默认方法，则返回 true。
public Class<?> 		getDeclaringClass()
							// (重写 Executable) 返回表示声明此方法的类或接口的 Class 对象。
public String 			getName()
							// (重写 Executable) 以字符串形式返回此方法的名称。
public int 				getModifiers()
							// (重写 Executable) 以整数形式返回此方法的 Java 语言修饰符。
public TypeVariable<Method>[] 	getTypeParameters()
							// (重写 Executable) 返回一个 TypeVariable 对象数组，表示此方法声明的泛型类型参数。
public boolean			equals(Object obj)
							// 比较此 Method 与指定对象是否相等。
public int 				hashCode()
							// 返回此 Method 的哈希码。
public String 			toString()
							// 返回描述此 Method 的字符串。
public String 			toGenericString()
```



#### `Field`类

- **字段**

##### 方法

- **通用 Get/Set**

```java
public Object 			get(Object obj)
							// 返回指定对象上此 Field 表示的字段的值。如果字段是静态的，则 obj 参数可为 null。
public void 			set(Object obj, Object value)
							// 将指定对象上此 Field 表示的字段设置为指定的新值。
```



- **原始类型get**

```java
public boolean 			getBoolean(Object obj)
							// 获取一个静态或实例 boolean 字段的值。
public byte 			getByte(Object obj)
							// 获取一个静态或实例 byte 字段的值。
public char 			getChar(Object obj)
							// 获取一个静态或实例 char 字段的值。
public double 			getDouble(Object obj)
							// 获取一个静态或实例 double 字段的值。
public float 			getFloat(Object obj)
							// 获取一个静态或实例 float 字段的值。
public int 				getInt(Object obj)
							// 获取一个静态或实例 int 字段的值。
public long 			getLong(Object obj)
							// 获取一个静态或实例 long 字段的值。
public short 			getShort(Object obj)
							// 获取一个静态或实例 short 字段的值。
```



- **原始类型set**

```java
public void 			setBoolean(Object obj, boolean z)
							// 将字段的值在指定对象上设置为一个 boolean 值。
public void 			setByte(Object obj, byte b)
							// 将字段的值在指定对象上设置为一个 byte 值。
public void 			setChar(Object obj, char c)
							// 将字段的值在指定对象上设置为一个 char 值。
public void 			setDouble(Object obj, double d)
							// 将字段的值在指定对象上设置为一个 double 值。
public void 			setFloat(Object obj, float f)
							// 将字段的值在指定对象上设置为一个 float 值。
public void 			setInt(Object obj, int i)
							// 将字段的值在指定对象上设置为一个 int 值。
public void 			setLong(Object obj, long l)
							// 将字段的值在指定对象上设置为一个 long 值。
public void 			setShort(Object obj, short s)
							// 将字段的值在指定对象上设置为一个 short 值。
```



- **字段元数据与类型信息**

```java
public Class<?> 		getDeclaringClass()
							// (实现 Member) 返回表示声明此字段的类或接口的 Class 对象。
public String 			getName()
							// (实现 Member) 返回此 Field 对象所表示字段的名称。
public int 				getModifiers()
							// (实现 Member) 以整数形式返回此字段的 Java 语言修饰符。
public Class<?> 		getType()
							// 返回一个 Class 对象，该对象标识此字段的声明类型。
public Type 			getGenericType()
							// 返回一个 Type 对象，该对象表示此字段的声明类型（包含泛型信息）。
public AnnotatedType 	getAnnotatedType()
							// (Java 8+) 返回一个 AnnotatedType 对象，表示此字段的声明类型（包含类型注解）。
```



- **属性标志与比较**

```java
public boolean 			isEnumConstant()
							// 如果此字段是枚举常量，则返回 true。
public boolean 			isSynthetic()
							// (实现 Member) 如果此字段是编译器生成的合成字段，则返回 true。
public boolean 			equals(Object obj)
							// 比较此 Field 与指定对象是否相等。
public int 				hashCode()
							// 返回此 Field 的哈希码
```



- **字符串**

```java
public String 			toString()
							// 返回描述此 Field 的字符串。
public String 			toGenericString()
							// 返回描述此 Field 的字符串，包括其泛型类型。
```



#### `Array`类

- 数组

##### 方法

- **创建数组**

```java
public static Object 	newInstance(Class<?> componentType, int length)
				// 创建一个具有指定组件类型和长度的新的一维数组。
public static Object 	newInstance(Class<?> componentType, int... dimensions)
				// 创建一个具有指定组件类型和维度的新数组（可用于创建多维数组）。
```



- **获取数组信息与元素**

```java
public static int 		getLength(Object array)
				// 以 int 形式返回指定数组对象的长度。
```



- **get**

```java
public static Object 	get(Object array, int index)
				// 返回指定数组对象中指定索引位置的组件值。
public static boolean 	getBoolean(Object array, int index)
				// 以 boolean 形式返回指定数组对象中指定索引位置的组件值。
public static byte 		getByte(Object array, int index)
				// 以 byte 形式返回指定数组对象中指定索引位置的组件值。
public static char 		getChar(Object array, int index)
				// 以 char 形式返回指定数组对象中指定索引位置的组件值。
public static double 	getDouble(Object array, int index)
				// 以 double 形式返回指定数组对象中指定索引位置的组件值。
public static float 	getFloat(Object array, int index)
				// 以 float 形式返回指定数组对象中指定索引位置的组件值。
public static int 		getInt(Object array, int index)
				// 以 int 形式返回指定数组对象中指定索引位置的组件值。
public static long 		getLong(Object array, int index)
				// 以 long 形式返回指定数组对象中指定索引位置的组件值。
public static short 	getShort(Object array, int index)
				// 以 short 形式返回指定数组对象中指定索引位置的组件值。
```



- **set**

```java
public static void 		set(Object array, int index, Object value)
				// 将指定数组对象的指定索引位置的组件值设置为指定的新值。
public static void 		setBoolean(Object array, int index, boolean z)
				// 将指定数组对象的指定索引位置的组件值设置为指定的 boolean 值。
public static void 		setByte(Object array, int index, byte b)
				// 将指定数组对象的指定索引位置的组件值设置为指定的 byte 值。
public static void 		setChar(Object array, int index, char c)
				// 将指定数组对象的指定索引位置的组件值设置为指定的 char 值。
public static void 		setDouble(Object array, int index, double d)
				// 将指定数组对象的指定索引位置的组件值设置为指定的 double 值。
public static void 		setFloat(Object array, int index, float f)
				// 将指定数组对象的指定索引位置的组件值设置为指定的 float 值。
public static void 		setInt(Object array, int index, int i)
				// 将指定数组对象的指定索引位置的组件值设置为指定的 int 值。
public static void 		setLong(Object array, int index, long l)
				// 将指定数组对象的指定索引位置的组件值设置为指定的 long 值。
public static void 		setShort(Object array, int index, short s)
				// 将指定数组对象的指定索引位置的组件值设置为指定的 short 值。
```



#### `Modifier`类

- **修饰符**

##### 常量

- 这些常量代表了 Java 语言中各种修饰符的 int 值（位掩码）

```java
public static final int 	ABSTRACT
									// 代表 abstract 修饰符的 int 值。
public static final int 	FINAL
									// 代表 final 修饰符的 int 值。
public static final int 	INTERFACE
									// 代表 interface 修饰符的 int 值。
public static final int 	NATIVE
									// 代表 native 修饰符的 int 值。
public static final int 	PRIVATE
									// 代表 private 修饰符的 int 值。
public static final int 	PROTECTED
									// 代表 protected 修饰符的 int 值。
public static final int 	PUBLIC
									// 代表 public 修饰符的 int 值。
public static final int 	STATIC
									// 代表 static 修饰符的 int 值。
public static final int 	STRICT
									// 代表 strictfp 修饰符的 int 值。
public static final int 	SYNCHRONIZED
									// 代表 synchronized 修饰符的 int 值。
public static final int 	TRANSIENT
									// 代表 transient 修饰符的 int 值。
public static final int 	VOLATILE
									// 代表 volatile 修饰符的 int 值。
```



##### 方法

- **修饰符检查方法**

```java
public static boolean 		isAbstract(int mod)
									// 如果整数参数 mod 包含 abstract 修饰符，则返回 true。
public static boolean 		isFinal(int mod)
									// 如果整数参数 mod 包含 final 修饰符，则返回 true。
public static boolean 		isInterface(int mod)
									// 如果整数参数 mod 包含 interface 修饰符，则返回 true。
public static boolean 		isNative(int mod)
									// 如果整数参数 mod 包含 native 修饰符，则返回 true。
public static boolean 		isPrivate(int mod)
									// 如果整数参数 mod 包含 private 修饰符，则返回 true。
public static boolean 		isProtected(int mod)
									// 如果整数参数 mod 包含 protected 修饰符，则返回 true。
public static boolean 		isPublic(int mod)
									// 如果整数参数 mod 包含 public 修饰符，则返回 true。
public static boolean 		isStatic(int mod)
									// 如果整数参数 mod 包含 static 修饰符，则返回 true。
public static boolean 		isStrict(int mod)
									// 如果整数参数 mod 包含 strictfp 修饰符，则返回 true。
public static boolean 		isSynchronized(int mod)
									// 如果整数参数 mod 包含 synchronized 修饰符，则返回 true。
public static boolean 		isTransient(int mod)
									// 如果整数参数 mod 包含 transient 修饰符，则返回 true。
public static boolean 		isVolatile(int mod)
									// 如果整数参数 mod 包含 volatile 修饰符，则返回 true。
```



- **程序元素修饰符集合**

```java
public static int	 		classModifiers()
									// 返回一个 int 值，该值是所有可应用于类的修饰符的按位或（OR）组合。
public static int 			constructorModifiers()
									// 返回一个 int 值，该值是所有可应用于构造函数的修饰符的按位或（OR）组合。
public static int 			fieldModifiers()
									// 返回一个 int 值，该值是所有可应用于字段的修饰符的按位或（OR）组合。
public static int 			interfaceModifiers()
									// 返回一个 int 值，该值是所有可应用于接口的修饰符的按位或（OR）组合。
public static int 			methodModifiers()
									// 返回一个 int 值，该值是所有可应用于方法的修饰符的按位或（OR）组合。
public static int 			parameterModifiers()
									// 返回一个 int 值，该值是所有可应用于参数的修饰符的按位或（OR）组合。
```



- **工具方法**

```java
public static String 		toString(int mod)
				// 返回一个字符串，描述在指定修饰符 mod 中设置的访问修饰符标志。
```



#### `Parameter`类

- **参数**

##### 方法

- 参数信息

```java
public Executable 		getDeclaringExecutable()
							// 返回声明此参数的 Executable 对象（即方法或构造函数）。
public String 			getName()
							// 返回参数的名称。注意：需要编译器开启 -parameters 选项，否则会返回 "argN" 形式的名称。
public int 				getModifiers()
							// 以整数形式返回此参数的修饰符（例如 final）。
```



- **参数类型信息**

```java
public Class<?> 		getType()
							// 返回一个 Class 对象，该对象标识此参数的声明类型。
public Type 			getParameterizedType()
							// 返回一个 Type 对象，该对象标识此参数的参数化类型（包含泛型信息）。
public AnnotatedType 	getAnnotatedType()
							// 返回一个 AnnotatedType 对象，表示此参数的类型（包含类型注解）。
```



- **参数属性标志**

```java
public boolean 			isNamePresent()
							// 如果参数在编译后的 .class 文件中确实有名称，则返回 true。
public boolean 			isImplicit()
							// 如果此参数是在源代码中隐式声明的（例如，内部类的构造函数中对其外部类实例的引用）,则返回 true
public boolean 			isSynthetic()
							// 如果此参数是由编译器生成的合成参数，则返回 true。
public boolean 			isVarArgs()
							// 如果此参数是可变参数（varargs），则返回 true。
```



- **注解处理**

```java
public <T extends Annotation> T 	getAnnotation(Class<T> annotationClass)
										// 返回此参数上存在的指定类型的注解。
public Annotation[] 				getAnnotations()
										// 返回此参数上存在的所有注解的数组。
public <T extends Annotation> T[] 	getAnnotationsByType(Class<T> annotationClass)
										// 返回与此参数关联的所有指定类型的注解。
public <T extends Annotation> T 	getDeclaredAnnotation(Class<T> annotationClass)
										// 返回直接声明在此参数上的指定类型的注解。
public Annotation[] 				getDeclaredAnnotations()
										// 返回直接声明在此参数上的所有注解的数组。
public <T extends Annotation> T[] 	getDeclaredAnnotationsByType(Class<T> annotationClass)
										// 返回直接或间接声明在此参数上的所有指定类型的注解。
```



- **对象方法**

```java
public boolean 		equals(Object obj)
						// 比较此 Parameter 与指定对象是否相等（基于其所属的可执行文件和在参数列表中的索引）。
public int 			hashCode()
						// 返回此 Parameter 的哈希码。
public String 		toString()
						// 返回描述此参数的字符串。
```



#### `Proxy`类

- **动态代理机制**的核心

##### 字段

```java
protected 	InvocationHandler 	h
					// 此代理实例的调用处理器，所有对代理实例的方法调用都会被转发到此处理器的 invoke 方法。
```

##### **构造方法**

```java
protected		 Proxy(InvocationHandler h)
					// 从子类（通常是由 JVM 动态生成的代理类）构造一个新的 Proxy 实例，并为其指定调用处理器。
					// 开发者不应直接调用此构造函数。
```

##### 方法

- **静态工厂方法**

```java
public static Object newProxyInstance(ClassLoader loader, Class<?>[] interfaces, InvocationHandler h)
				//返回一个代理类的实例，该代理类实现了指定加载器中定义的所有接口，并将方法调用分派给指定的调用处理器 h
```



- **静态工具与内省方法**

```java
public static InvocationHandler getInvocationHandler(Object proxy)
				// 返回指定代理实例的调用处理器（InvocationHandler）。
public static boolean 			isProxyClass(Class<?> cl)
				// 如果一个类是通过 getProxyClass 或 newProxyInstance 创建的动态代理类，则返回 true。
public static Class<?> 			getProxyClass(ClassLoader loader, Class<?>... interfaces)
				// (已废弃) 返回代理类的 Class 对象，该代理类给定加载器和接口数组。
				// 废弃原因：在 Java 9 模块化系统后，生成的代理类被封装在其模块内，外部代码无法访问，因此该方法不再可靠。
```



#### `InvocationHandler`接口

- **函数式接口**

- **`InvocationHandler`** 是动态代理类的**调用处理器**所实现的接口

##### 方法

```java
public Object 			invoke(Object proxy, Method method, Object[] args)
							// 处理代理实例上的方法调用并返回结果。这是实现所有代理逻辑的核心方法。
							// proxy: 调用该方法的代理实例。Java运行时系统自动传入的、最终创建好的那个代理对象实例
							// method: 被调用的 Method 实例。
							// args: 传递给方法的参数数组；如果方法没有参数，则为 null。
```

```java
public static Object 	invokeDefault(Object proxy, Method method, Object... args)
							// (Java 9+) 使用给定的参数在指定的代理实例上调用一个接口的默认（default）方法。
```



#### `InvocationTargetException`类

- 包装了由反射调用的方法或构造函数所抛出的实际异常

##### 构造方法

```JAVA
public InvocationTargetException(Throwable target)
				// 构造一个 InvocationTargetException，并指定被包装的目标异常。
public InvocationTargetException(Throwable target, String s)
				// 构造一个 InvocationTargetException，并指定目标异常和详细消息。
protected InvocationTargetException()
				// 构造一个 InvocationTargetException，其目标异常为 null。
```

##### 方法

```java
public Throwable 	getTargetException()
				// 获取被此异常包装的、由被调用方法实际抛出的目标异常。
public Throwable 	getCause()
				// (重写 Throwable) 返回此异常的根本原因。在此类中，它的返回值与 getTargetException() 完全相同。
```

#### `AnnotatedType`接口

- 代表了在程序中一个**类型的使用**

##### 方法

- **核心类型信息**

```java
public Type 					getType()
			// 返回此注解类型所代表的、基础的 java.lang.reflect.Type。
public default AnnotatedType 	getAnnotatedOwnerType()
	//如果此类型是嵌套类型(例如,Outer.Inner),则返回代表其所有者类型(Outer)的AnnotatedType.如果它不是嵌套类型,则返回null
```



- **注解处理**

```JAVA
public <T extends Annotation> T 	getAnnotation(Class<T> annotationClass)
			// 返回此元素上存在的指定类型的注解。
public Annotation[] 				getAnnotations()
			// 返回此元素上存在的所有注解的数组。
public Annotation[] 				getDeclaredAnnotations()
			// 返回直接声明在此元素上的所有注解的数组。
public <T extends Annotation> T 	getDeclaredAnnotation(Class<T> annotationClass)
			// 如果直接存在指定类型的注解，则返回该注解。
public <T extends Annotation> T[] 	getAnnotationsByType(Class<T> annotationClass)
			// 返回与此元素关联的所有指定类型的注解。
public <T extends Annotation> T[] 	getDeclaredAnnotationsByType(Class<T> annotationClass)
			// 返回直接或间接声明在此元素上的所有指定类型的注解。
public boolean 						isAnnotationPresent(Class<? extends Annotation> annotationClass)
           // 检查是否存在指定类型的注解。
```



#### `AnnotatedArrayType`接口

- 代表一个数组类型的**类型使用**，这个使用点上可能存在类型注解

##### 方法

- 核心数组类型信息

```java
public AnnotatedType 		getAnnotatedGenericComponentType()
					// 返回此数组类型的潜在注解组件类型。
					// 例如，对于 String @NonNull []，此方法将返回代表 String @NonNull 的 AnnotatedType
```



- 继承自**`AnnotatedType`**的方法

```java
public Type 			getType()
					// 返回此注解类型所代表的、基础的 java.lang.reflect.Type（即数组的 Class 对象）。
public AnnotatedType 	getAnnotatedOwnerType()
					// 如果此数组类型的组件类型是嵌套类型，则返回代表其所有者类型的 AnnotatedType。
```



- 继承自**`AnnotatedElement`**的方法

```java
public <T extends Annotation> T getAnnotation(Class<T> annotationClass)
					//返回此元素上存在的指定类型的注解。
public Annotation[] 			getAnnotations()
					//返回此元素上存在的所有注解的数组。
public Annotation[] 			getDeclaredAnnotations()
					//返回直接声明在此元素上的所有注解的数组。
```



#### `AnnotatedParameterizedType`接口

- 代表一个**参数化类型**（例如 List<String>）的**类型使用**，这个使用点上可能存在类型注解

##### 方法

- 核心参数化类型信息

```java
public AnnotatedType[] 		getAnnotatedActualTypeArguments()
		// 返回一个 AnnotatedType 数组，该数组代表此参数化类型的实际类型参数。
	//例如,对于Map<@Key String, @Value Object>,此方法将返回一个包含两个元素的数组,分别代表@Key String和@Value Object
```



- 继承自 **`AnnotatedType`** 的方法

```JAVA
public Type 				getType()
			//返回此注解类型所代表的、基础的 java.lang.reflect.Type（即 ParameterizedType 实例）。
public AnnotatedType 		getAnnotatedOwnerType()
			//如果此参数化类型的原始类型是嵌套类型，则返回代表其所有者类型的 AnnotatedType。
```



- 继承自 **`AnnotatedElement`** 的方法

```JAVA
public <T extends Annotation> T getAnnotation(Class<T> annotationClass)
				// 返回此元素上存在的指定类型的注解。
public Annotation[] 			getAnnotations()
				// 返回此元素上存在的所有注解的数组。
public Annotation[] 			getDeclaredAnnotations()
				// 返回直接声明在此元素上的所有注解的数组。
```



#### `AnnotatedTypeVariable`接口

- **类型变量**（例如，泛型定义中的 T）的**类型使用**

##### 方法

- 核心类型变量信息

```java
public AnnotatedType[] getAnnotatedBounds()
		// 返回一个 AnnotatedType 数组，该数组代表此类型变量的边界（bounds）。
	//例如.对于T extends @A Number & @B Serializable此方法将返回代表@A Number和@B Serializable的AnnotatedType对象
```



- 继承自 **`AnnotatedType`** 的方法

```java
public Type 			getType()
			// (已补充) 返回此注解类型所代表的、基础的 java.lang.reflect.Type（即 TypeVariable 实例）。
public AnnotatedType 	getAnnotatedOwnerType()
			// 如果此类型变量是在一个内部类中声明的，则返回其所有者类型的 AnnotatedType。
```



- 继承自**`AnnotatedElement`** 的方法

```java
public <T extends Annotation> T getAnnotation(Class<T> annotationClass)
			// (已补充) 返回此元素上存在的指定类型的注解。
public Annotation[] 			getAnnotations()
			// (已补充) 返回此元素上存在的所有注解的数组。
public Annotation[] 			getDeclaredAnnotations()
			// (已补充) 返回直接声明在此元素上的所有注解的数组。
```



#### `AnnotatedWildcardType`接口

- 代表一个**通配符类型参数**（例如 ? extends Number 或 ? super String）的**类型使用**，这个使用点上可能存在类型注解

##### 方法

- 核心通配符类型信息 (此接口独有)

```java
public AnnotatedType[] 		getAnnotatedLowerBounds()
				// 返回一个 AnnotatedType 数组，该数组代表此通配符的下限（lower bounds）
		// 例如，对于 ? super @A String，此方法将返回代表 @A String 的 AnnotatedType。如果没有显式下限，则返回空数组
public AnnotatedType[] 		getAnnotatedUpperBounds()
				// 返回一个 AnnotatedType 数组，该数组代表此通配符的上限（upper bounds）
		//例如，对于? extends @B Number，此方法将返回代表@B Number 的 AnnotatedType。如果没有显式上限，则隐式为 Object
```



- 继承自 **`AnnotatedType`** 的方法

```java
public Type 			getType()
				// (已补充) 返回此注解类型所代表的、基础的 java.lang.reflect.Type（即 WildcardType 实例）。
public AnnotatedType 	getAnnotatedOwnerType()
				// 如果此通配符类型是在一个内部类中声明的，则返回其所有者类型的 AnnotatedType。
```



- 继承自 **`AnnotatedElement`** 的方法

```java
public <T extends Annotation> T 	getAnnotation(Class<T> annotationClass)
				// 返回此元素上存在的指定类型的注解。
public Annotation[] 				getAnnotations()
				// 返回此元素上存在的所有注解的数组。
public Annotation[] 				getDeclaredAnnotations()
				// 返回直接声明在此元素上的所有注解的数组。
```



#### `TypeVariable`接口

- 各种 Type 子接口的公共超接口，它代表一个**类型变量**。例如，在泛型类 class List<T> { ... } 中，T 就是一个类型变量

##### 方法

- 核心类型变量信息

```java
public String 			getName()
			// 返回此类型变量在源代码中的名称（例如 "T"）。
public D 				getGenericDeclaration()
			// 返回声明了此类型变量的通用声明实体（即 Class、Method 或 Constructor 对象）。
public Type[] 			getBounds()
			// 返回一个 Type 对象数组，该数组表示此类型变量的上限（upper bounds）。
			// 例如，对于T extends Number & Serializable，此方法将返回代表Number和Serializable的Type对象
public AnnotatedType[] 	getAnnotatedBounds()
			// (Java 8+) 返回一个 AnnotatedType 数组，该数组表示此类型变量的上限（包含类型注解）。
```



- 继承自 **`AnnotatedElement`** 的方法

```java
public <T extends Annotation> T 	getAnnotation(Class<T> annotationClass)
				// 如果此类型变量的使用点上存在指定类型的注解，则返回该注解。
public Annotation[] 				getAnnotations()
				// 返回此类型变量的使用点上存在的所有注解。
public Annotation[] 				getDeclaredAnnotations()
				// 返回直接声明在此类型变量的使用点上的所有注解。
```



#### `Type`接口

- **`Type`** 是 Java 编程语言中所有类型的公共超接口。这些类型包括原始类型、参数化类型、数组类型、类型变量和基本类型。它是一个**标记接口**，其主要目的是将所有这些不同的类型种类统一起来。

##### 方法

```java
public default String getTypeName()
			// (Java 8+) 返回描述此类型的字符串，可能包含有关任何类型参数的详细信息。
			// 例如，对于 List<String>，它会返回 "java.util.List<java.lang.String>"。
```



#### `ParameterizedType`接口

- 代表一个**参数化类型**，例如 Collection<String>。这是 Java 泛型在反射中的核心表示

##### 方法

- 核心参数化类型信息

```java
public Type[] 	getActualTypeArguments()
		// 返回一个 Type 对象数组，该数组代表此类型的实际类型参数。
		// 例如，对于 Map<String, Integer>，此方法将返回一个包含 String.class 和 Integer.class 的数组。
public Type 	getOwnerType()
		// 返回一个 Type 对象，该对象表示此类型所属的类型。
		// 例如，对于嵌套类型 Outer.Inner<T>，此方法将返回代表 Outer 的 Type。如果它不是嵌套类型，则返回 null。
public Type 	getRawType()
		// 返回一个 Type 对象，该对象表示声明此参数化类型的原始类或接口。
		// 例如，对于 Map<String, Integer>，此方法将返回 Map.class。
```



- 继承自 **`Type`** 的方法

```JAVA
public default String 	getTypeName()
			// 返回描述此类型的字符串，包括类型参数。
			// 例如，对于 java.util.List<String>，它会返回 "java.util.List<java.lang.String>"。
```



#### `GenericArrayType`接口

- 代表一个数组类型，其组件类型要么是**类型变量**，要么是**参数化类型**。例如，List<String>[] 或 T[] (其中 T 是一个类型变量)。

##### 方法

- 核心数组类型信息

```java
public Type 		getGenericComponentType()
		// 返回一个 Type 对象，该对象表示此数组的组件类型。
		// 例如，对于 T[]，此方法将返回代表 T 的 TypeVariable。
		// 对于 List<String>[]，此方法将返回代表 List<String> 的 ParameterizedType。
```

- 继承自 Type 的方法

```java
public default String 	getTypeName()
			// 返回描述此类型的字符串。
			// 例如，对于 java.util.List<java.lang.String>[]，它会返回 "java.util.List<java.lang.String>[]"。
```



#### `WildcardType`接口

- 代表一个**通配符类型**表达式，例如 ?、? extends Number 或 ? super String

##### 方法

- 核心通配符类型信息

```java
public Type[] 	getLowerBounds()
		// 返回一个 Type 对象数组，该数组表示此通配符类型的下限（lower bounds）。
			// 例如，对于 ? super String，此方法将返回一个包含 String.class 的数组。
    		//对于没有显式下限的通配符（如 ? extends Number）,则返回一个空数组
public Type[] 	getUpperBounds()
		// 返回一个 Type 对象数组，该数组表示此通配符类型的上限（upper bounds）。
			// 例如，对于 ? extends Number，此方法将返回一个包含 Number.class 的数组。
    		//对于没有显式上限的通配符（如 ?），则隐式地以 Object 为上限。
```



- 继承自 **`Type`** 的方法

```JAVA
public default String getTypeName()
		// (已补充) 返回描述此类型的字符串。
		// 例如，对于 ? extends java.lang.Number，它会返回 "? extends java.lang.Number"。
```

