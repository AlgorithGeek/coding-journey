# XML

## 相关概念

- **XML 全称为 eXtensible Markup Language **：中文叫**“可扩展标记语言”**

  - **Markup Language (标记语言)**：意味着它使用**标签**（如 **`<作者>`**）来“标记”数据的含义和结构。
    - HTML 也是一种**标记语言**，但它的标签是预定义好的（如 **`<h1>`**, **`<p>`**），主要用于**“展示”**网页。
    - 而 XML 的标签是你可以**自己定义**的，主要用于**“描述数据”**
  - **eXtensible (可扩展)**：意味着你可以根据你的需要，自由创建**任何你想要的标签**
    - 例如 **`<书名>`**、**`<作者>`** 都是我们自己发明的，这就是**“可扩展”**的含义。

  - **XML** 的设计初衷**不是为了在浏览器里好看**，而是为了**传输和存储数据**。
    - 它的核心价值在于：**它用一种纯文本的方式，既承载了数据本身，也承载了数据的结构和含义**
      - 这带来的几个好处：
        - **平台无关性**：**XML 文件是纯文本**，**任何操作系统（Windows, Linux, macOS）、任何编程语言（Java, Python, C#）都可以轻松地读取和处理它**
        - **自描述性**：即使没有文档说明，**通过阅读 XML 的标签，我们也能大致猜出数据的含义**。这使得不同系统间的**数据交换**变得非常方便。

- **标签**

  - **标签**是 XML 中用来**标记**和**定义**元素边界的**语法结构**

  - 在 XML 中，标签主要有三种形式

    - **开始标签**：**标志着一个元素的开始**
      - **格式**：**`<标签名>`**
      - **示例**：**`<title>`**

    - **结束标签**：**标志着一个元素的结束**
      - **格式**：**`</标签名>`** (比开始标签多了一个斜杠 **`/`**)
      - **示例**：**`</title>`**

    - **自闭合标签**：用于**表示一个没有内容的“空元素”**
      - **格式**：**`<标签名/>`**
      - **示例**：**`<br/>`**

  - 标签的作用

    - **定义边界**：标签最基本的作用就是划定范围。它告诉计算机，从哪里开始 (**`<title>`**) 到哪里结束 (**`</title>`**)  是一块完整的数据。
    - **赋予含义**：这是标签**名字**的功劳。它不仅仅是划定边界，更重要的是它给被包裹的数据赋予了语义。
    - **构建层级关系**：通过将一套标签嵌套在另一套标签内部，我们就可以创建出**父子关系**，从而构建出整个 XML 文档的树状结构





## XML的组成部分

- 基于XML 1.0/1.1

### 文档声明

#### 相关概念

- **XML 文档声明**是位于 XML 文档**最顶端、最前面**的一行特殊指令。它**不是 XML 数据内容的一部分，它不是标签**。可以把它看作是文档的**“身份标识”**，它必须出现在文件的**第一行第一列**，**前面不能有任何空格、换行或注释**
- **XML 文档声明** 可以不写，但**强烈不推荐**，因为**真的会“有事”**
  - 会有很多问题，比如**编码、版本......**



#### 语法格式

- **文档声明**的**语法格式**如下

  ```xml
  <?xml 属性1="值1" 属性2="值2" ... ?>
  ```

#### 相关属性

- **XML 文档声明** 中，有且仅有这三个属性：**`version`** (必需)、**`encoding`** (可选，但强烈推荐)、**`standalone`** (可选)
  - 这**由 W3C (万维网联盟) 的 XML 规范所定义**，**不能添加任何自定义的属性**



##### `version` 版本号

- 这是文档声明中**唯一一个必须存在**的属性，**只要是写了XML文档声明，就必须写这个属性**
- **作用**：它用于**指定当前这份 XML 文档遵循的是哪个版本的 XML 规范**
- **可选值**：除非有极其特殊的需求，否则**请始终使用 `version="1.0"`**
  - **`"1.0"`**：这是**绝大多数情况下你会用到的值**。**XML 1.0** 标准自 1998 年发布以来一直是最稳定、最广泛支持的版本。
  - **`"1.1"`**：**XML 1.1 是在 2004 年发布的修订版**，主要**放宽了对名称中可使用字符的限制**，并**对换行符的处理做了一些更改**。但由于它并未被广泛采用，且与 1.0 有一些不兼容之处，因此在实践中非常罕见。



##### `encoding` 编码

- **作用**：它用于声明**保存这份 XML 文件时**所使用的**字符编码**。这等于给了计算机一份“解码指南”，告诉它应该如何将文件中的二进制字节流翻译成我们能读懂的字符
- 如果缺少这个声明，解析器会**猜测编码**（通常默认是 UTF-8），一旦猜测错误（比如文件实际是 GBK 编码），就会产生**乱码**
- 常用可选值：
  - **`"UTF-8"`**：**全球标准，首选推荐**。它可以表示世界上几乎所有的字符，且兼容 ASCII 编码，具有极好的通用性
  - **`"UTF-16"`**：另一种 Unicode 编码，每个字符通常占用 2 或 4 个字节
  - **`"GBK"`**, **`"BIG5"`**：分别是针对简体中文和繁体中文的地区性编码，现已不推荐在新项目中使用
  - **`"ISO-8859-1"`**：一种针对西欧语言的编码



##### `standalone` 独立性声明

- 它用于声明该 XML 文档**是否“自给自足”**，即它的结构和内容的正确性验证是否需要依赖一个**外部的 DTD 文件**
- 可选值：
  - **`"yes"`**：表示该文档是一个**独立文档**。解析器在处理此文件时，不需要去读取任何外部的 DTD 文件。这意味着文档的验证（如果需要的话）完全基于其内部的定义。他也是一个给解析器的**优化信号和保证**，这在不使用 DTD 的现代应用中是最佳实践
  - **`"no"`(默认行为)**：表示该文档**不是一个独立文档**。这意味着解析器**可能需要**读取外部的 DTD 文件来正确地解析和验证文档。例如，外部 DTD 可能定义了一些实体或默认的属性值，如果解析器不加载它，就会导致信息丢失或解析错误



### 元素

#### 相关概念

- 一个元素是 XML 文档中一个**独立的、有标签的数据单元**。它**定义了文档结构的一个层级，并包裹着相应的数据**
  - 最简单的理解：**一个从开始标签到结束标签的完整部分，就是一个元素**



- **一些注意点**

  - **允许有同名元素，同名的两个元素表示不同的两个元素**

    - 示例

      ```xml
      <car color="red"/>
      
      <car>
        <color>red</color>
      </car>
      ```

      

  - **元素名大小写敏感**：XML大小写是敏感的，大小写不同是不同的元素，比如**`<Book>`** 和 **`<book>`** 是两个**完全不同的元素**。这一点与 HTML 不同，需要特别注意

  - **元素必须正确嵌套**：要进行元素嵌套，要把子元素完全放置在另一个元素的**开始标签**和**结束标签**之间，而不应该交叉

    - 正确案例

      ```xml
      <p>
          <b>这是粗体</b>
      </p>
      ```

    - 错误案例

      ```xml
      <p>
          <b>这是粗体</p>
      </b>
      ```

      

#### 构成

- 一个标准的元素由三个部分组成：

  1. **开始标签**：例如 **`<author>`**。它**标记着一个元素的开始**
  2. **内容**：**位于开始标签和结束标签之间的一切**。它是**元素所承载的数据**
  3. **结束标签**：例如 **`</author>`**。它**标记着一个元素的结束**，注意**它比开始标签多一个斜杠 `/`**

  - 语法结构

    ```xml
    <标签名>内容</标签名>		<!-- <开始标签>内容<结束标签>  -->
    ```

  - 示例

    ```xml
    <author>J.K. Rowling</author>
    ```



#### 元素的命名规则

- 给元素起名字不是随意的，必须遵守以下规则：

  - **合法字符**：名称可以包含**字母、数字、下划线 `_`、连字符 `-` 和点 `.`**

  - **开头限制**：名称**必须**以**字母**或**下划线 (`_`)** 开头

  - **前缀限制**：名称**不能**以 **`xml`** (**或任何大小写变体如 `XML`, `Xml` 等**) 开头

  - **无空格**：名称中**不能**包含**空格**



#### 元素的类型

##### 根据内容模型划分

- XML里的**内容模型分类**是对XML文件的元素进行的一种**描述性分类**。它回答的问题是：“这个元素**实际上**长什么样？”

###### 空元素

- **没有任何内容**。它通常用于表示一个**事实**或**插入一个独立的对象**

  - **注意**：空元素是没有**内容**，不是没有**属性**，不要搞混

- 空元素的两种写法

  - **带结束标签**

    ```xml
    <标签名></标签名>		
    <!-- 
      <开始标签><结束标签>实际上是这个意思，结束标签比开始标签多了个 /
    -->
    ```

  - **自闭合标签 (Self-Closing Tag)**

    ```xml
    <标签名/>	
    <!--把 / 加到了标签末尾-->
    ```



###### 含有纯文本内容的元素

- 最常见的类型，其内容是纯粹的字符串文本

- 语法

  ```xml
  <元素名>文本内容</元素名>
  ```

  

- 示例

  ```xml
  <year>2025</year>
  <price>99.99</price>
  ```



###### 含有子元素的元素

- 这类元素不直接包含文本，而是作为**“容器”**，包裹着**一个或多个子元素**，从而构建出**数据的层级结构（树状结构）**

- 语法格式

  ```xml
  <父元素名>
      <子元素1/>
      <子元素2>...</子元素2>
      <子元素3>...</子元素3>
      ...
  </父元素名>
  ```

- 示例

  ```xml
  <book>
    <title>深入理解XML</title>
    <author>张三</author>
  </book>
  ```



###### 含有混合内容的元素

- 这种元素的内容中既有文本，也穿插着子元素

- 示例

  ```xml
  <paragraph>
    XML是一种<emphasis>非常强大</emphasis>的数据格式。
  </paragraph>
  ```



#### 特殊元素----根元素

- **根元素**是 XML 文档中处于**最顶层、唯一一个**的元素。它像一个巨大的容器，包裹了文档中所有其他的数据元素、注释和处理指令

##### 根元素的规则

- 一个**格式正确的 XML 文档**，**必须有且仅有一个根元素**
  - **没有根元素是错误的**
  - **有多个根元素也是错误的**
- 根元素必须出现在**可选的 XML 声明 `<?xml ... ?>` 之后**，并**包裹所有其他元素**。它是**文档实际内容的开始和结束**



##### 正确的一个示例

```xml
<project xmlns="http://maven.apache.org/POM/4.0.0" 
         xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
         xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd">
    
    <modelVersion>4.0.0</modelVersion>
    <groupId>com.example</groupId>
    <artifactId>my-app</artifactId>
    <version>1.0-SNAPSHOT</version>

    <dependencies>
        <dependency>
            ...
        </dependency>
    </dependencies>
    
</project> 
```



#### 元素的父子关系

- 在 XML 中，元素的父子关系完全由**嵌套**来定义
  - 当一个元素 **B** 被直接完整地包含在另一个元素 **A** 的内部时，我们就说：
    - **A 是 B 的父元素 (Parent Element)**
    - **B 是 A 的子元素 (Child Element)**

- **XML元素的父子关系**为程序(如 Java DOM、XPath)提供了一套完整的**导航和定位机制**，使得对复杂数据的精确操作成为可能





### 属性

#### 相关概念

- **属性**是为 XML 元素提供**额外信息**或**元数据 (Metadata)** 的一种方式。

  - 它是一个**名值对 (name-value pair)**，并且必须位于元素的**开始标签**内部

  > 如果把元素想象成一个“**盒子**”，那么：
  >
  > - **子元素**是放在**盒子里面**的东西。
  > - **属性**就是贴在**盒子外面**的“**便利贴 (Sticky Note)**”或“**标签**”,上面写着关于这个盒子的信息(比如“颜色：红色”、“ID: A-123”)



#### 语法格式

- **属性名="属性值"**
  - **位置**：必须在元素的开始标签里，位于元素名之后
  - **分隔**：如果一个元素有多个属性，它们之间用**空格**隔开。顺序不重要
  - **引号**：**属性值** **必须**被**双引号 `"`** 或**单引号 `'`** 包裹





### 注释

#### 相关概念

- **XML 注释**是一段被插入到文档中，但会被 XML 解析器**完全忽略**的文本。
  - 它**不会**出现在最终解析出的数据结构中，也不会影响文档的任何内容
  - 唯一作用是**给人看**



#### 语法格式

- **使用`<!--` 和` -->`包裹注释内容，即`<!-- 注释 -->`**

  - 示例

    ```java
    <!-- This is a comment -->
    ```



#### 注意点

- **内容中不能包含 `--` (双连字符)**
- **XML 注释不能嵌套**
- 出现的位置
  - **不能出现在XML 声明之前**：如果文档包含 **`<?xml ... ?>` 声明**
    - **声明**必须出现在文件的**第一行第一列**，**前面不能有任何空格、换行或注释**
  - **标签内部**：**不能将注释写在某个标签的 `<` 和 `>` 之间**



## XML模式语言

### 相关概念

- **模式语言**是一种**元语言**，它的主要工作就是用来**定义其他文本文档的结构、约束和合法性规则**

- **XML模式语言**是一种**形式化语言**，主要作用是去**“验证”和“约束”** **XML容器**里的数据，确保它们**正确、完整且一致**

  - 一个XML文件作为**结构化的数据容器**，其最基本的**物理格式和结构由W3C的XML 1.0/1.1规范定义**。**该规范只负责规定如何组织和包裹数据（例如标签必须闭合、正确嵌套），而完全不关心被包裹的数据是什么内容、有什么意义。**
  - XML是一个**数据容器**，它只负责**承载结构化的数据**。而像XSD这样的**XML模式语言**，是**用来定义一套逻辑规则和蓝图**的。这套规则的主要作用是去**“验证”和“约束”** **XML容器**里的数据，确保它们**正确、完整且一致**
  - **不同的XML模式语言(如DTD或XSD)，其本质是为XML解析器提供了一套规则，用于“验证”和“深入理解”一个用XML 1.0/1.1规范写出来的** **`.xml`** **文件**
    - 不同的**XML模式语言**之间存在巨大差异，主要体现在**语法形式**、**设计哲学**、**功能与表达能力**以及**业界地位**等方面
  - **主流的XML模式语言**包括：**DTD**（古典派）、**XSD**（现代标准）、**RELAX NG**（简洁派）和 **Schematron**（规则派）

- **XML模式语言的本质是一个独立的规则定义系统，其核心任务是为XML文档提供验证和约束。因此，一个模式语言自身的语法无需与XML语法保持一致。**

  **只要它能够被相应的XML解析器所理解，并成功地将其内部定义的规则（无论这些规则是用何种语法书写的）应用于目标XML文档，它就完成了其核心使命。其语法的具体形式，是该模式语言的“内部实现细节”**



### DTD

- **DTD** 是一种为XML文档定义**合法结构和构建块**的**模式语言**。它是XML最早期的、源自其“父语言”SGML的**验证机制**
- **DTD文档后缀是`.dtd`**

#### 组成部分

##### 元素声明或定义

- 定义一个合法的元素（标签）叫什么名字，以及它里面**能包含什么内容**

- 定义元素的语法

  ```dtd
  <!ELEMENT 元素名 (内容模型)>
  ```

  - 这里的内容模型分类是定义了DTD中**约束未来元素**的不同的**事前规则和指令**，它是用来**约束XML文件**的。这个内容模型定义的是**“元素必须长什么样”**

    - **空内容模型**

      - **DTD语法：** EMPTY

      - **核心含义：** 规定了该元素内部**必须是空的**，不能包含任何文本或子元素。

      - **用途：** 用于表示一个本身就代表了完整信息的“标记”，类似于HTML中的**`<br>`**或**`<img>`**。信息通常通过其属性来承载。

      - 示例

        ```dtd
        <!ELEMENT image EMPTY>					<!-- 这里的 EMPTY -->
        <!ATTLIST image src CDATA #REQUIRED>
        ```

        ```xml-dtd
        <!-- 合法的XML -->
        <image src="photo.jpg"/>
        ```

      

    - **元素内容模型**

      - **DTD语法：** (子元素1,子元素2, ...)

      - **核心含义：** 规定该元素**只能包含指定的子元素**，不能直接包含文本（子元素内部可以有文本，但父元素这一层不行）

      - **用途：** 定义数据记录、配置项等层级分明、结构固定的XML。

      - **这个模型内部又包含两种重要的“连接符”：**

        - **a) 顺序连接符**

          - **含义：** 子元素必须严格按照逗号分隔的**顺序**出现。
          - **示例：** **`<!ELEMENT book (title, author, year)>`** (顺序必须是 title -> author -> year)

        - **b) 选择连接符**

          - **含义：** 必须从竖线分隔的选项中，**选择其中一个**出现。
          - **示例：** **`<!ELEMENT contact (email | phone)>`** (联系方式要么是email，要么是phone，不能都要)

        - **c) 次数指示符**

          - **含义：** 作为后缀，附加在**子元素名**或**括号组**之后，用来规定该部分出现的次数。
          - **指示符列表：**
            - **无符号 (默认):** 必须且只能出现**一次**
            - **? (问号):** **零次或一次** (可选)
            - *** (星号):** **零次或多次**
            - **+ (加号):** **一次或多次** (至少一次)

        - **示例：**

          - **修饰单个元素**

            ```dtd
            <!ELEMENT book (title, author?, chapter+)>
            ```

          - **修饰括号组**

            ```dtd
            <!ELEMENT section ((title, paragraph)+ | summary)>
            ```

          - 复杂场景

            ```dtd
            <!-- 一个复杂的元素内容模型 -->
            <!ELEMENT chapter (title, (paragraph | image)+, note?)>
            ```

            

    - **纯文本内容模型**

      - **DTD语法：** (#PCDATA)

      - **核心含义：** 该元素**只能包含文本**，不能再嵌套任何子元素

      - **用途：** 这是最基础的数据单元，用于存放最终的数据值，如姓名、价格、标题等

      - 示例

        ```java
        <!ELEMENT name (#PCDATA)>
        <!ELEMENT price (#PCDATA)>
        ```

        

      - **混合内容模型**

        - **DTD语法：** (#PCDATA | 子元素1 | 子元素2 | ...)*

        - **核心含义：** 该元素内部可以包含**文本**，也可以**混杂着指定的子元素**，顺序和数量不限。

        - **重要规则：**

          1. 必须**以`#PCDATA`开头**
          2. 必须使用**`|`**作为连接符
          3. 整个组的最后**必须**跟上 **`*`** (零次或多次)

        - **用途：** 主要用于“文档型”XML，比如文章、书籍等，其中的段落里会穿插一些强调、链接等行内标签

        - 示例

          ```dtd
          <!ELEMENT p (#PCDATA | b | i)*>
          ```

          ```xml
          <!-- 合法的XML -->
          <p>这是一个<b>非常重要</b>的<i>提示</i>。</p>
          ```

          

      

      - .**任意内容模型**

        - **DTD语法：** ANY

        - **核心含义：** 该元素可以包含**任何**在DTD中已定义的元素，也可以包含文本，没有顺序和数量的限制。

        - **用途：** 用于定义一些结构非常灵活、无法提前预知的容器，或者在DTD设计初期作为临时占位符。

        - **缺点：** 它极大地削弱了DTD的验证能力，使得约束变得非常松散。应谨慎使用。

        - 示例

          ```dtd
          <!ELEMENT note ANY>
          ```

          



##### 属性声明

- **属性声明** 的核心作用是，为一个已经通过<!ELEMENT>定义的元素，**声明（或“附加”）一个或多个合法的属性**

- 语法结构

  ```dtd
  <!ATTLIST 元素名
      属性名1 属性类型1 默认值声明1
      属性名2 属性类型2 默认值声明2
      ...
  >
  ```

  - **<!ATTLIST 元素名** : 指明这些属性是附加给哪个元素的。

  - 每一行定义一个属性，包含三个部分：**属性名、属性类型、默认值声明**。

  - **属性类型分类**

    - **CDATA (最常用)**

      - **含义：** Character Data，表示属性值是**一串普通的字符串文本**。

      - **特点：** 这是最灵活、最常用的类型。解析器不会对CDATA类型的值做过多检查，只把它当作普通文本。

      - **示例：**

        ```dtd
        <!ATTLIST person name CDATA #REQUIRED>
        ```

        ```xml-dtd
        <person name="张三"/>
        ```

        

    - **枚举类型**

      - **含义：** 属性值**必须是**括号中用 | 分隔的预定义列表中的一个。

      - **特点：** 非常适合用于状态、类别等取值范围有限的属性。

      - **示例：** 

        ```dtd
        <!ATTLIST order status (processing|shipped|delivered) #REQUIRED>
        ```

        ```xml
        <order status="shipped"/>
        ```

        

    - **ID**

      - **含义：** 属性值在整个XML文档中，必须是**独一无二的标识符**。

      - **特点：**

        - 它的值必须符合XML的命名规则（不能以数字开头等）。
        - 一个元素最多只能有一个ID类型的属性。
        - 主要用于建立内部链接和唯一索引。

      - **示例：**

        ```dtd
        <!ATTLIST book book-id ID #REQUIRED>
        ```

        ```xml
        <book book-id="b123">...</book>
        ```

        

    - **IDREF 和 IDREFS**

      - **含义：**

        - IDREF: 属性值必须是文档中**某个已经存在的ID类型属性的值**。它用来“引用”或“指向”另一个元素。
        - IDREFS: 属性值是**一个或多个**用空格分隔的IDREF。

      - **特点：** 用于在元素之间建立关联关系，类似数据库中的外键。

      - 示例

        ```dtd
        <!ATTLIST author author-id ID #REQUIRED>
        <!ATTLIST book author-ref IDREF #REQUIRED>
        ```

        ```xml
        <author author-id="a001">...</author>
        <book author-ref="a001">...</book> <!-- author-ref指向了author-id -->
        ```

  - **默认值声明**

    - 用来规定属性是否必需，以及它的默认行为

      - **#REQUIRED**

        - **含义：** **必需的。** 这个属性必须在元素的标签中明确地写出来。

        - **示例：**

          ```dtd
          <!ATTLIST image src CDATA #REQUIRED>
          ```

          

      - **#IMPLIED**

        - **含义：** **可选的 (Implied)。** 这个属性可以写，也可以不写。如果不写，解析器也不会给它添加任何值。

        - **示例**

          ```dtd
          <!ATTLIST person title CDATA #IMPLIED>
          ```

          

      - **"默认值"**

        - **含义：** 为属性提供一个**默认值**。如果在元素的标签中**没有**写这个属性，XML解析器会自动把它加上，并赋予这个默认值。

        - **示例：**

          ```dtd
           <!ATTLIST link target CDATA "_blank">
          ```

          - *如果你写：* 

            ```xml
            <link href="..."/>
            ```

          - *解析器看到的等同于：* 

            ```xml
            <link href="..." target="_blank"/>
            ```

            

      - #### **#FIXED "固定值"**

        - **含义：** 为属性提供一个**固定的值**。这个属性是可选的，但如果出现，它的值**必须**是这个指定的固定值。如果省略，行为同默认值，解析器会自动加上。

        - **示例：** 

          ```dtd
          <!ATTLIST script language CDATA #FIXED "javascript">
          ```

          ```xml
          <script language="javascript" ... />
          ```



##### 实体声明

- 见“处理特殊字符”



#### 在XML中使用DTD

- 将DTD（文档类型定义）应用到一个XML文件中，主要有两种方式。这两种方式决定了DTD规则是**直接写在XML文件内部**，还是**放在一个独立的外部文件中**。
- 声明关键字是**`<!DOCTYPE>`**,无论哪种方式,**把DTD引入XML** **都需要**在XML文件的**`<?xml ... ?>`声明之后**，**根元素之前**添加它



##### 方式一：内部DTD

- 把**所有的DTD规则（<!ELEMENT>, <!ATTLIST>, <!ENTITY>）**都**直接写在XML文件自身的<!DOCTYPE>声明的方括号[]内部**

- 优缺点

  - **优点：**
    - **自包含，便于传输：** 只需要一个XML文件，就包含了数据和验证规则，非常便于分发和演示。
    - **简单直观：** 对于小型的、一次性的验证规则，写在一起很方便。
  - **缺点：**
    - **无法重用：** DTD规则只对当前这一个XML文件有效。如果你有多个XML文件需要遵守相同的规则，你就得在每个文件里都复制粘贴一遍，这非常糟糕。
    - **可维护性差：** 数据和规则混在一起，当规则复杂时，文件会变得很混乱。

- 如何编写内部DTD

  - 语法结构

    ```xml
    <?xml version="1.0" encoding="UTF-8"?>
    
    <!DOCTYPE 根元素名 [
      <!-- 这里是所有的DTD声明 -->
      <!ELEMENT ... >
      <!ATTLIST ... >
      <!ENTITY ... >
    ]>
    
    <根元素>
      ... (XML数据) ...
    </根元素>
    ```

  - 示例

    ```xml
    <?xml version="1.0" encoding="UTF-8"?>
    
    <!-- <!DOCTYPE> 声明开始，指定根元素是 "note" -->
    <!DOCTYPE note [
      <!-- 元素声明 -->
      <!ELEMENT note (to, from, heading, body)>
      <!ELEMENT to (#PCDATA)>
      <!ELEMENT from (#PCDATA)>
      <!ELEMENT heading (#PCDATA)>
      <!ELEMENT body (#PCDATA)>
    
      <!-- 属性声明 -->
      <!ATTLIST note 
          priority (high|low) "low">
    
      <!-- 实体声明 -->
      <!ENTITY signature "The Team">
    ]>
    
    <!-- DOCTYPE 声明结束 -->
    
    
    <!-- XML 数据部分开始 -->
    <note priority="high">
        <to>Alice</to>
        <from>Bob</from>
        <heading>提醒</heading>
        <body>不要忘记今天的会议！</body>
        <!-- 这里没有实体引用，但DTD里定义了 -->
    </note>
    ```

    

##### 方式二：外部DTD

- 这种方式将所有的DTD规则保存在一个独立的、后缀为 .dtd 的文件中。然后在XML文件中，通过<!DOCTYPE>声明来引用这个外部文件

- 优缺点

  - **优点：**
    - **高度可重用：** 同一个.dtd文件可以被成百上千个XML文件共享和引用，保证了数据的一致性。
    - **关注点分离：** 数据（.xml）和规则（.dtd）分离，结构清晰，易于维护。修改规则时，只需要改动.dtd文件即可。
    - **模块化：** 可以创建更复杂的、模块化的文档系统。
  - **缺点：**
    - 需要管理多个文件

- **如何编写和引用外部DTD**

  - **第一步：创建** **.dtd** **文件**

    - 示例

      ```dtd
      <!-- 这个文件里只包含DTD规则，没有XML声明或DOCTYPE -->
      
      <!ELEMENT note (to, from, heading, body)>
      <!ELEMENT to (#PCDATA)>
      <!ELEMENT from (#PCDATA)>
      <!ELEMENT heading (#PCDATA)>
      <!ELEMENT body (#PCDATA)>
      
      <!ATTLIST note 
          priority (high|low) "low">
      
      <!ENTITY signature "The Team">
      ```

  - **第二步：在XML文件中引用** **.dtd** **文件**

    - 引用外部DTD有两种关键字：**`SYSTEM`** 和 **`PUBLIC`**

    - **SYSTEM (最常用)**

      - **含义：** 指示解析器从一个**私有的、具体的URI**（通常是本地文件路径或URL）来加载DTD文件。

      - **语法：** 

        ```XML
        <!DOCTYPE 根元素名 SYSTEM "DTD文件的路径">
        ```

        

    - **PUBLIC**

      - **含义：** 指示解析器使用一个**公共的、广为人知的标识符**来查找DTD。解析器会尝试在本地目录或预设的“目录”中解析这个公共ID，如果找不到，再使用后面提供的SYSTEM路径作为备用。

      - **用途：** 主要用于引用像HTML、SVG这样被广泛使用的公共标准。

      - **语法：** 

        ```XML
        <!DOCTYPE 根元素名 PUBLIC "公共标识符" "DTD文件的备用路径">
        ```

        

### XSD

- **XSD (XML Schema Definition)**，通常被称为**XML Schema**，是W3C官方推荐的、用于**定义和验证XML文档结构、内容和数据类型**的模式语言



#### 组成部分

##### 根元素`<xs:schema>`

- **`<xs:schema>`**是任何XSD文档的**根元素**。所有的模式定义都必须包含在此元素之内。它声明了文档是一个XML Schema，并定义了相关的命名空间

- **`<xs:schema>`** 的关键属性

  1. ```XML
     xmlns:xs="http://www.w3.org/2001/XMLSchema" (必需)
     ```

     - **类型：** 命名空间声明。
     - **含义：** 这是一个**绝对必需**的声明。它告诉XML解析器：“本文档中所有带xs:前缀的标签（比如<xs:element>），都属于W3C定义的‘XML Schema’这套官方词汇，请用它的规则来理解我。”
     - **注意：** 前缀不一定非得是xs，你也可以用xsd或其他，但xs是事实上的行业标准和约定

  2. **targetNamespace**

     - **类型：** 普通属性。

     - **含义：** **目标命名空间。** 这个属性极其重要，它声明了：**“我这个XSD文件，是用来定义和描述哪一个命名空间里的元素的？”**

     - 示例

       ```xml
       <xs:schema xmlns:xs="http://www.w3.org/2001/XMLSchema"
                  targetNamespace="http://www.example.com/library">
           <!-- 这里定义的所有全局元素，比如<book>，都属于"http://www.example.com/library"这个命名空间 -->
       </xs:schema>
       ```

       - 当一个XML文档想要使用这个XSD时，它的元素就必须属于这个目标命名空间，例如

       ```xml
       <lib:book xmlns:lib="http://www.example.com/library">...</lib:book>
       ```

  3. **elementFormDefault="qualified|unqualified"**

     - **类型：** 普通属性。
     - **含义：** **元素形式默认值。** 这个属性用来规定，在目标XML文档中，那些**局部定义**的元素（即嵌套在其他元素内部的元素）是否需要**显式地使用命名空间前缀**。
     - **可选值：**
       - **unqualified (默认值):** 局部元素**不需要**命名空间前缀。只有全局的、顶层的元素才需要。这是默认行为，但通常不是最佳实践。
       - **qualified (推荐值):** **所有**的元素，无论是全局的还是局部的，都**必须**属于目标命名空间（即需要命名空间前缀，或者通过默认命名空间隐式地属于）。这使得XML文档的结构更清晰、无歧义。**在绝大多数情况下，都应该设置为"qualified"。**

  4. **attributeFormDefault="qualified|unqualified"**

     - **类型：** 普通属性。
     - **含义：** **属性形式默认值。** 和elementFormDefault类似，但它规定的是**属性**是否需要命名空间前缀。
     - **可选值：**
       - **unqualified (默认值):** 属性**不需要**命名空间前缀，它们不属于任何命名空间。这是最常见、最普遍的做法。
       - **qualified:** 属性也**必须**属于目标命名空间。这种情况比较少见

  5. **其他命名空间声明 (xmlns:prefix="...")**

     - **类型：** 命名空间声明。

     - **含义：** 如果你的XSD需要引用**其他命名空间**的组件（比如，通过<xs:import>），你就需要在<xs:schema>上为那些外部命名空间声明一个前缀。

     - 示例

       ```xml
       <xs:schema xmlns:xs="http://www.w3.org/2001/XMLSchema"
                  targetNamespace="http://www.example.com/A"
                  xmlns:b="http://www.example.com/B"> 
           <!-- 现在可以在这里引用来自命名空间B的组件了 -->
       </xs:schema>
       ```



##### 声明类元素

- 可以把这类元素想象成XSD这门“立法语言”中的**“声明动词”**。它们的作用就是在你的Schema“法典”中，正式地、从无到有地**声明和定义**一个个新的、合法的构建块
  - **`<xs:element>`** - 用于声明一个**元素 (Element)**
  - **`<xs:attribute>`** - 用于声明一个**属性 (Attribute)**



##### 类型定义类元素

- 类型定义类元素就是定义了**“是什么样的”**。它们是XSD超越DTD的根本所在，为XML数据注入了严格的语义和约束。
- XSD将宇宙万物（所有元素和属性的内容）清晰地划分为两大“界”：**简单类型**和**复杂类型**。
  - 简单类型 (`<xs:simpleType>`)
  - 复杂类型 (`<xs:complexType>`)



##### 组合器

##### 引用于分组类元素





#### 在XML中使用XSD

- 将XSD关联到XML文档，本质上就是在XML文件内部，通过特定的属性，明确地告诉XML解析器：“嘿，请用这个指定的`.xsd`文件作为‘蓝图’或‘法律’来检查我！”(也可以在外面操作，然后在XML内部就不用写关联的语句了)

##### 第一步：声明xsi命名空间

- 无论你使用哪种关联方式，第一步总是在你的XML文档的根元素上，声明**`xsi`命名空间**

  ```XML
  xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
  ```

##### 第二步

- 根据你的XML文档本身**是否使用了命名空间**，关联XSD的方式分为两种

  - **场景一：XML文档本身没有命名空间 (No Namespace)**

    - 这是最简单、最常见的情况。你的XML元素都是普通的，没有前缀，也没有默认命名空间。

      - **使用的工具属性：** xsi:noNamespaceSchemaLocation

      - **属性值的含义：** 直接就是你的.xsd文件的**路径（URI）**。这个路径可以是本地相对路径、绝对路径，也可以是一个网络URL

      - 示例

        ```xml
        <?xml version="1.0" encoding="UTF-8" ?>
        <xs:schema xmlns:xs="http://www.w3.org/2001/XMLSchema">
          <xs:element name="person">
            <xs:complexType>
              <xs:sequence>
                <xs:element name="name" type="xs:string"/>
                <xs:element name="age" type="xs:positiveInteger"/>
              </xs:sequence>
            </xs:complexType>
          </xs:element>
        </xs:schema>
        ```

        ```xml
        <?xml version="1.0" encoding="UTF-8"?>
        <!-- 
          1. 声明xsi命名空间。
          2. 使用xsi:noNamespaceSchemaLocation属性，直接指向xsd文件的位置。
        -->
        <person xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
                xsi:noNamespaceSchemaLocation="person.xsd">
                
            <name>张三</name>
            <age>30</age>
        </person>
        ```

  - **场景二：XML文档使用了命名空间**

    - **使用的工具属性：** xsi:schemaLocation

    - **属性值的含义：** 这是一个**成对出现**的值，中间用**空格**隔开：

      ```xml
      "目标命名空间URI   Schema文件的路径URI"
      ```

      - **第一部分 (目标命名空间URI):** 必须与你的XML文档中想要验证的元素所使用的命名空间完全匹配。
      - **第二部分 (Schema文件的路径URI):** 指向定义了该命名空间规则的.xsd文件的位置。

    - 示例

      ```xml
      <?xml version="1.0" encoding="UTF-8" ?>
      <!-- 声明这个Schema定义的是"http://www.example.com/library"命名空间 -->
      <xs:schema xmlns:xs="http://www.w3.org/2001/XMLSchema"
                 targetNamespace="http://www.example.com/library"
                 elementFormDefault="qualified">
      
        <xs:element name="book">
          <xs:complexType>
            <xs:sequence>
              <xs:element name="title" type="xs:string"/>
            </xs:sequence>
          </xs:complexType>
        </xs:element>
      </xs:schema>
      ```

      ```xml
      <?xml version="1.0" encoding="UTF-8"?>
      <!-- 
        1. 声明你的业务命名空间，这里用默认命名空间的方式。
        2. 声明xsi命名空间。
        3. 使用xsi:schemaLocation属性，提供"命名空间"和"XSD位置"的对应关系。
      -->
      <book xmlns="http://www.example.com/library"
            xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
            xsi:schemaLocation="http://www.example.com/library library.xsd">
            
          <title>The Art of XML</title>
      </book>
      ```







## 处理特殊字符

- 在XML中，为了确保**字符数据**与**句法标记**之间不存在二义性，XML规范定义了以**实体引用**和**CDATA区块**为核心的机制，对语法中的预留字符（如**`<`**和**`&`**）进行处理



### 实体引用

- **实体**在 XML 中是一个“**命名的数据块**”。可以把它理解成一个**变量**或一个**别名**。

  - 先给一小段数据（**可以是一个字符，一段文字，甚至一个外部文件**）起个名字，之后在文档中就可以通过这个名字来引用它
    - 最贴切的比喻是**“起外号”**

  - **实体引用 (Entity Reference)** 就是在文档中**使用这个名字**的动作



#### 语法格式

- 在 XML 中，实体引用的语法是固定的
  -  **`&实体名;`** 
     - 由一个 **`&`** 开始
     - 由一个 **`;`** 结束



#### 实体引用的分类

##### 预定义实体

- **XML 规范已经提前为我们定义好的 5 个 实体**

- 我们**最常用**，也是解决特殊字符问题的关键。

  - 是**内置在所有 XML 解析器中的**，**无需我们做任何事，可以直接使用**

- 唯一目的就是用来**表示那 5 个在 XML 语法中有特殊含义的字符**

  - **5个特殊字符及其实体引用如下**

    | **特殊字符** | **实体引用** | **中文描述** |
    | ------------ | ------------ | ------------ |
    | **`<`**      | **`&lt;`**   | **小于号**   |
    | **`>`**      | **`&gt;`**   | **大于号**   |
    | **`&`**      | **`&amp;`**  | **和号**     |
    | **`'`**      | **`&apos;`** | **单引号**   |
    | **`"`**      | **`&quot;`** | **双引号**   |

- 示例

  ```xml
  <script-info name="Q&A_Script" version="1.0">
    <description>This script's purpose is to check if 5 &lt; 10.</description>
    <author comment="He said, &quot;It's awesome!&quot;"/>
  </script-info>
  ```

  

##### 自定义实体

- 除了使用内置的 5 个实体，还可以创建**属于自己的实体**，以达到**内容复用**和**模块化**的目的

- 自定义实体必须在 **DTD** 中进行声明。DTD 是一种为 XML 文档定义结构和合法构建块的“蓝图”。（也可以在 XSD 中定义，但 DTD 是最经典的用法）

- 自定义实体分为**内部实体**和**外部实体**

  

###### 内部实体

- 实体的值（它所代表的文本）直接在 DTD 中定义。

  - **语法**：

    - 定义：**`<!ENTITY 实体名 "实体的值">`**
    - 引用：**`&实体名`**

  - **示例**：假设你的公司名 **"FutureTech Innovations, Inc."** 在文档中要出现很多次

    ```xml
    <?xml version="1.0"?>
    <!DOCTYPE document [
      <!ENTITY company "FutureTech Innovations, Inc.">
      <!ENTITY copyright_year "2025">
    ]>
    <document>
      <header>
        <h1>Welcome to &company;</h1>
      </header>
      <footer>
        <p>Copyright &copy; &copyright_year; &company;. All rights reserved.</p>
      </footer>
    </document>
    ```

    



###### 外部实体

- 实体的值存储在一个外部文件中。这使得你可以将大块内容（如页眉、页脚、法律条款）模块化。

  - **语法**：**`<!ENTITY 实体名 SYSTEM "文件的URI">`**

  - **示例**：将页脚内容放在一个单独的 `footer.html` 文件里。

    - **`footer.html` 文件内容：**

      ```xml
      <p>Contact us at contact@example.com</p>
      ```

    - xml文档

      ```xml
      <?xml version="1.0"?>
      <!DOCTYPE report [
        <!ENTITY footer_content SYSTEM "footer.html">
      ]>
      <report>
        <title>Annual Report</title>
        <content>
          ... main content here ...
        </content>
        &footer_content;
      </report>
      ```

###### 现代视角看待自定义实体

- 虽然自定义实体很强大，但在现代XML实践中，它的**使用频率已经大大降低了**，原因如下：

  - **与XSD不兼容：** XML Schema (XSD) 是目前验证XML的主流标准，但XSD**不支持**定义实体这种文本替换功能。实体的定义是DTD的专属特性。

  - **安全风险 - XXE攻击！(极其重要)**
    外部实体特性带来了一个严重的安全漏洞，叫做**“XML外部实体注入 (XML External Entity Injection, XXE)”**。
    黑客可以构造一个恶意的XML文件，利用外部实体来读取你服务器上的敏感文件！

    - **恶意XML示例：**

    ```xml
    <!DOCTYPE foo [
      <!ENTITY xxe SYSTEM "file:///etc/passwd"> 
    ]>
    <stockCheck>
      <productId>&xxe;</productId>
    </stockCheck>
    ```

    - 如果服务器上的XML解析器没有禁用外部实体，它就会尝试读取服务器上的/etc/passwd文件，并将其内容作为响应的一部分返回给黑客。**因此，现代所有的XML解析器，默认情况下都应该禁用或严格限制外部实体的解析。**



### CDATA区块

#### 相关概念

- **CDATA** 是 **Character Data** 的缩写，直译过来就是“**字符数据**”
- 在XML中，**CDATA区段是一个特殊的、被标记的文本块。文本块中的内容**将被当作**最纯粹的、原封不动的普通文本来处理**

#### 语法格式

- **开始标记：** **`<![CDATA[`** (9个字符，必须大写)
- **结束标记：** **`]]>`** (3个字符)

```XML
<![CDATA[

  这里可以包含任何你想要的文本，
  包括 < > & " ' 这些特殊字符，
  无需进行任何转义！

]]>
```

- **一个重要的限制：** CDATA区段的**内容中不能包含**字符串 ]]>，因为它会被解析器认为是区段的结束。这是它唯一的限制。



#### 示例

- 不管写什么都不会转义

  ```xml
  <script>
     <!-- 看！下面完全不需要转义 -->
    <![CDATA[
      function compare(a, b) {
        if (a < b && b > 0) { 	 
          alert("Condition is true!");
        }
      }
    ]]>
  </script>
  ```

  

- 如果想在XML里存储一段HTML代码作为数据

  ```xml
  <article>
    <title>我的博客</title>
    <content>
      <![CDATA[
        <h1>欢迎来到我的主页</h1>
        <p>这是一个段落，里面有<b>加粗</b>标签。</p>
        <a href="http://example.com?a=1&b=2">一个链接</a>
      ]]>
    </content>
  </article>
  ```

  



## XML解析器

### 介绍

- **XML解析器就是一个软件库或程序，它的核心工作是读取** **`.xml`** **文件的文本内容，并将其转换成你的编程语言能够理解和操作的内存中的数据结构。**



### 文档约束

- **文档约束分为良构约束和有效性约束**

#### 良构约束

- **“良构约束”**是直接写在 **W3C XML 1.0/1.1 规范** 中的一套**硬性语法规则**
  - **规则来源：** **XML 1.0/1.1 规范自身**。它不需要任何外部文件（如**`.xsd`**或**`.dtd`**）
  - **目标：** 保证一个文档是 **“格式良好 (Well-Formed)”** 的
  - **检查内容：** 纯粹的**语法 (Syntax)**，与业务内容完全无关
  - **强制性：** **绝对强制！** 任何XML解析器都**必须**检查WFCs。如果违反了任何一条，解析器会立即报错并停止工作

#### 有效性约束

- “有效性约束”是在**外部模式文件（如 DTD 或 XSD）**中定义的一套**结构和内容规则**。它们是为特定类型的XML文档量身定做的“蓝图”
  - **规则来源：** **外部的模式文件 (Schema)**，例如 **`.xsd`**, **`.dtd`** 等
  - **目标：** 保证一个“格式良好”的文档，其内容和结构也是 **“有效 (Valid)”** 的
  - **检查内容：** **结构 (Structure)** 与 **内容 (Content)**，是与业务逻辑紧密相关的
  - **强制性：** **可选的！** 只有当XML文档**声明**了它要遵守某个模式文件时，解析器才会进行VCs的检查。如果没有声明，解析器会完全跳过这一步。





### 解析器核心工作阶段

- 解析器核心有两个阶段：**解析**和**验证**

#### 第一阶段：解析

- **解析 (Parsing)：检查“格式良好” (Well-Formed)**
  - 这是**第一步，也是强制性的一步**。解析器会像“语法警察”一样，逐行检查XML文件是否遵守了XML 1.0/1.1的所有**“良构约束 (WFCs)”**
  - 如果全部通过，解析器就在内存中成功建立了一个数据结构（比如DOM树）。**“解析”到此成功**
  - 如果失败，它会立刻报错并停止，你的程序连数据都读不到

#### 第二阶段：验证

- **验证 (Validation)：检查“有效性” (Valid)**
  - 这是**第二步，是可选的一步**。只有在解析成功后，解析器才会做这件事。
  - 解析器会检查XML文件内部是否声明了XML模式语言（DTD或XSD）。
    - **如果声明了：** 解析器会去加载这个模式文件，然后用里面的**“有效性约束 (VCs)”**来逐一检查内存中的数据结构。比如，**`<age>`**是不是数字？**`<status>`**是不是预设的几个值之一？
      - 这种情况下，如果发现错误，也会直接**报错并停止**
    - **如果没声明：** 解析器会**完全跳过**这一步



### 解析模型

#### 两大经典解析模型

- XML解析器**读取和处理XML的方式**，主要有两种经典的思想流派：**DOM** 和 **SAX**
- **DOM和SAX不是解析器工作流程中的不同“阶段”，而是两种完全不同的、从头到G尾的“工作方式”或“策略”**
  - 一个解析器在某一次操作中，要么作为一个**“DOM解析器”**工作，要么作为一个**“SAX解析器”**工作

##### DOM

- **DOM(文档对象模型 - Document Object Model)**

- **工作方式：** **一次性加载，建立完整模型。**

  - DOM解析器会**一口气读完整个XML文件**，然后在内存中构建一棵**完整**的、与原始XML结构完全对应的“**树**”(DOM Tree)
    这棵树的**每一个节点（元素、属性、文本）都是一个可以操作的对象**

- **优点：**

  - **直观易用：** 整棵树都在内存里，你可以随意地在树上**前进、后退、遍历、查找**任何节点。
  - **可修改：** 你可以轻松地在这棵树上**增加、删除、修改**节点，然后再把整棵树写回成一个新的XML文件。

- **缺点：**

  - **消耗内存：** 如果XML文件非常大（比如几个G），一次性把它全部加载到内存中，可能会直接导致**内存溢出 (Out of Memory)**
  - **启动速度慢**：必须读完整本书才能开始工作，所以初始加载时间较长。

- **适用场景**：

  - XML 文件体积不大（通常在几十兆以内）。
  - 需要频繁地在文档中前后导航、查找信息。
  - 需要对 XML 结构进行增、删、改的操作。
  - **例如**：解析应用程序的配置文件。

- DOM树

  ![image-20250727184623209](./assets/image-20250727184623209.png)

##### **SAX**

- **SAX(Simple API for XML)**

- **工作方式：** **事件驱动，边读边处理。**
  - SAX解析器不会在内存中构建任何完整的树。它像一个**流水线上的扫描仪**，从头到尾地读取XML文件，每当遇到一个特定的东西（比如一个元素的开始、一个元素的结束、一段文本），它就会**触发一个“事件”**，然后调用你预先写好的“事件处理器”代码。
- **优点：**
  - **速度极快，内存占用极小：** 因为它**不需要存储整个文件**，所以**处理超大文件的速度非常快，内存消耗几乎为零**
- **缺点：**
  - **编程复杂：** 你**无法“回头”或“向前看”**，因为数据是流式的。你**需要自己管理状态**（比如，当前在哪个元素内部）
  - **无法修改：** 因为它只是一个只读的事件流，你无法用它来修改XML

- **适用场景**：
  - 处理非常巨大的 XML 文件。
  - 只需要从 XML 中提取少量信息，且只需读取一次。
  - 服务器端需要同时处理大量 XML 请求，内存敏感。
  - **例如**：处理银行的交易流水日志文件。



#### 现代的解析方式

- 我们在Java代码中一般用**开源的第三方Java库dom4j**来进行**读写和操作XML文件**，**它是一个非常流行且强大的“增强版DOM模型”**



## Xpath

- XPath，全称**XML Path Language**，即**XML路径语言**。它**是一种专门用来在XML（可扩展标记语言）和HTML文档中查找和定位信息的语言**。可以把它想象成一个**功能强大的“地址系统”**，**通过这个系统，可以精确地找到文档中任何一个或一组元素、属性或文本。**
  - 虽然**XPath最初是为XML设计的**，但由于HTML文档的结构与XML非常相似，它**现在被广泛应用于网络爬虫、自动化测试（如Selenium）等领域，用于从网页中提取数据**





## dom4j

- dom4j 是一个开源的、基于 Java 的库，用于处理 XML。它的名字是 "**Document Object Model for Java**" 的缩写，但它在传统的 W3C-DOM 模型上做了很多改进，提供了更直观、更灵活的 API。
  - **结合了 DOM 和 SAX 的优点**。它**内部使用 SAX 来解析文档，从而保证了良好的性能，同时对外提供了类似 DOM 的树状API，使得导航、查询和修改变得极其简单**。它还集成了 XPath，让节点查询变得异常强大和便捷



### 使用前的准备工作

- 添加 dom4j 依赖



### 核心概念与主要类

- **`Document`**: 代表整个 XML 文档。它是树的根，你可以通过它获取根元素

- **`Element`**: 代表一个 XML 元素（标签）。这是你打交道最多的对象。它可以包含其他 **`Element`**、**`Attribute`** 和文本

- **`Attribute`**: 代表元素的属性

- **`Node`**: 是 **`Document`**, **`Element`**, **`Attribute`** 等的父接口，代表树中的一个节点

- **`SAXReader`**: 这是 **dom4j 的读取器**。顾名思义，它**使用 SAX 在后台读取和解析 XML 文件**，并**最终构建成一个 `Document` 对象**

- **`XMLWriter`**:**写入器**。负责将内存中的 **`Document` 对象**写回到文件或输出流中。
- **`DocumentHelper`**：**辅助工具类**。用于在没有源文件的情况下，凭空创建 **`Document`**、**`Element`** 等对象。



### 常用方法

#### 1. `Element` (元素)

**说明:** `Element` 对象是 dom4j 的核心，代表一个 XML 标签。以下方法全部为**实例方法**，需要通过一个 `Element` 对象（这里用 `element` 作为示例）来调用。

| 方法 (Method)                                     | 类型 (Type) | 返回类型 (Return Type) | 说明 (Description)                                    |
| :------------------------------------------------ | :---------- | :--------------------- | :---------------------------------------------------- |
| **导航与获取**                                    |             |                        |                                                       |
| `element.getParent()`                             | 实例        | `Element`              | 获取当前元素的父元素。                                |
| `element.getDocument()`                           | 实例        | `Document`             | 获取当前元素所属的 `Document` 对象。                  |
| `element.elements()`                              | 实例        | `List<Element>`        | 获取当前元素下的**所有**直接子元素。                  |
| `element.elements(String name)`                   | 实例        | `List<Element>`        | 获取当前元素下所有**指定名称**的直接子元素。          |
| `element.element(String name)`                    | 实例        | `Element`              | 获取当前元素下**第一个**指定名称的直接子元素。        |
| `element.getName()`                               | 实例        | `String`               | 获取元素的标签名。                                    |
| `element.getText()`                               | 实例        | `String`               | 获取元素的文本内容，包含前后空格。                    |
| `element.getTextTrim()`                           | 实例        | `String`               | 获取元素的文本内容，并去除前后空格。**(常用)**        |
| `element.elementText(String name)`                | 实例        | `String`               | 获取指定子元素的文本内容。**(推荐)**                  |
| `element.elementTextTrim(String name)`            | 实例        | `String`               | 获取指定子元素的文本内容，并去除前后空格。**(推荐)**  |
| `element.attribute(String name)`                  | 实例        | `Attribute`            | 获取指定名称的 `Attribute` 对象。                     |
| `element.attributeValue(String name)`             | 实例        | `String`               | 直接获取指定名称的属性值。**（极其常用）**            |
| `element.attributes()`                            | 实例        | `List<Attribute>`      | 获取该元素的所有属性对象。                            |
| **修改与添加**                                    |             |                        |                                                       |
| `element.setName(String name)`                    | 实例        | `void`                 | 修改元素的标签名。                                    |
| `element.setText(String text)`                    | 实例        | `void`                 | 设置元素的文本内容，会覆盖旧内容。                    |
| `element.addElement(String name)`                 | 实例        | `Element`              | 添加一个新的子元素，并返回这个新元素。**（常用）**    |
| `element.addAttribute(String name, String value)` | 实例        | `Element`              | 添加一个属性，并返回当前元素自身（方便链式调用）。    |
| `element.addComment(String comment)`              | 实例        | `Element`              | 添加一个注释节点。                                    |
| `element.addCDATA(String cdata)`                  | 实例        | `Element`              | 添加一个 CDATA 节点。                                 |
| `element.remove(Element subElement)`              | 实例        | `boolean`              | 移除一个指定的子元素。                                |
| `element.remove(Attribute attribute)`             | 实例        | `boolean`              | 移除一个指定的属性。                                  |
| **XPath 查询**                                    |             |                        |                                                       |
| `element.selectNodes(String xpath)`               | 实例        | `List<Node>`           | 根据 XPath 查询并返回所有匹配的节点。**（核心功能）** |
| `element.selectSingleNode(String xpath)`          | 实例        | `Node`                 | 根据 XPath 查询并返回第一个匹配的节点。               |
| `element.valueOf(String xpath)`                   | 实例        | `String`               | 根据 XPath 获取匹配节点的字符串值。**(推荐)**         |

---

#### 2. `Document` (文档)

**说明:** 代表整个 XML 文档的对象。以下方法均为**实例方法**，通过一个 `Document` 对象（这里用 `document` 作为示例）来调用。

| 方法 (Method)                                                | 类型 (Type) | 返回类型 (Return Type) | 说明 (Description)                          |
| :----------------------------------------------------------- | :---------- | :--------------------- | :------------------------------------------ |
| `document.getRootElement()`                                  | 实例        | `Element`              | 获取文档的根元素。**（最核心方法）**        |
| `document.addElement(String name)`                           | 实例        | `Element`              | 为文档添加根元素（仅当文档无根时）          |
| `document.addComment(String text)`                           | 实例        | `Document`             | 在文档级别添加注释                          |
| `document.addProcessingInstruction(String target, String data)` | 实例        | `Document`             | 添加处理指令                                |
| `document.selectNodes(String xpath)`                         | 实例        | `List<Node>`           | 从整个文档范围执行 XPath 查询               |
| `document.selectSingleNode(String xpath)`                    | 实例        | `Node`                 | 从整个文档范围执行 XPath 查询，返回单个节点 |
| `document.getXMLEncoding()`                                  | 实例        | `String`               | 获取在XML声明中指定的编码                   |

---

#### 3. `SAXReader` (读取器)

**说明:** 用于从文件或流中解析 XML。你需要先 `new` 一个实例。

| 方法 (Method)                              | 类型 (Type) | 返回类型 (Return Type) | 说明 (Description)                       |
| :----------------------------------------- | :---------- | :--------------------- | :--------------------------------------- |
| `new SAXReader()`                          | 构造器      | `SAXReader`            | 创建一个新的 `SAXReader` 实例。          |
| `reader.read(File file)`                   | 实例        | `Document`             | 从文件对象读取并解析 XML。**（最常用）** |
| `reader.read(InputStream in)`              | 实例        | `Document`             | 从输入流读取并解析 XML。                 |
| `reader.read(String url)`                  | 实例        | `Document`             | 从 URL (文件路径或网址) 读取并解析 XML。 |
| `reader.setEncoding(String encoding)`      | 实例        | `void`                 | 设置解析时使用的字符编码。               |
| `reader.setValidation(boolean validation)` | 实例        | `void`                 | 设置是否需要 DTD 验证，默认为 `false`。  |

---

#### 4. `XMLWriter` (写入器)

**说明:** 用于将 `Document` 对象写入到文件或流。

| 方法 (Method)                             | 类型 (Type) | 返回类型 (Return Type) | 说明 (Description)                                        |
| :---------------------------------------- | :---------- | :--------------------- | :-------------------------------------------------------- |
| `new XMLWriter(Writer w, OutputFormat f)` | 构造器      | `XMLWriter`            | 创建一个新的 `XMLWriter` 实例。                           |
| `writer.write(Document doc)`              | 实例        | `void`                 | 将 `Document` 对象写入目标。                              |
| `writer.write(Element element)`           | 实例        | `void`                 | 将一个 `Element` 对象（及其所有子节点）写入。             |
| `writer.close()`                          | 实例        | `void`                 | 关闭写入器。**（必须调用，建议使用 try-with-resources）** |
| `writer.flush()`                          | 实例        | `void`                 | 刷新输出缓冲区。                                          |

---

#### 5. `OutputFormat` (输出格式)

**说明:** 用于配置 `XMLWriter` 的输出样式。它既有静态工厂方法，也有实例配置方法

| 方法 (Method)                        | 类型 (Type) | 返回类型 (Return Type) | 说明 (Description)                                   |
| :----------------------------------- | :---------- | :--------------------- | :--------------------------------------------------- |
| `OutputFormat.createPrettyPrint()`   | **静态**    | `OutputFormat`         | 创建一个美化格式的对象（带缩进和换行）。**（常用）** |
| `OutputFormat.createCompactFormat()` | **静态**    | `OutputFormat`         | 创建一个紧凑格式的对象（无额外空白）。               |
| `format.setEncoding(String enc)`     | 实例        | `void`                 | **设置输出编码，极其重要，防止乱码。**               |
| `format.setIndent(String indent)`    | 实例        | `void`                 | 设置用于缩进的字符串（如 "  " 或 "\t"）。            |
| `format.setIndentSize(int size)`     | 实例        | `void`                 | 设置缩进的空格数量。                                 |
| `format.setNewlines(boolean nl)`     | 实例        | `void`                 | 设置是否生成新行。                                   |
| `format.setTrimText(boolean trim)`   | 实例        | `void`                 | 设置是否在写入前去除元素文本的空白。                 |

---

#### 6. `DocumentHelper` (辅助工具)

**说明:** 一个纯工具类，所有方法都是**静态的**，通过类名直接调用。

| 方法 (Method)                               | 类型 (Type) | 返回类型 (Return Type) | 说明 (Description)                                           |
| :------------------------------------------ | :---------- | :--------------------- | :----------------------------------------------------------- |
| `DocumentHelper.createDocument()`           | **静态**    | `Document`             | 创建一个空的 `Document` 对象。                               |
| `DocumentHelper.createElement(String name)` | **静态**    | `Element`              | 创建一个独立的 `Element` 对象。                              |
| `DocumentHelper.createText(String text)`    | **静态**    | `Text`                 | 创建一个独立的 `Text` 节点。                                 |
| `Document.parseText(String text)`           | **静态**    | `Document`             | 将一段 XML 格式的字符串直接解析成 `Document`。**（非常实用）** |

---

#### 7. `Attribute` (属性)

**说明:** 代表元素的属性。通过 `Element` 对象获取 `Attribute` 实例后调用。

| 方法 (Method)                      | 类型 (Type) | 返回类型 (Return Type) | 说明 (Description)     |
| :--------------------------------- | :---------- | :--------------------- | :--------------------- |
| `attribute.getName()`              | 实例        | `String`               | 获取属性的名称。       |
| `attribute.getValue()`             | 实例        | `String`               | 获取属性的值。         |
| `attribute.setValue(String value)` | 实例        | `void`                 | 修改属性的值。         |
| `attribute.getParent()`            | 实例        | `Element`              | 获取该属性所属的元素。 |



### 实战

#### 解析XML文件

##### xml文件示例

- 假设我们有一个 `students.xml` 文件，内容如下：

  ```xml
  <?xml version="1.0" encoding="UTF-8"?>
  <class name="Java进阶班">
      <student id="001">
          <name>张三</name>
          <age>18</age>
          <gender>男</gender>
      </student>
      <student id="002">
          <name>李四</name>
          <age>20</age>
          <gender>女</gender>
      </student>
      <student id="003">
          <name>王五</name>
          <age>19</age>
          <gender>男</gender>
      </student>
  </class>
  ```

##### 读取并解析 XML

- 所有操作的第一步：将 XML 文件读入内存，并转换成一个 `Document` 对象

  ```java
  import org.dom4j.Document;
  import org.dom4j.DocumentException;
  import org.dom4j.io.SAXReader;
  
  import java.io.File;
  
  public class Dom4jReadExample {
      public static void main(String[] args) {
          try {
              // 1. 创建 SAXReader 对象
              SAXReader reader = new SAXReader();
  
              // 2. 指定要解析的 XML 文件
              File xmlFile = new File("path/to/your/students.xml");
  
              // 3. 调用 read 方法，将文件解析为 Document 对象
              Document document = reader.read(xmlFile);
  
              System.out.println("XML 文档加载成功！");
              // 接下来就可以对 document 对象进行操作了
              
          } catch (DocumentException e) {
              System.out.println("XML 解析错误！");
              e.printStackTrace();
          }
      }
  }
  ```

##### 遍历节点并获取数据

- 获取到 `Document` 对象后，我们就可以像操作树一样来获取里面的数据

  ```java
  import org.dom4j.Document;
  import org.dom4j.DocumentException;
  import org.dom4j.Element;
  import org.dom4j.io.SAXReader;
  
  import java.io.File;
  import java.util.List;
  
  public class Dom4jParseExample {
  
      public static void main(String[] args) {
          try {
              SAXReader reader = new SAXReader();
              Document document = reader.read(new File("path/to/your/students.xml"));
  
              // 1. 获取根元素 <class>
              Element rootElement = document.getRootElement();
              System.out.println("根元素名称: " + rootElement.getName());
  
              // 2. 获取根元素的属性
              String className = rootElement.attributeValue("name");
              System.out.println("班级名称: " + className);
              System.out.println("--------------------");
  
              // 3. 获取所有的 <student> 元素
              // elements("student") 返回一个包含所有名为 "student" 的子元素的列表
              List<Element> studentElements = rootElement.elements("student");
  
              // 4. 遍历 List<Element>
              for (Element student : studentElements) {
                  // 获取 student 元素的 id 属性值
                  String id = student.attributeValue("id");
  
                  // 获取 student 下的子元素 <name> 和 <age>
                  // element("name") 返回第一个名为 "name" 的子元素
                  Element nameElement = student.element("name");
                  Element ageElement = student.element("age");
                  Element genderElement = student.element("gender");
  
                  // 获取元素的文本内容
                  String name = nameElement.getText();
                  String age = ageElement.getTextTrim(); // getTextTrim() 会去除前后空格
                  String gender = genderElement.getText();
  
                  System.out.println("学生信息:");
                  System.out.println("  ID: " + id);
                  System.out.println("  姓名: " + name);
                  System.out.println("  年龄: " + age);
                  System.out.println("  性别: " + gender);
                  System.out.println();
              }
  
          } catch (DocumentException e) {
              e.printStackTrace();
          }
      }
  }
  ```

##### 常用方法

```java
document.getRootElement(): 			//获取根元素。

element.elements(): 				//获取当前元素下的所有直接子元素。

element.elements("elementName"): 	//获取当前元素下所有指定名称的直接子元素。

element.element("elementName"): 	//获取当前元素下指定名称的第一个直接子元素。

element.attributeValue("attrName"): //获取指定属性的值。

element.getText():					 //获取元素的文本内容。

element.getTextTrim(): 				//获取元素的文本内容，并去除首尾空格。
```



#### 使用XPath查询

- 当 XML 结构很复杂时，一层一层地 **`element()`** 下去会非常繁琐。

  - XPath (XML Path Language) 是一种用于在 XML 文档中查找信息的语言，使用 XPath，你可以用一个字符串路径表达式直接定位到你想要的节点，非常高效。
  - dom4j 对它提供了完美的支持

  ```java
  import org.dom4j.Document;
  import org.dom4j.Node;
  import org.dom4j.io.SAXReader;
  
  import java.io.File;
  import java.util.List;
  
  public class Dom4jXPathExample {
      public static void main(String[] args) throws Exception {
          SAXReader reader = new SAXReader();
          Document document = reader.read(new File("path/to/your/students.xml"));
  
          // 1. 使用 XPath 查找所有 <student> 节点
          // "//student" 表示从文档任意位置开始查找所有名为 "student" 的元素
          System.out.println("--- 查找所有学生 ---");
          List<Node> studentNodes = document.selectNodes("//student");
          for (Node node : studentNodes) {
              // node.valueOf("子元素名或@属性名") 是获取值的便捷方法
              System.out.println("姓名: " + node.valueOf("name"));
          }
  
          // 2. 使用 XPath 查找第一个 <student> 节点
          System.out.println("\n--- 查找第一个学生 ---");
          Node firstStudent = document.selectSingleNode("//student");
          System.out.println("ID: " + firstStudent.valueOf("@id")); // @id 表示 id 属性
          System.out.println("姓名: " + firstStudent.valueOf("name"));
  
          // 3. 使用带条件的 XPath 查找 id 为 "003" 的学生
          System.out.println("\n--- 查找 ID 为 003 的学生 ---");
          Node student003 = document.selectSingleNode("//student[@id='003']");
          System.out.println("姓名: " + student003.valueOf("name"));
          System.out.println("年龄: " + student003.valueOf("age"));
      }
  }
  ```



#### 创建和修改 XML

- dom4j 不仅能读，还能写。创建和修改 XML 也非常直观

##### 创建一个新的 XML 文件

```java
import org.dom4j.Document;
import org.dom4j.DocumentHelper;
import org.dom4j.Element;
import org.dom4j.io.OutputFormat;
import org.dom4j.io.XMLWriter;

import java.io.FileWriter;
import java.io.IOException;

public class Dom4jCreateExample {
    public static void main(String[] args) {
        // 1. 使用 DocumentHelper 创建一个 Document 对象
        Document document = DocumentHelper.createDocument();

        // 2. 添加根元素
        Element booksElement = document.addElement("books");

        // 3. 在根元素下添加子元素和属性
        Element book1 = booksElement.addElement("book").addAttribute("id", "b01");
        book1.addElement("title").setText("Java核心技术");
        book1.addElement("author").setText("Cay S. Horstmann");

        Element book2 = booksElement.addElement("book").addAttribute("id", "b02");
        book2.addElement("title").setText("Effective Java");
        book2.addElement("author").setText("Joshua Bloch");

        // 4. 将 Document 对象写入文件
        XMLWriter writer = null;
        try {
            // 创建漂亮的格式 (带缩进和换行)
            OutputFormat format = OutputFormat.createPrettyPrint();
            format.setEncoding("UTF-8"); // 指定编码

            writer = new XMLWriter(new FileWriter("new_books.xml"), format);
            writer.write(document);
            System.out.println("new_books.xml 创建成功！");
        } catch (IOException e) {
            e.printStackTrace();
        } finally {
            if (writer != null) {
                try {
                    writer.close();
                } catch (IOException e) {
                    e.printStackTrace();
                }
            }
        }
    }
}
```



##### 修改现有 XML 文件

- 修改的逻辑是：**读取 -> 在内存中修改 -> 写回文件**

  ```java
  public class Dom4jModifyExample {
      public static void main(String[] args) throws Exception {
          File xmlFile = new File("path/to/your/students.xml");
          
          // --- 读取 ---
          SAXReader reader = new SAXReader();
          Document document = reader.read(xmlFile);
  
          // --- 在内存中修改 ---
          // 1. 找到 id 为 "003" 的学生
          Node studentNode = document.selectSingleNode("//student[@id='003']");
          if (studentNode instanceof Element) {
              Element studentElement = (Element) studentNode;
              
              // 2. 修改他的年龄
              Element ageElement = studentElement.element("age");
              ageElement.setText("21"); // 把王五的年龄从 19 改为 21
              System.out.println("王五的年龄已修改。");
  
              // 3. 为他添加一个新元素 <city>
              studentElement.addElement("city").setText("北京");
              System.out.println("为王五添加了城市信息。");
          }
  
          // 4. 添加一个全新的学生
          Element root = document.getRootElement();
          Element newStudent = root.addElement("student").addAttribute("id", "004");
          newStudent.addElement("name").setText("赵六");
          newStudent.addElement("age").setText("22");
          newStudent.addElement("gender").setText("男");
          System.out.println("添加了新学生赵六。");
  
  
          // --- 写回文件 ---
          XMLWriter writer = new XMLWriter(
              new FileWriter(xmlFile), // 直接覆盖原文件
              OutputFormat.createPrettyPrint()
          );
          writer.write(document);
          writer.close();
          System.out.println("students.xml 文件已更新！");
      }
  }
  ```

##### 修改后的xml文件

```xml
<?xml version="1.0" encoding="UTF-8"?>
<class name="Java进阶班">
    ...
    <student id="003">
        <name>王五</name>
        <age>21</age>
        <gender>男</gender>
        <city>北京</city>
    </student>
    <student id="004">
        <name>赵六</name>
        <age>22</age>
        <gender>男</gender>
    </student>
</class>
```
