# 排序

**排序** 是后端开发中最常见的数据处理操作之一。在 Java 中，排序不仅仅是调用一个 `sort()` 方法那么简单



## 1. 数组与比较器

### 01. 数组排序 (`Arrays.sort`)

#### 1. 核心算法机制

Java 的 `Arrays.sort()` 非常智能，它会根据你传入的 **数据类型** 自动切换算法

| 数据类型         | 典型代表                          | 采用算法         | 核心特性                                                     |
| ---------------- | --------------------------------- | ---------------- | ------------------------------------------------------------ |
| **基本数据类型** | `int[]`, `long[]`, `double[]`     | **双轴快速排序** | 🚀 **极快，但不稳定** 平均时间复杂度 $O(n \log n)$。空间复杂度 $O(\log n)$ |
| **对象引用类型** | `Integer[]`, `String[]`, `User[]` | **TimSort**      | ⚖️ **稳定** 时间复杂度 $O(n \log n)$。需要 $O(n)$ 的额外空间  |

> **什么是“稳定性”？** 
>
> - 如果数组中有两个 `5`（记为 5A 和 5B），排序前 5A 在 5B 前面
>
>   - **稳定排序**：排序后 5A 依然在 5B 前面。
>
>   - **不稳定排序**：排序后 5A 可能会跑到 5B 后面
>
> - *对象排序通常要求稳定（比如先按日期排，再按金额排），而基本类型数字没这个需求*



#### 2. 核心 API (`sort(xxx)`)

以下方法均属于 `java.util.Arrays` 类的静态方法

- **`void sort(int[] a)`** (覆盖所有基本类型)
  - **作用**：对数组进行 **升序** 排序
  - **原地修改**：该方法没有返回值，直接修改传入的数组
  - **避坑**：
    - 如果你想对 `int[]` 进行 **倒序（降序）**排序，**不能** 直接使用 `Collections.reverseOrder()`，因为基本类型不支持泛型
    - 你只能先 `sort()` 升序，再手动写循环反转数组；或者把 `int[]` 变成 `Integer[]`



- **`void sort(int[] a, int fromIndex, int toIndex)`**
  - **作用**：**局部排序**
  - **范围**：遵循 Java 惯例，**包头不包尾** `[fromIndex, toIndex)`
  - **场景**：只需要数组中某一段有序时使用，性能更高



- **`void sort(Object[] a)`**

  - **作用**：对对象数组进行 **自然排序**（升序）

  - **前提**：数组中的对象类必须实现 `Comparable` 接口（例如 `String`、`Integer` 都实现了）。否则运行时会抛出 `ClassCastException`

  - **避坑**：`Arrays.asList()` 陷阱

    ```java
    String[] arr = {"b", "a"};
    // Arrays.asList 返回的是一个内部类 "ArrayList"
    // 这个 List 并没有把数据复制一份，而是直接持有 arr 数组的【引用地址】
    List<String> list = Arrays.asList(arr); 
    
    Collections.sort(list); 
    // 结果：原数组 arr 的内容也会被改变！变成 {"a", "b"}
    ```



- **`void sort(T[] a, Comparator<? super T> c)`**
  - **作用**：**自定义排序**
  - **说明**：当对象没有实现 Comparable，或者你想临时换一种排序规则（比如按“字符串长度”而不是“字典序”排）时使用
  - *这是实际开发中最常用的 API，将在后文详解*



#### 3. 实战代码示例

```java
import java.util.Arrays;

public class BasicSortDemo {
    public static void main(String[] args) {
        // --- 场景 1: 基本数据类型排序 (快排) ---
        int[] nums = {9, 5, 2, 7, 12};
        
        // 默认升序
        Arrays.sort(nums); 
        
        // 技巧：打印数组必须用 Arrays.toString，直接打印 nums 会输出内存地址
        System.out.println("基本类型升序: " + Arrays.toString(nums));
        // 输出: [2, 5, 7, 9, 12]


        // --- 场景 2: 对象类型自然排序 (TimSort) ---
        String[] names = {"Bob", "Alice", "Charlie"};
        
        // String 已经实现了 Comparable 接口 (按字典序)
        Arrays.sort(names);
        
        System.out.println("对象自然排序: " + Arrays.toString(names));
        // 输出: [Alice, Bob, Charlie]
        
        
        // --- 场景 3: 局部排序 ---
        int[] data = {9, 8, 7, 6, 5};
        
        // 只排索引 1 到 3 (即元素 8, 7)。注意：不包含索引 3
        Arrays.sort(data, 1, 3);
        
        // 预期结果: 9 不变, [7, 8] 交换, 6, 5 不变
        System.out.println("局部排序结果: " + Arrays.toString(data));
        // 输出: [9, 7, 8, 6, 5]
    }
}
```



### 02. `Comparable` 与 `Comparator`

#### 1. 核心痛点与架构思想

我们学习了 `Arrays.sort()`。对于 `int[]` 这种基本数据类型，计算机非常清楚 `1 < 2`。但是，对于 **对象** ，就比较复杂了

##### (1) 计算机的困惑

假设你有一个 `Student` 对象数组：

```java
Student s1 = new Student("Alice", 100分);
Student s2 = new Student("Bob", 80分);
```

如果你直接告诉计算机“请给这两个学生排序”，计算机是无法执行的。它会有很多疑问：

- 是按 **分数** 从高到低排？
- 还是按 **名字** 的字典序排？
- 亦或是按 **学号** 从小到大排？



Java 的设计哲学是：**“排序算法”与“比较规则”分离**

- **排序算法**（如 TimSort）：这是 JDK 提供的通用引擎，负责移动元素位置
- **比较规则**（`Comparable`/`Comparator`）：这是开发者必须提供的业务逻辑，负责告诉算法谁大谁小



##### (2) 常见的“运行时异常”

这是新手最容易踩的第一个坑。如果试图对一个 **没有实现任何比较接口** 的对象数组进行排序，编译器 **不会报错**（编译能通过），但在程序运行时会直接崩溃

**错误示范：**

```java
public class User { // ❌ 此时 User 只是一个普通类，没有实现 Comparable
    String name;
}

public static void main(String[] args) {
    User[] users = { new User("A"), new User("B") };
    
    // 💣 运行时崩溃！抛出 ClassCastException: User cannot be cast to Comparable
    Arrays.sort(users); 
}
```

**原因解析：** 

- `Arrays.sort(Object[])` 内部会尝试把数组中的元素强制转型为 `Comparable` 接口来调用 `compareTo` 方法

  如果你的类没实现这个接口，转型就会失败

**最佳实践：** 

- 在设计领域模型时，如果这个对象具有“天然的顺序”（比如日期 `Date`、数字 `Integer`、字符串 `String`），一定要让它实现 `Comparable` 接口

  否则，它就是“不可排序”的





#### 2. 概念对比：内排序与外排序

这两个接口的根本区别在于：**排序逻辑是定义在类的“内部”还是“外部”**

##### (1) `Comparable`：内部排序

- **定义方式**：直接让你的实体类（如 `Student`）实现 `Comparable` 接口
- **核心逻辑**：这是一种 **侵入式** 的设计。意味着这个类在设计之初，就确定了自己与其他对象比较的唯一标准
- **接口定义速览**： 它位于 `java.lang` 包，只有一个方法

  ```java
  public interface Comparable<T> {
      // 返回值：负数(小)、0(相等)、正数(大)
      // 语义：用【我 (this)】去和【对象 o】比
      public int compareTo(T o);
  }
  ```
- **专业术语**：**自然排序**
  - 例如：`Integer` 的自然排序是数值大小，`String` 的自然排序是字典序
  - 一旦实现，`Collections.sort(list)` 会默认调用该逻辑



##### (2) `Comparator`：外部排序

- **定义方式**：编写一个 **独立** 的类（或 Lambda 表达式）来实现 `Comparator` 接口
- **核心逻辑**：这是一种 **非侵入式** 的设计（策略模式）。不需要修改实体类的源码，而是把比较逻辑剥离出来，作为参数传递给排序方法
- **接口定义速览**： 它位于 `java.util` 包，是一个 **函数式接口**

  ```java
  @FunctionalInterface
  public interface Comparator<T> {
      // 返回值：负数(o1小)、0(相等)、正数(o1大)
      // 语义：我是第三方裁判，我来比较【选手 o1】和【选手 o2】
      int compare(T o1, T o2);
  
      // (Java 8 之后还包含了很多默认方法，如 reversed, thenComparing 等)
  }
  ```
- **专业术语**：**定制排序**
  - 它允许在不改变类本身的情况下，定义多种不同的排序规则（如按年龄排、按薪资排）



##### (3) 核心维度对比表

| 维度         | Comparable (内部)                               | Comparator (外部)                             |
| ------------ | ----------------------------------------------- | --------------------------------------------- |
| **所在包**   | `java.lang` (基础语义)                          | `java.util` (工具类)                          |
| **实现者**   | **实体类本身** (如 `Student`)                   | **第三方策略类** (如 `NameSorter`)            |
| **方法签名** | `int compareTo(T other)`*(自己 vs 别人)*        | `int compare(T o1, T o2)`*(对象1 vs 对象2)*   |
| **代码耦合** | **高耦合** : 排序逻辑与业务类绑定，修改需改源码 | **低耦合 **: 排序逻辑独立，符合“开闭原则”     |
| **数量限制** | **唯一** : 一个类只能有一种自然排序逻辑         | **无限** : 可以创建任意多个比较器应对不同场景 |



##### (4) 决策指南

在实际开发中，请遵循以下技术选型原则：

1. **优先检查标准库**：

   - 如果是 `String`、`Integer`、`Date` 等标准库类型，它们已经实现了 `Comparable`，直接用即可

2. **默认规则用 `Comparable`**：

   - 如果是你自己定义的领域对象（如 `User`），且它有一个 **公认的、固定的** 主排序规则（比如按数据库主键 ID 排序），建议实现 `Comparable`

     这设定了对象的“默认出场顺序”

3. **多变需求用 `Comparator`**：

   - **多视图排序**：后台管理列表需要按“注册时间”排，前端展示需要按“热度”排
   - **老旧代码维护**：你需要对一个第三方 Jar 包里的类进行排序，但你没有源码或不能修改源码
   - **处理 null 值**：使用 Comparator 可以方便地处理对象为 `null` 的情况（后续 API 章节会讲）





#### 3. 核心 API 契约

无论是 `Comparable.compareTo` 还是 `Comparator.compare`，它们都遵循同一套 **严苛的返回值契约**

- Java 排序框架 完全依赖这个返回值来决定元素的位置

##### (1) 返回值的铁律

方法签名返回的是 `int`，而不是 `boolean`。因为它需要表达三种状态：

| 返回值             | 含义                    | 排序结果                     |
| ------------------ | ----------------------- | ---------------------------- |
| **负整数** (如 -1) | **当前对象 < 比较对象** | 当前对象排在 **前面** (升序) |
| **零** (0)         | **当前对象 = 比较对象** | 相对位置取决于排序算法稳定性 |
| **正整数** (如 1)  | **当前对象 > 比较对象** | 当前对象排在 **后面** (升序) |

> 实际代码中 **严禁** 直接用减法，遇到极大值与极小值运算时会由正变负（溢出），使用 `Integer.compare(a, b)`最为稳妥
>
> - `Integer.compare` 内部直接使用逻辑运算符 `<` 和 `==`，不管数字多大或多小，逻辑判断永远是准确的，**绝对不会溢出**



##### (2) A：实现 `Comparable` (定义默认排序)

**场景**：你需要定义 `Student` 类，并规定：默认情况下，学生永远按照 **ID 从小到大** 排序

```java
public class Student implements Comparable<Student> {
    private int id;
    private String name;

    public Student(int id, String name) {
        this.id = id;
        this.name = name;
    }

    @Override
    public int compareTo(Student other) {
        // 核心逻辑：比较 this.id 和 other.id
        
        // ❌ 错误写法 (极度危险)：直接相减
        // return this.id - other.id; 
        // 风险：如果 this.id 是 20亿，other.id 是 -10亿，相减会溢出变成负数！
        
        // ✅ 正确写法：使用包装类的静态工具方法
        return Integer.compare(this.id, other.id);
    }
    
    // 省略 Getter/Setter/ToString
}

// 调用验证：
// Collections.sort(studentList); // 自动按 ID 升序
```



##### (3) B：使用 `Comparator` (定义定制排序)

**场景**：现在业务需求变了，需要按 **“名字长度”** 排序，名字越长的越靠前（降序）。我们不能修改 `Student` 类的源码，或者不想破坏原有的 ID 排序

```java
import java.util.Comparator;
import java.util.Arrays;

public class ComparatorDemo {
    public static void main(String[] args) {
        Student[] students = {
            new Student(1, "Bob"),
            new Student(2, "Alice"),
            new Student(3, "Eve")
        };

        // 1. 匿名内部类写法 (Java 7 风格，繁琐但便于理解)
        Arrays.sort(students, new Comparator<Student>() {
            @Override
            public int compare(Student o1, Student o2) {
                // 降序逻辑：o2(他) - o1(我)
                int len1 = o1.getName().length();
                int len2 = o2.getName().length();
                return Integer.compare(len2, len1); 
            }
        });

        // 2. Lambda 表达式写法 (Java 8+ 标准，推荐)
        // 语义：如果 o2 长度大，返回正数 -> o2 排前面
        Arrays.sort(students, (o1, o2) -> 
            Integer.compare(o2.getName().length(), o1.getName().length())
        );

        // 3. 现代流式写法 (Java 8+ 进阶，最优雅)
        // 语义：取出 name -> 取出 length -> 比较 -> 反转(reversed)
        Arrays.sort(students, Comparator
            .comparingInt((Student s) -> s.getName().length())
            .reversed()
        );
    }
}
```



##### (4) 避坑指南

- **🚫 坑点一：减法溢出**

  - **现象**：`return a - b;` 在绝大多数情况下正常，但遇到极大值与极小值运算时会由正变负（溢出）

  - **后果**：排序错乱，这种 Bug 极难复现

  - **铁律**：永远不要使用减法来比较整型，**必须使用 `Integer.compare(a, b)`**

    >`Integer.compare` 内部直接使用逻辑运算符 `<` 和 `==`，不管数字多大或多小，逻辑判断永远是准确的，**绝对不会溢出**

  

- **🚫 坑点二：违反传递性**

  - **现象**：你写的逻辑导致 `A > B`，`B > C`，但是 `A < C`
  - **后果**：Java 7 引入的 TimSort 对逻辑严谨性要求极高。如果检测到逻辑矛盾，会直接抛出 **`IllegalArgumentException: Comparison method violates its general contract!`** 导致系统崩溃
  - **对策**：在多条件判断时，确保逻辑分支覆盖全面，不要遗漏 `return 0` 的情况





## 2. 集合与现代排序

### 01. 集合排序

> 从 `Collections.sort` 到 `List.sort`

#### 1. 历史演进与核心痛点

在 Java 8 之前，`List` 接口本身是没有排序功能的

- 如果你想给一个 `ArrayList` 排序，必须借助于一个“外挂”工具类：`java.util.Collections`

  这其实不太符合面向对象思想（对象应该自己有能力对自己排序，而不是被别人拿去排）



**Java 8 的革命：** 随着 Java 8 引入了 **默认方法**，`List` 接口终于挺直了腰杆，增加了自己的 `sort()` 方法

- **旧时代 (Java 7及以前)**：`Collections.sort(list, comparator)`
- **新时代 (Java 8及以后)**：`list.sort(comparator)`



#### 2. 核心 API 对比

虽然现在推荐用新写法，但你必须两种都懂，因为维护老系统时避不开 `Collections.sort`

| 特性         | 传统写法 (`Collections`)                             | 现代写法 (`List` 接口)                |
| ------------ | ---------------------------------------------------- | ------------------------------------- |
| **方法签名** | `static void sort(List list, Comparator c)`          | `default void sort(Comparator c)`     |
| **调用方式** | `Collections.sort(myList, c)`                        | `myList.sort(c)`                      |
| **底层实现** | 内部其实调用的就是 `list.sort(c)` (Java 8后被重构过) | 直接调用 `Arrays.sort` 对底层数组排序 |
| **语义**     | "工具类，请帮我排这个列表"                           | "列表，请你自己排个序"                |
| **推荐度**   | ⭐⭐ (兼容旧代码)                                      | ⭐⭐⭐⭐⭐ (现代标准)                      |



#### 3. 实战代码示例

假设我们需要对一个 `User` 列表按 **年龄** 排序

```java
import java.util.*;

public class ListSortEvolution {
    public static void main(String[] args) {
        // 准备数据 (这是可变的 ArrayList)
        List<User> users = new ArrayList<>();
        users.add(new User("Alice", 30));
        users.add(new User("Bob", 20));

        // -------------------------------------------------------
        // 方式一：Java 7 之前的传统写法
        // -------------------------------------------------------
        // 必须引入 Collections 工具类
        Collections.sort(users, new Comparator<User>() {
            @Override
            public int compare(User u1, User u2) {
                return Integer.compare(u1.age, u2.age);
            }
        });

        // -------------------------------------------------------
        // 方式二：Java 8 List.sort + Lambda (Modern Way)
        // -------------------------------------------------------
        // 直接调用 list 自己的方法，语义更流畅
        users.sort((u1, u2) -> Integer.compare(u1.age, u2.age));

        // -------------------------------------------------------
        // 方式三：极致优雅 (Best Practice)
        // -------------------------------------------------------
        // 配合 Comparator 工具方法 (将在下一节详细拆解)
        users.sort(Comparator.comparingInt(u -> u.age));
        
        System.out.println(users);
    }

    static class User {
        String name;
        int age;
        // 构造器、toString 省略...
        User(String n, int a) { name = n; age = a; }
        public String toString() { return name + ":" + age; }
    }
}
```



#### 4. 避坑指南

- **🚫 巨坑一：试图对不可变列表排序**

  - **现象**：

    - 如果你使用 `List.of()` (Java 9+) 或 `Collections.unmodifiableList()` 创建列表，调用 `sort()` 时会直接抛出 **`UnsupportedOperationException`**

  - **原因**：排序必须交换元素位置（即调用 `set` 方法），而不可变列表禁止修改

  - **错误示范**：

    ```java
    List<String> list = List.of("B", "A"); // 不可变！
    list.sort(null); // 💣 运行时报错
    ```

  - **解决方案**：先复制一份，再排序

    ```java
    List<String> mutableList = new ArrayList<>(list);
    mutableList.sort(null); // ✅ 安全
    ```

  

- **🚫 坑点二：并发修改异常**

  - **现象**：如果在多线程环境下，一个线程在遍历 List，另一个线程在调用 `list.sort()`，可能会导致遍历线程崩溃

  - **对策**：

    - `ArrayList` 不是线程安全的

      如果需要并发排序，请使用 `CopyOnWriteArrayList` (但它不支持直接 sort，需要复制) 或者加锁 (`synchronized`)



- **❓ 常见疑问：`Arrays.asList` 能排吗？**

  - **答案**：**能！**

  - 虽然 `Arrays.asList` 不能 `add/remove`（长度固定），但它支持 `set` (修改元素)

    排序本质上就是不断地 `get` 和 `set` 交换位置，所以它是支持排序的



### 02. Java 8 Comparator 现代流式构建

Java 8 引入 Stream 和 Lambda 后，Comparator 的写法不再是写逻辑代码，而是 **“像说话一样声明规则”**



#### 1. 核心痛点：告别“匿名内部类地狱”

在 Java 8 之前，如果你要实现一个“多级排序”（比如：先按 **分数降序**，分数一样再按 **年龄升序**），代码会写得非常痛苦：

##### **🛑 噩梦般的旧写法 (Java 7)**

```java
Collections.sort(students, new Comparator<Student>() {
    @Override
    public int compare(Student s1, Student s2) {
        // 第一级：按分数降序
        int scoreCompare = Integer.compare(s2.getScore(), s1.getScore());
        if (scoreCompare != 0) {
            return scoreCompare;
        }
        // 第二级：按年龄升序
        return Integer.compare(s1.getAge(), s2.getAge());
    }
});
```

这种代码 **可读性极差** ，逻辑嵌套深，维护起来很容易出错



##### **✅ 现代写法 (Java 8+)**

```java
// 读起来像英语一样：
// "Sort by score (reversed), then by age"
students.sort(Comparator
    .comparingInt(Student::getScore)
    .reversed()
    .thenComparingInt(Student::getAge)
);
```



#### 2. 核心 API

- 所有方法均是 `java.util.Comparator` 接口的 **静态方法 (Static)** 或 **默认方法 (Default)**



- **核心思维：特征提取**：你不需要告诉 Java 怎么比两个 `Student`，你只需要告诉 Java **“比什么属性”**

  - 在 Java 8 之前，排序逻辑通常是 **命令式** 的：你需要手写两个对象如何进行计算、判断正负的完整过程

  - 而在 Java 8 之后，Comparator 转变为 **声明式** 风格：你只需要指定 **“用于排序的键”**



##### (1) 创建比较器

**作用**：用于开启一段比较逻辑，是链式调用的起点。返回值都是一个 `Comparator` 类型



###### a. 最常用的方法

| 方法签名                              | 适用场景                                                     | 代码示例 (以 User 类为例)                                    |
| ------------------------------------- | ------------------------------------------------------------ | ------------------------------------------------------------ |
| **`comparing(Function)`**             | **引用类型 (对象)**：适用于 String, Date 或实现了 `Comparable` 的自定义对象 | `Comparator.comparing(User::getName)`*(按名字字典序)*        |
| **`comparing(Function, Comparator)`** | **双参数 (自定义规则)**：适用于需要指定特殊排序规则（如忽略大小写）或对象未实现 `Comparable` | `Comparator.comparing(User::getName, String.CASE_INSENSITIVE_ORDER)`*(按名字忽略大小写)* |
| **`comparingInt(ToIntFunction)`**     | **int 原生类型**：适用于 age, id, score 等 int 字段          | `Comparator.comparingInt(User::getAge)`*(按数值大小)*        |
| **`comparingLong(...)`**              | **long 原生类型**：适用于 timestamp, fileLength 等           | `Comparator.comparingLong(User::getId)`                      |
| **`comparingDouble(...)`**            | **double 原生类型**：适用于 price, weight 等                 | `Comparator.comparingDouble(User::getPrice)`                 |



###### b. 单参数 `comparing()` 如何比较

- 当你调用 `Comparator.comparing(User::getName)` 时，底层逻辑如下：

  1. **提取**：比较器接收到两个 `User` 对象，应用你传入的函数 `User::getName`，提取出两个 **排序键**
  2. **代理**：比较器并不直接比较 `User` 对象，而是委托给提取出来的 **键** 进行比较

  

- **约束条件**： `comparing(Function keyExtractor)` 默认要求提取出的键必须实现 **`Comparable` 接口**

  - 如果提取出的属性（例如一个自定义的 `Department` 对象）没有实现 `Comparable`，编译器会报错，因为它不知道该如何排列这些对象
  - **解决方案**：使用重载版本 `comparing(keyExtractor, keyComparator)`，显式传入一个比较器来规定这个属性的顺序



###### c. 高阶：双参数版本 (定制比较规则) 

如果你提取出来的属性 **没有实现 `Comparable`**，或者你 **想改变默认规则**（比如忽略大小写、处理 Null），就需要使用 **双参数版本 `comparing()`**

> **语法**：`comparing(1. 提取器, 2. 比较器)` 
>
> **规则**：先提取，再按指定规则比

| 参数       | 说明                                                        |
| ---------- | ----------------------------------------------------------- |
| **参数 1** | 负责把属性提取出来 (如 `User::getName`)                     |
| **参数 2** | 负责比较提取出来的属性 (如 `String.CASE_INSENSITIVE_ORDER`) |

**实战场景**：

1. **忽略大小写排序**：

   ```java
   // 提取出名字，然后按“忽略大小写”的规则比
   Comparator.comparing(User::getName, String.CASE_INSENSITIVE_ORDER);
   ```

2. **处理属性为 Null 的情况 (最重要！)**：

   ```java
   // 提取出邮箱，如果邮箱是 null，把它排在最后
   Comparator.comparing(User::getEmail, Comparator.nullsLast(Comparator.naturalOrder()));
   ```



###### d. 特殊规则

| 方法签名             | 说明                                                         |
| -------------------- | ------------------------------------------------------------ |
| **`naturalOrder()`** | **自然顺序**：直接使用对象自身的 `compareTo` 规则。常用于 `List<String>` 或 `List<Integer>` |
| **`reverseOrder()`** | **自然逆序**：`naturalOrder()` 的反转版本                    |



###### e. 性能关键

在处理数值类型时，选择正确的方法至关重要，这直接影响系统的 GC（垃圾回收）压力。

**场景：按年龄 (int) 排序**

- ❌ 低效写法：`comparing`

  ```java
  // 编译通过，但性能不佳
  Comparator.comparing(User::getAge) 
  ```



- **问题分析**：
  - `User::getAge` 返回的是原生 `int`
  - 因为 `comparing` 接收的是泛型 `Function<T, R>`，泛型不支持原生类型
  - **自动装箱**：Java 必须把 `int` 封装成 `Integer` 堆对象才能传递
  - **性能损耗**：在大数据量排序时，会产生大量临时的 `Integer` 对象，导致内存占用飙升并触发频繁 GC



- **✅ 高效写法：`comparingInt`**

  ```java
  // 针对原生类型优化
  Comparator.comparingInt(User::getAge)
  ```

  

- **优化原理**：
  - 使用 `ToIntFunction` 接口，该接口专门设计用于处理 `int` 输入
  - 内部比较直接使用 CPU 指令对比数值，**零对象创建，零装箱开销**





##### (2) 组合拳：链式排序与反转

在实际业务中，往往需要多级排序（例如：先按分数排，分数一样按学号排）

- Java 8 通过 **链式调用** 完美解决了这个问题



###### a. 链式逻辑

当第一级比较器认为两个对象“相等”（即 `compare` 返回 0）时，链条才会继续向下执行。这类似于 SQL 中的 `ORDER BY Score, Age`

**核心方法：`thenComparing`**

| 方法签名                                  | 作用                                                         | 备注                                                         |
| ----------------------------------------- | ------------------------------------------------------------ | ------------------------------------------------------------ |
| **`thenComparing(Function)`**             | **追加二级排序**:当前一级比较结果为相等时，使用此规则        | 适用于对象引用类型                                           |
| **`thenComparing(Function, Comparator)`** | **追加自定义排序**:指定**特殊的比较器**来处理提取出的属性(可参考之前的双参数`comparing()`) | **🔥 灵活王**。可指定规则（如忽略大小写）;**不强制**属性实现 `Comparable` |
| **`thenComparingInt(ToIntFunction)`**     | **追加 int 排序**                                            | **强烈推荐**。同 `comparingInt`，避免二级排序时的装箱开销    |
| **`thenComparingLong(...)`**              | **追加 long 排序**                                           | 同上                                                         |
| **`thenComparingDouble(...)`**            | **追加 double 排序**                                         | 同上                                                         |



**代码示例**

```java
Comparator<Student> comparator = Comparator
    // [一级] 主关键字：先按分数降序
    .comparingInt(Student::getScore).reversed()
    
    // [二级] 次关键字：分数一样时，按 ID 升序 (使用性能优化版)
    .thenComparingLong(Student::getId)
    
    // [三级] 再次关键字：如果连 ID 都撞了（假设情况），按名字排序
    // 这里演示【双参数版本】：指定 String.CASE_INSENSITIVE_ORDER 忽略大小写
    .thenComparing(Student::getName, String.CASE_INSENSITIVE_ORDER);
```



###### b. 逻辑反转

`reversed()` 是一个修饰符，用于反转排序顺序

- **关键痛点**：它到底反转了谁？是反转了整个链条，还是只反转了上一行？



###### c. 核心规则：逆序快照

`reversed()` 会对 **调用它之前生成的所有比较逻辑** 进行整体取反

> 就是把前面的结果直接倒过来

- 注意：`reversed()` 改变的是 **逻辑（Comparator）**，而不是 **结果（Stream/List）**。 它是 **预处理**，不是**后处理**。

  它并不是把所有的元素拿到，之后重新排序一次，之后返回，而是直接取反之前的逻辑



**模式 A：局部反转 (常见需求)**

- **需求**：分数 **降序** (高分在前)，如果分数一样，ID **升序** (小号在前)

  ```java
  Comparator<Student> c = Comparator
      .comparingInt(Student::getScore)
      .reversed()                           // <--- 1. 只反转了“按分数排序”这一步
      .thenComparingLong(Student::getId);   // <--- 2. ID 排序逻辑是后续追加的，不受 reversed 影响
  ```

  

- **执行流程**：
  1. `(A, B)` -> 比较分数 -> 拿到结果 `X`
  2. `reversed()` -> 将结果 `X` 取反 (变 `-X`)
  3. 如果结果非 0，直接返回
  4. 如果结果为 0 (分数相等)，**继续执行** `thenComparingLong(ID)` (默认升序)



**模式 B：全局反转**

- **需求**：先按分数升序，再按 ID 升序，**最后把整个列表完全倒过来**

  ```java
  Comparator<Student> c = Comparator
      .comparingInt(Student::getScore)
      .thenComparingLong(Student::getId)
      .reversed();                          // <--- 这里的 reversed 作用于 (分数+ID) 的整体组合
  ```



- **执行流程**：

  1. 比较分数
  2. 分数相等则比较 ID
  3. 拿到最终综合结果 `Y`
  4. `reversed()` -> 将最终结果 `Y` 取反

  

- **实际效果**：分数变成了降序，**且** ID 也变成了降序



###### d. 最佳实践

为了避免逻辑混乱，建议遵循 **“一步一处理”** 的书写习惯，尽量让 `reversed()` 紧跟在它需要反转的那个属性后面



**推荐模板：**

```java
list.sort(Comparator
    // 第一级：优先级 (降序) -> 既然是降序，马上跟 reversed
    .comparingInt(Task::getPriority).reversed()
    
    // 第二级：截止日期 (升序) -> 默认自然序，不需要修饰
    .thenComparing(Task::getDeadline)
    
    // 第三级：创建人ID (升序) -> 使用特化方法优化性能
    .thenComparingLong(Task::getCreatorId)
);
```



**自测题**： 如果写成 `comparing(...).thenComparing(...).reversed()`，那么 `thenComparing` 指定的属性是升序还是降序？

- **答案**：降序。因为 `reversed` 在最后，它反转了前面所有的逻辑



##### (3) Null 值处理

###### a. 痛苦：`NullPointerException`

默认情况下，`Comparator` 是非常脆弱的

- 如果你提取的属性是 `null` (比如 `getName()` 返回 null) -> **崩**
- 如果你比较的对象本身是 `null` -> **崩**

为了解决这个问题，Java 8 引入了两个 **装饰器**，专门用来处理“空值”



###### b. `nullsFirst` 与 `nullsLast`

这两个方法包裹住你原来的规则，专门负责拦截 `null`

| 方法签名 (完整版)                       | 描述                                                         |
| --------------------------------------- | ------------------------------------------------------------ |
| **`nullsFirst(Comparator comparator)`** | **Null 排最前**。遇到 `null` 认为最小，其余非 `null` 元素按传入的 `comparator` 规则排 |
| **`nullsLast(Comparator comparator)`**  | **Null 排最后**。遇到 `null` 认为最大，其余非 `null` 元素按传入的 `comparator` 规则排 |



###### c. 关键区分：“行”空还是“列”空

**场景 A：列表里的元素本身是 Null (行空)**

- 比如 `List<User>` 里面混入了几个 `null` 对象

  ```JAVA
  // 保护整个比较器
  users.sort(
      Comparator.nullsLast(             // <--- 最外层包围
          Comparator.comparing(User::getName)
      )
  );
  // 结果：[Alice, Bob, null]
  ```

  



**场景 B：元素的属性是 Null (列空) —— 最常见**

- User 对象都在，但有的人没有填 `email` (email 为 null)。 此时，我们需要把 Null 规则 **塞进** `comparing` 的第二个参数里

  ```JAVA
  // 语法：comparing(提取器, 比较规则)
  Comparator.comparing(
      User::getEmail, 
      Comparator.nullsLast(Comparator.naturalOrder()) // <--- 指定“怎么比这个属性”
  )
  // 结果：[a@test.com, b@test.com, null] (没有邮箱的排最后)
  ```

  



#### 3. 实战代码示例

假设我们有一个电商场景的 `Product` 类：

```java
class Product {
    String name;
    int price;    // 价格
    int sales;    // 销量
    // ...
}
```



**场景 A：基础组合排序**

- 需求：先按 **销量从高到低**（卖得好的在前），销量一样按 **价格从低到高**（便宜的在前）

```java
products.sort(Comparator
    .comparingInt(Product::getSales).reversed() // 第一梯队：销量降序
    .thenComparingInt(Product::getPrice)        // 第二梯队：价格升序
);
```



**场景 B：处理 Null 值**

- 需求：按 `name` 排序，如果 `name` 是 null，把它放到最后面，不要报空指针异常

```java
// 包装器写法：nullsLast 包裹住了“按名字比”这个逻辑
products.sort(Comparator.nullsLast(
    Comparator.comparing(Product::getName)
));
```

#### 4. 避坑指南

- **🚫 巨坑一：装箱性能损耗**

  - **现象**：`Comparator.comparing(User::getAge)`

  - **问题**：

    - 如果 `age` 是 `int` 基本类型，`comparing` 接受的是 `Function<T, U>`，它会强制把 `int` 自动装箱成 `Integer` 对象

      在百万级数据排序时，这会产生海量的垃圾对象，导致 GC 压力剧增

  - **修正**：**必须使用 `comparingInt`**。它接受 `ToIntFunction`，直接操作 `int`，零装箱

  

- **🚫 坑点二：reversed() 的作用域**

  - **误区**：有人以为 `reversed()` 会反转整个链条

  - **真相**：`reversed()` 只反转 **调用它的那个时刻之前** 的比较器

  - **示例**：

    ```java
    // 逻辑：(按销量排).reversed() -> 销量降序
    // 然后再：thenComparing(按价格) -> 价格依然是默认升序
    comparingInt(Product::getSales).reversed().thenComparingInt(Product::getPrice)
    ```

    如果你想让价格也降序，必须在价格后面也加 reversed： `thenComparing(..., Comparator.reverseOrder())`

  

- **🚫 坑点三：IDE 的类型推断提示**

  - **现象**：有时候写 `comparing(User::getName)` 编译器会报错 `Cannot resolve method...`
  - **原因**：Java 的类型推断在某些复杂链式调用下会失效
  - **解决**：显式指定类型。 `Comparator.<User, String>comparing(User::getName)` (虽然丑，但管用)





## 3. 流、映射与结构

### 01. Stream 流式排序与 Map 排序

#### 1. 核心场景

在 Java 8 引入 Stream API 后，排序不再仅仅是一个独立的步骤，它变成了 **数据处理流水线** 中的一个环节

- 我们经常遇到这样的需求：从数据库查出一堆数据 -> 过滤掉无效的 -> **排序** -> 提取前 10 个 -> 转换成 DTO
  - 标准的 `HashMap` 是无序的，想要给 Map 排序，通常需要借助 Stream 流将其“展平”处理



#### 2. Stream 流式排序 (`Stream.sorted`)

Stream 提供了两个中间操作方法用于排序。注意，它们不会改变原集合，而是返回一个新的排好序的 Stream

| 方法                       | 描述                                              | 示例                                                   |
| -------------------------- | ------------------------------------------------- | ------------------------------------------------------ |
| **`sorted()`**             | **自然排序**。要求提取的元素必须实现 `Comparable` | `stream.sorted()`                                      |
| **`sorted(Comparator c)`** | **定制排序**。使用传入的比较器                    | `stream.sorted(Comparator.comparingInt(User::getAge))` |



**实战示例：找出薪资最高的前 3 名员工**

```java
List<Employee> top3 = employees.stream()
    .filter(e -> e.getSalary() > 0)        // 1. 过滤
    .sorted(Comparator.comparingInt(Employee::getSalary).reversed()) // 2. 排序 (降序)
    .limit(3)                              // 3. 截取
    .collect(Collectors.toList());         // 4. 收集
```



#### 3. Map 排序：最棘手的场景

HashMap 本身是 **无序** 的。如果你想让 Map 有序，通常有两种策略：

1. **按 Key 排序**：使用 `TreeMap`
2. **按 Value 排序**：这是最麻烦的（例如：按“销量”给“商品Map”排序）



##### (1) A：使用 TreeMap (自动按 Key 排序)

如果你只需要让 Map 里的 Key 有序（比如按日期 Key 排列日志），直接换容器即可

```java
// 这里的 Key (String) 会自动按字典序排列
Map<String, Integer> scores = new TreeMap<>();
scores.put("Bob", 80);
scores.put("Alice", 90);
// 遍历时输出顺序保证为: Alice=90, Bob=80
```



##### (2) B：使用 Stream 按 Value 排序

**场景**：你有一个 Map `<商品名, 销量>`，你想按 **销量** 从高到低排序

```java
Map<String, Integer> salesMap = new HashMap<>();
salesMap.put("Apple", 500);
salesMap.put("Banana", 200);
salesMap.put("Orange", 800);

// 核心逻辑：Map -> EntrySet -> Stream -> Sort -> LinkedHashMap
Map<String, Integer> sortedMap = salesMap.entrySet().stream()
    // 1. 按 Value (销量) 倒序
    .sorted(Map.Entry.<String, Integer>comparingByValue().reversed())
    // 2. 收集回 Map
    .collect(Collectors.toMap(
        Map.Entry::getKey,
        Map.Entry::getValue,
        (oldVal, newVal) -> oldVal, // Merge Function (用不到，但为了调用下面的 mapSupplier)
        LinkedHashMap::new          // ⚠️ 关键！必须用 LinkedHashMap 才能保留排序结果
    ));

// 结果: Orange=800, Apple=500, Banana=200
```



#### 4. 避坑指南

- **🚫 巨坑一：收集到 HashMap 导致白忙一场**

  - **现象**：在 Stream 里费劲排好了序，最后 `.collect(Collectors.toMap(...))`
  - **问题**：`Collectors.toMap` 默认返回 `HashMap`，它是无序的！你排好的顺序放进去瞬间就乱了
  - **解决**：必须显式指定使用 **`LinkedHashMap::new`**（如上例所示），它能保留插入顺序

  

- **🚫 坑点二：OOM 风险 (内存溢出)**

  - **现象**：对海量数据（如 1000 万行）进行 `sorted()`
  - **原理**：`sorted()` 是一个 **有状态** 的操作。它必须把流里的所有数据都读进内存，排好序，才能吐出第一个元素
  - **对策**：如果数据量极大，不要在应用层用 Stream 排序，**请在数据库层用 SQL (`ORDER BY`) 排好** 再查出来

  

- **🚫 坑点三：Map.Entry.comparing... 编译报错**

  - **现象**：`sorted(Map.Entry.comparingByValue())` 报类型错误
  - **原因**：Java 泛型推断有时会失灵
  - **解决**：加显式泛型 `<String, Integer>`，即 `Map.Entry.<String, Integer>comparingByValue()`



### 02. 自动排序的数据结构

#### 1. 核心场景

在前面的章节中，排序都是 **“一次性”** 的动作（调用 `sort` 方法）。但在某些场景下，我们需要数据**“实时有序”**：

- **实时排行榜**：不断有新分数进来，需要随时查看前 10 名
- **任务调度**：任务源源不断地来，每次都要立刻取出优先级最高的那一个执行
- **去重且有序**：既不能有重复元素，又要保持顺序

Java 提供了三种核心数据结构来解决这些问题

#### 2. 红黑树双雄：TreeSet 与 TreeMap

这两个类底层基于 **红黑树** 实现。它们的特点是：**每插入一个元素，都会自动把它放到正确的排序位置上**

- **`TreeSet`**：有序的 Set（去重）
- **`TreeMap`**：有序的 Map（按 Key 排序）



**如何指定排序规则？**

1. **构造器传参**：`new TreeSet<>(Comparator)`（推荐）
2. **自然排序**：如果不传 Comparator，则要求元素必须实现 `Comparable` 接口



**实战示例：不区分大小写的字符串排序集合**

```java
// 使用自定义 Comparator：忽略大小写排序
Set<String> sortedSet = new TreeSet<>(String.CASE_INSENSITIVE_ORDER);

sortedSet.add("banana");
sortedSet.add("Apple");
sortedSet.add("cherry");

// 自动排序结果: [Apple, banana, cherry]
System.out.println(sortedSet);
```



#### 3. 优先级队列:`PriorityQueue`(Top K 神器)

`PriorityQueue` (PQ) 是基于 **堆 (Heap)** 实现的

- 它和 `TreeSet` 的核心区别在于：`TreeSet` 保证 **所有** 元素都是有序的；而 `PriorityQueue` 只承诺 **堆顶（队头）** 是最小（或最大）的元素

- **性能对比**：
  - `TreeSet`：插入/查找都是 $O(\log n)$
  - `PriorityQueue`：插入 $O(\log n)$，但获取最值是 $O(1)$，效率极高
- **适用场景**：不需要所有数据都有序，只需要**“时刻能拿到某一项指标最突出的那个”**（如：Top K 问题、任务调度）



**实战示例：找出输入流中最大的 K 个数 (Top K)**

```JAVA
// 需求：保留最大的 3 个元素
// 技巧：使用【小顶堆】。如果堆满了，新来的元素比堆顶大，就把堆顶踢走。
PriorityQueue<Integer> minHeap = new PriorityQueue<>();

int[] stream = {10, 5, 20, 3, 100, 50};
int K = 3;

for (int num : stream) {
    minHeap.add(num);
    // 如果超过 K 个，移除最小的那个（堆顶）
    if (minHeap.size() > K) {
        minHeap.poll(); 
    }
}

// 结果: [20, 50, 100] (注意：PQ 的 iterator 输出不保证顺序，必须 poll 出来才有序)
while (!minHeap.isEmpty()) {
    System.out.println(minHeap.poll());
}
```



#### 4. 避坑指南

- **🚫 巨坑一：不要在 TreeSet 中修改参与排序的字段**

  - **现象**：你把一个 `Student(id=1)` 放进了 `TreeSet`，然后你在外面偷偷改了 `student.setId(99)`
  - **后果**：红黑树不会自动感知这个修改！这会导致红黑树的结构损坏，你可能再也**删不掉、找不到**这个元素了，甚至导致后续操作死循环或报错
  - **原则**：放入 Set/Map Key 的对象，最好是**不可变对象 (Immutable)**

  

- **🚫 坑点二：PriorityQueue 的遍历陷阱**

  - **现象**：`System.out.println(pq)` 或者 `for (int i : pq)`
  - **真相**：`PriorityQueue` 的 `toString()` 或迭代器**不保证**输出有序！它只是打印底层数组的存储结构
  - **解决**：如果想按顺序看，必须用 `while (!pq.isEmpty()) { pq.poll(); }` 一个个取出来

  

- **🚫 坑点三：TreeSet 判断“重复”的标准**

  - **现象**：`HashSet` 靠 `hashCode()` 和 `equals()` 判断重复；但 `TreeSet` **只靠 `compareTo()` 或 `Comparator`**
  - **后果**：如果 `compare(a, b) == 0`，`TreeSet` 就认为它们是同一个元素，直接**拒收**（即使 `equals` 返回 false）。这可能导致你莫名其妙丢失数据



## 4. 生产避坑与最佳实践

### A. 噩梦级异常：Contract Violation

这是 Java 排序中最著名、也最隐蔽的生产事故

**现象**：代码运行了好几年都没事，突然有一天数据量变大或出现特殊数据，程序直接崩溃，

- 抛出 `IllegalArgumentException: Comparison method violates its general contract!`



**根本原因**：你写的 `Comparator` 逻辑自相矛盾，违反了**传递性**

- 即：`A > B` 且 `B > C`，但你的逻辑却判出了 `A < C`
- **TimSort** 算法极其严谨，一旦它在排序过程中发现这种逻辑矛盾，为了防止死循环或数据错乱，它会选择直接报错停止



**🚫 错误示范 (复杂的业务逻辑)：**

```java
// 错误逻辑：我想把“非VIP”排后面，VIP按分数排
// 但如果两个都是非 VIP 呢？这里漏掉了 return 0 的情况！
compare(User u1, User u2) {
    if (u1.isVip() && !u2.isVip()) return -1;
    if (!u1.isVip() && u2.isVip()) return 1;
    // 💣 漏判：如果 u1 和 u2 都不是 VIP，这里会直接往下走去比分数
    // 这种逻辑分支缺失极易导致传递性失效
    return Integer.compare(u1.score, u2.score); 
}
```



**✅ 修复方案：**

1. **逻辑完备**：确保所有分支（大于、小于、等于）都被覆盖
2. **使用链式构建**：用 Java 8 的 `Comparator.comparing(...).thenComparing(...)` 代替手写的 `if-else`，因为官方的 API 逻辑是绝对严谨的



### B. 性能审查清单

在 Code Review 同事的代码时，请检查以下几点：

- **并没有对 `LinkedList` 进行排序**
  - `Collections.sort(linkedList)` 极其慢。因为它需要把链表转成数组，排完序再复制回去
  - **建议**：如果需要频繁排序，请直接用 `ArrayList`
- **并没有对 `int/long` 字段使用装箱比较器**
  - ❌ `Comparator.comparing(User::getAge)` (会有 `Integer` 垃圾产生)
  - ✅ `Comparator.comparingInt(User::getAge)` (零 GC)
- **大数据量排序是否前置到了数据库**
  - Java 内存排序通常快不过数据库索引。如果数据量超过 1 万条，优先考虑 SQL `ORDER BY`，而不是查出来用 Java `stream().sorted()`



### C. Null 安全策略

永远假设你的数据里会有 `null`

- **数据库层**：如果字段定义为 `DEFAULT NULL`，那么 Java 对象里的字段就可能是 null
- **代码层**：
  - ❌ `(u1, u2) -> u1.getName().length() - ...` (如果 name 是 null 直接空指针)
  - ✅ `Comparator.comparing(User::getName, Comparator.nullsLast(String::compareTo))`
  - **技巧**：如果你用 `comparing(User::getName)`，若 Name 可能为 null，必须在内层再包一个 `nullsLast`



### D. 排序技术选型决策树

面对一个排序需求，该用哪个类？请查阅此图：

```
开始
 │
 ├─ 需要实时有序/TopK?
 │   ├─ 是 -> [PriorityQueue] (只要最值) 或 [TreeSet] (全量有序)
 │   └─ 否 (一次性排序) -> 往下走
 │
 ├─ 数据源是什么?
 │   ├─ 数组 (Array) -> [Arrays.sort]
 │   ├─ 列表 (List)  -> [list.sort] (Java 8+)
 │   └─ 键值对 (Map) -> [Stream sorted] -> [LinkedHashMap]
 │
 └─ 比较规则?
     ├─ 只有一种固定的规则 -> 实现 [Comparable] 接口 (compareTo)
     └─ 规则多变/临时 -> 使用 [Comparator] (comparingInt...)
```

