# 注解

## 相关概念

- Java 注解是在 Java SE 5.0 版本中引入的一个重要特性。它是一种**元数据 (Metadata)**，可以附加到 Java 代码的各个元素上，如类、方法、字段、参数等。
- 写给**“编译器”或“程序”看的**，**描述代码的元信息**，告诉它们**如何处理这段代码**
  - **注解本身不直接影响代码的执行逻辑**，但**它可以被编译器、框架或工具读取和处理**，从而在**编译时、加载时或运行时实现特定的功能**。它的**标志性语法是 `@` 符号**，**后面跟着注解的名称**



## Java内置的注解

### 用于编译器的一些注解

- 主要用于给编译器提供信息，帮助进行**静态检查**

- **`@Override`**

  - **作用**：检查该方法是否是**重写（覆盖）了父类或接口中的方法**

  - **好处**：**提供编译时安全，防止因拼写错误等原因导致重写失败**

- **`@Deprecated`**

  - **作用**：**表示某个程序元素（类、方法等）已过时**，**不推荐再使用**。

  - **效果**：**编译器在遇到使用被此注解标记的代码时会发出警告**。它通常与 Javadoc 中的 **`@deprecated` 标签**一起使用，以说明为什么过时以及应该用什么替代

  - 示例

    ```java
    /**
     * @deprecated 这个方法已经过时了，请使用 newMethod() 代替。
     */
    @Deprecated
    public void oldMethod() {
        // ...
    }
    ```

- **`@SuppressWarnings`**

  - **作用**：**抑制编译器产生特定的警告信息**。

  - **例子**：**`@SuppressWarnings("unchecked")`** 用于抑制因为泛型类型转换而产生的警告

  - 示例

    ```java
    @SuppressWarnings("unchecked")
    public void someLegacyMethod() {
        java.util.List wordList = new java.util.ArrayList();
        wordList.add("hello"); // 这里会产生 "unchecked" 警告，但被抑制了
    }
    ```



### 元注解

- 元注解是**“用来注解其他注解”的注解**，它们**定义了自定义注解的行为**
- **`@Target`**
  - **作用**：**指定你的注解可以被应用在哪些类型的程序元素上**。
  - **取值**：`ElementType` 枚举，例如：
    - `ElementType.TYPE`：类、接口、枚举
    - `ElementType.FIELD`：字段（成员变量）
    - `ElementType.METHOD`：方法
    - `ElementType.PARAMETER`：方法参数
    - `ElementType.CONSTRUCTOR`：构造函数
    - `ElementType.LOCAL_VARIABLE`：局部变量
- **`@Retention`**
  - **作用**：指定注解的生命周期，即它在什么级别上保留。这是最重要的元注解之一。
  - **取值**：`RetentionPolicy` 枚举：
    - `RetentionPolicy.SOURCE`：注解只保留在源代码文件中，编译后被丢弃（例如 `@SuppressWarnings`）。常用于代码分析或生成。
    - `RetentionPolicy.CLASS`：注解被保留到 `.class` 文件中，但在 JVM 运行时不可见。这是默认值。
    - `RetentionPolicy.RUNTIME`：注解被保留到 `.class` 文件中，并且在 JVM 运行时可以通过**反射 (Reflection)** 读取。这是最常用的策略，像 Spring、JUnit 等框架大量使用。
- **`@Documented`**
  - **作用**：如果一个注解被 `@Documented` 标记，那么在使用这个注解的类的 Javadoc 中，会包含该注解的信息。
- **`@Inherited`**
  - **作用**：允许子类继承父类上的注解。如果一个类使用了被 `@Inherited` 标记的注解，那么它的所有子类也会自动拥有这个注解。



### 其它注解

- **`@FunctionalInterface`** (Java 8+)
  - **作用**：表示一个接口是“函数式接口”，即该接口只包含一个抽象方法。
  - **好处**：如果一个接口被此注解标记，但它包含了多个抽象方法或没有抽象方法，编译器会报错。它主要用于配合 Lambda 表达式使用



## 自定义注解

### 相关概念

- 虽然 Java **内置了 `@Override`、`@Deprecated` 等注解**，但它们的**功能是固定的**。在实际开发中，我们常常需要：
  - **创建标记 (Markers)**：为一个类或方法打上一个特殊的“标签”，以便在后续流程中识别它们。例如，标记某个方法是“需要权限校验的”。
  - **携带元数据 (Metadata)**：将配置信息直接附加到代码上，而不是写在外部的 XML 或 properties 文件中。例如，为一个 API 方法附加它的 URL 路径、请求方法等信息。
  - **编译时生成代码 (Code Generation)**：为特定代码（如数据类）自动生成大量样板代码（如 `getters`, `setters`, `toString`），以简化开发。

- **自定义注解就是为了满足这些需求而生的**

- 如果一个注解元素没有使用 **`default`** 关键字**指定默认值**，那么它就是必需的（Required）。在使用该注解时，必须在括号 **`()`** 中为这个元素显式地赋值。



### 语法规则

- 创建一个注解使用 **`@interface` 关键字**。一个完整的自定义注解定义通常包含四个部分：
  1. **`@interface` 声明**：这是定义注解的关键字
  2. **元注解 (Meta-Annotations)**：用于配置注解自身行为的注解，最重要的是 **`@Retention`** 和 **`@Target`**
  3. **元素 (Elements)**：注解的参数，用于携带数据
  4. **默认值 (Default Values)**：为元素提供默认值，使其变为可选





#### 定义注解语法模板

```java
import java.lang.annotation.*;

// 为了在注解中使用枚举，我们先定义一个
enum HttpMethod {
    GET, POST, PUT, DELETE
}

/**
 * [元注解] - 用于配置注解本身
 */
@Retention(RetentionPolicy.RUNTIME)                 // 1. 指定生命周期为“运行时”
@Target({ElementType.METHOD, ElementType.TYPE})   // 2. 指定可以修饰“方法”和“类”
@Documented                                         // 3. (可选) 将此注解包含到 Javadoc 中
@Inherited                                          // 4. (可选) 允许子类继承

/**
 * [注解声明] - 使用 @interface 关键字
 * 这是一个用于描述API信息的自定义注解
 */
public @interface ApiDoc {

    /**
     * [元素声明] - 格式: 类型 元素名();
     */

    // 1. 特殊元素 value - 只有一个参数且名为value时，使用可简写
    String value();

    // 2. 带默认值的元素 (变为可选项)
    HttpMethod method() default HttpMethod.GET;
    int timeout() default 5000;

    // 3. 数组类型的元素
    String[] tags() default {}; // 默认值是一个空数组

    // 4. Class 类型的元素
    Class<?> response() default Void.class; // Void.class 表示无返回值
}
```

#### 使用注解语法模板

```java
// 示例1：只使用必需的 value 元素，并采用简写形式
@ApiDoc("/users/list")
public class UserController {

    // 示例2：提供所有元素的值，覆盖默认值
    @ApiDoc(
        value = "/users/create",
        method = HttpMethod.POST,
        timeout = 10000,
        tags = {"user", "creation"},
        response = User.class
    )
    public User createUser(String name) {
        // ...
        return new User();
    }

    // 示例3：数组元素只有一个值时的简写
    @ApiDoc(value = "/users/delete", tags = "user") // 等同于 tags = {"user"}
    public void deleteUser(int id) {
        // ...
    }
}
```



#### 示例

##### 定义自定义注解

```java
// 1. 使用元注解定义注解的行为
@Retention(RetentionPolicy.RUNTIME) // 让注解在运行时可用
@Target(ElementType.METHOD)         // 让注解只能用于方法上
public @interface ApiInfo {

    // 2. 定义注解的元素
    String value(); // 一个名为 "value" 的字符串元素

    String author() default "Unknown"; // 一个有默认值的 "author" 元素

    int version() default 1; // 一个有默认值的 "version" 元素
}
```

##### 使用自定义注解

```java
class UserController {

    @ApiInfo(value = "获取用户信息", author = "Alice", version = 2)
    public void getUserInfo(String userId) {
        // ... 业务逻辑 ...
    }

    @ApiInfo("获取所有用户") // 如果注解中只有一个名为 "value" 的元素，可以省略 "value="
    public void getAllUsers() {
        // ... 业务逻辑 ...
    }
}
```



## 注解的底层

- **注解的底层本质**：它是一种特殊的 **接口 (Interface)**，并不神秘

- 你定义了一个注解，生成了一个**`.class`**文件，这个文件的本质上是一个**继承了 `java.lang.annotation.Annotation` 接口的接口**

  - 例子

    当你定义一个注解时，例如：

    ```java
    public @interface MyAnnotation {
        String value();
        int count() default 1;
    }
    ```

    在编译器编译后，生成的 **`MyAnnotation.class`** 文件，其本质上是一个**继承了 `java.lang.annotation.Annotation` 接口的接口**，类似于

    ```java
    // 这是编译器在“幕后”为你生成的，你不需要手动写
    public interface MyAnnotation extends java.lang.annotation.Annotation {
        // 你定义的每个元素，都变成了这个接口里的一个抽象方法
        public abstract String value();
        public abstract int count();
    }
    ```

    - 注意点

      - **继承 `Annotation` 接口**：这是它和普通接口的根本区别，这个“标记”告诉 JVM 和其他工具，这不是一个普通的接口，而是一个注解。

        **元素变为方法**：注解中定义的每一个元素（参数），都变成了这个新接口里的一个抽象方法。方法名就是元素名，返回类型就是元素的类型。

        **我们使用的注解是什么**：当你在代码中使用 **`@MyAnnotation(value="test")`** 时，在运行时，JVM 会通过动态代理技术创建一个 **`MyAnnotation` 接口的实现类实例**。你可以**通过反射获取到这个实例**，然后**调用它的 `value()` 或 `count()` 方法**，**就能得到你赋的值（"test" 和 1）**



## 如何处理注解

### 编译时处理

- **机制**：通过实现 **`javax.annotation.processing.Processor` 接口**来创建**注解处理器**。
- **过程**：在 **`javac`** 编译代码时，注解处理器会被激活。它可以扫描源代码中指定的注解，并根据这些注解生成额外的源文件（如 **`.java`** 文件）、配置文件、文档等。
- **生命周期**：**`RetentionPolicy.SOURCE`**
- **著名案例**：
  - **Lombok**：通过 **`@Getter`, `@Setter`, `@Data`** 等注解，在编译时自动生成 getter/setter、构造函数等样板代码，极大简化了代码
  - **Dagger/Hilt**：用于依赖注入，在编译时生成依赖注入所需的代码，提高了运行效率。



### 运行时处理

- **机制**：利用 Java 的**反射 (Reflection) API**

- **过程**：在程序运行时，可以**通过反射获取类、方法、字段等对象**，然后调用 **`getAnnotation()`** 或 **`getAnnotations()`** 方法来检查它们上面是否存在某个注解，并读取注解元素的值，从而执行相应的逻辑

- **生命周期**：必须是 **`RetentionPolicy.RUNTIME`**

- **著名案例**：

  - **Spring**：启动时扫描所有类，如果发现一个类上有 `@Component` 注解，就通过反射创建这个类的实例，并放入 IoC 容器中管理。

    **JUnit**：在执行测试时，会扫描测试类，找到所有被 `@Test` 注解标记的方法，然后通过反射逐个调用它们来完成测试。

    **Jackson**：在序列化对象时，会检查字段上的 `@JsonProperty("user_name")` 注解，然后将该字段序列化为 JSON 中的 `user_name` 键

- 示例

  - 源代码：您在代码里写下了注解和它的数据

    ```java
    public class MyService {
        @MyAnnotation(value = "这是一个服务") // <-- 数据在这里被指定
        public void doWork() {}
    }
    ```

  - 字节码：`javac` 编译器在编译时，会读取 `@MyAnnotation(value = "这是一个服务")` 这部分信息，然后把它们作为**元数据**，原封不动地**写入到 `MyService.class` 文件中**。（前提是注解的 `@Retention` 策略是 `RUNTIME`）。 现在，`"这是一个服务"` 这个字符串，已经成为了 `MyService.class` 文件的一部分，就像一个永久的标签。

  - JVM内存：当您的程序运行时，JVM 会加载 `MyService.class`，连同它身上的注解元数据，一起加载到内存里。

  - 反射：

    ```java
    Method method = MyService.class.getMethod("doWork");
    MyAnnotation annotationObject = method.getAnnotation(MyAnnotation.class);
    ```

    - 您其实是在对 JVM 说：“请把 `doWork` 方法上贴的那个 `MyAnnotation` 标签给我”。 此时，JVM 会：
      - 在内部使用**动态代理**技术，动态地创建一个实现了 `MyAnnotation` 接口的匿名对象。
      - **最关键的一步**：JVM 会从内存中（也就是从 `.class` 文件加载来的元数据）找到 `value` 元素的值是 `"这是一个服务"`。
      - 然后，它将这个值“绑定”到它刚创建的那个代理对象的 `value()` 方法上。
      - 最后，JVM 把这个**已经填充好数据的代理对象** (`annotationObject`) 返回给您。