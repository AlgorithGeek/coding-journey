# 网络编程

## 概念以及一些知识点

- **网络编程就是编写程序，让两台或多台计算机能够通过网络互相交换数据**

- **网络编程**，也称为套接字编程，是指利用编程语言提供的特定API（应用程序编程接口），遵循既定的网络协议（如**`TCP/IP`**），来开发能够在不同计算机之间进行通信的应用程序的过程。

  - **工具：API（应用程序编程接口）**：在Java中，这套API就是 **`java.net`** 包中的 **`Socket`**, **`ServerSocket`** 等类。程序员通过调用这些API来命令计算机进行网络收发操作

  - 通信所必需的两个**关键信息**：**IP地址** 和 **端口号**

    - **IP地址**：标识网络中的**哪一台计算机**

    - **端口号**：**端口 (Port)** 是一个**逻辑通信端点**.

      ​		它是一个虚拟的、非物理存在的接口，专门用于在同一台计算机上区分不同的网络服务或应用程序.

      >概念属于**TCP/IP协议**中的传输层

      - **端口号**的取值范围是从 **0** 到 **65535**

        - **0 - 1023**：**周知端口**。这些端口被严格地分配给最重要、最核心的系统服务。例如：HTTP (**`80`**), HTTPS (**`443`**), FTP (**`21`**), SSH (**`22`**)。在大多数操作系统上，绑定到这个范围的端口需要管理员（root）权限。
        - **1024 - 49151**：**注册端口**。这些端口被分配给特定的应用程序或服务，由IANA（互联网号码分配局）进行注册和管理。例如：MySQL (**`3306`**), PostgreSQL (**`5432`**), Redis (**`6379`**)。虽然它们是注册的，但并不像周知端口那样被强制执行。
        - **49152 - 65535**：**动态/私有端口**。这个范围不会被分配给任何特定的服务。它被设计用于**私有**或**自定义**的应用程序，或者作为客户端发起连接时临时使用的“临时端口”。

      - **最佳实践是：为你的自定义应用程序选择** **49152** **到** **65535** **这个范围内的端口。**最安全、最推荐

        尽管上述是最佳实践，但在日常开发和测试中，开发者们形成了一些约定俗成的习惯：

        - **使用 "Registered Ports" 范围内的“高位”端口**：像 **`3000`, `8000`, `8080`, `5000`** 这样的端口在开发环境中非常常见

  

  - **规则：网络协议（TCP/IP协议）**
    - 网络协议的根本目的，是确保网络中千差万别的计算机和设备，能够**有序、高效、可靠地**进行数据交换和通信。
    - 网络协议中，虽然有很多协议，**但“TCP/IP协议族” 是事实上的全球标准**，基本上可以说目前**TCP/IP**是**唯一的协议族**
    - 其他的很多和 **TCP/IP** 竞争的协议族，基本都竞争失败了。**目前对于互联网和通用计算领域，**可以说**TCP/IP**是**唯一的协议族**
    - 我们平时见到的绝大多数协议，例如 **IP,TCP,UDP,HTTP, HTTPS, FTP, SMTP, POP3, IMAP, DNS, SSH** 等，**全部都属于TCP/IP协议族**



## TCP/IP协议

- **TCP/IP协议**，全称为**传输控制协议/网际协议**，它不是一个单一的协议，而是一个**包含了众多网络通信协议的集合，即协议族或协议套件 **。这个协议族是互联网的基础，它为网络中设备之间的数据交换定义了一套标准的、分层的规则，确保了全球范围内不同类型的计算机和网络能够相互通信



### 分层结构

- **TCP/IP 协议族**是一个四层的协议体系，从上到下依次为**应用层、传输层、网络层和网络接口层**

- 分层以及常见协议如下

  - **应用层 (Application Layer)**

    - 应用层直接为用户的应用程序提供服务，负责处理应用程序的逻辑。

    - 常见的应用层协议包括：

      - **HTTP (HyperText Transfer Protocol):** 超文本传输协议，用于万维网上的数据通信
      - **HTTPS (Hypertext Transfer Protocol Secure):** 在HTTP的基础上加入SSL/TLS协议，是用于在Web服务器和浏览器之间进行加密通信和身份认证的安全应用层协议

      - **FTP (File Transfer Protocol):** 文件传输协议，用于在计算机之间传输文件

      - **SMTP (Simple Mail Transfer Protocol):** 简单邮件传输协议，用于发送和接收电子邮件

      - **DNS (Domain Name System):** 域名系统，用于将域名解析为 IP 地址

      - **Telnet:** 远程登录协议，允许用户远程登录到另一台计算机

      - **SNMP (Simple Network Management Protocol):** 简单网络管理协议，用于网络设备的管理和监控

      - **POP3 (Post Office Protocol version 3):** 邮局协议版本3，用于接收电子邮件
      - ......

  - **传输层 (Transport Layer)**

    - 传输层为两台主机上的应用程序提供端到端的通信

    - 该层主要有两个核心协议：

      - **TCP:** 传输控制协议，提供面向连接的、可靠的数据传输服务。它具有流量控制、超时重传和拥塞控制等特性，确保数据包能够可靠地传输给对方

      - **UDP:** 用户数据报协议，提供无连接的、不可靠的数据传输服务。它不保证数据包是否能抵达对方，但实时性相对更好

  - **网络层 (Internet Layer)**

    - 网络层负责数据包的选路和转发，实现数据在网络中的传输。 它根据 IP 地址来寻找目标主机

    - 网络层的主要协议包括：

      - **IP (Internet Protocol):** 网际协议，是 TCP/IP 协议族的核心，负责将数据包从源主机发送到目标主机

      - **ICMP (Internet Control Message Protocol):** 互联网控制报文协议，用于在 IP 网络中发送控制消息，例如错误报告和网络状态查询

      - **IGMP (Internet Group Management Protocol):** 互联网组管理协议，用于管理多播组成员
      - ......

  - **网络接口层 (Network Interface Layer)**
    - 网络接口层也被称为数据链路层或链路层，它负责处理数据在物理媒介上的传输。该层实现了网卡接口的网络驱动程序，并管理物理地址（MAC 地址）与 IP 地址之间的转换
    - 这一层的协议包括：
      - **Wi-Fi (Wireless Fidelity):** 一套基于IEEE 802.11标准的无线局域网技术，允许电子设备通过无线电波连接到网络
      - **Ethernet (以太网):** 应用最广泛的有线局域网技术，定义了数据如何通过电缆等物理介质进行格式化和传输
      - **ARP (Address Resolution Protocol):** 地址解析协议，根据 IP 地址获取物理地址
      - **RARP (Reverse Address Resolution Protocol):** 逆地址解析协议，用于无盘工作站等设备根据物理地址获取自身的 IP 地址



### 协议细述

#### IP协议

- IP协议分为**IPv4**和**IPv6**
- Java中有一个专门的类**`java.net.InetAddress`**用来表示IP地址
  - **`InetAddress`** 是Java对IP地址（包括**`IPv4`**和**`IPv6`**）的封装。它不仅仅是一个字符串，而是一个包含了主机名和IP地址信息的对象

##### IPv4

- **IPv4 (Internet Protocol version 4)** 是互联网的第四个版本的核心协议，自1983年以来就一直是互联网的支柱。我们今天绝大多数的网络流量依然在通过它来传输。

- **地址格式**

  - **32位地址**: 这是**`IPv4`**最根本的特征。它的地址由32个二进制位组成。
  - **点分十进制表示法**: 为了方便人类记忆，这32位被分成了4个部分，每个部分8位（称为一个字节或八位位组），并用十进制数字表示，中间用点 **`.`**隔开
    - **示例**: **`192.168.1.1`** 或 **`8.8.8.8`**

- **后面地址不够用了**

  - 一个32位的地址，理论上最多可以提供 **2³²**个地址，大约是 **43亿** 个

  - **全球`IPv4`地址在2011年左右就已经被各大机构分配完毕了**

    >全球互联网号码分配局（IANA）管理的顶级IPv4地址池在 **2011年2月3日** 分配了最后一批/8地址块给五个地区的RIR。这标志着中央储备的完全枯竭
    >
    >在IANA的地址池耗尽后，全球五个地区的互联网注册机构（RIR）也相继分配完了各自持有的绝大部分IPv4地址：
    >
    >- **APNIC** (亚太地区): **2011年4月15日**
    >- **RIPE NCC** (欧洲、中东和中亚部分地区): **2012年9月14日**
    >- **LACNIC** (拉丁美洲和加勒比地区): **2014年6月10日**
    >- **ARIN** (美国、加拿大及部分加勒比岛屿): **2015年9月24日**
    >- **AFRINIC** (非洲地区): **2017年4月21日**

    - 现在能上网，全靠一些“续命”技术，比如 **NAT (网络地址转换)**，让一个路由器下的很多设备能共享同一个公网IP



##### IPV6

- 为了从根本上解决**`IPv4`地址耗尽**的问题，**IPv6 (Internet Protocol version 6)** 应运而生
- **核心特点：几乎无限的地址空间**
  - **128位地址**: 这是**`IPv6`**最引人注目的变化。它的地址长度是**`IPv4`**的四倍
  - **冒号十六进制表示法**: 它的地址由8个部分组成，每个部分16位，用十六进制数字表示，中间用冒号 **`:`**隔开。
    - **示例**: **`2001:0db8:85a3:0000:0000:8a2e:0370:7334`**

- **地址绝对够用**
  - **2¹²⁸** 个地址,这个数量级足以**为地球上每一粒沙子都分配一个IP地址**

- IPV6的**简化规则**
  - **省略前导零**: 在任何一个16位的块中，前面的 0 可以省略。
    - 0db8 -> db8
    - 0000 -> 0
    - 0370 -> 370
  - **压缩连续的零**: 如果有连续多个块都是 0，可以用 :: (双冒号) 来代替。**但这个规则在一个地址中只能使用一次**，否则无法确定压缩了多少个零块。



##### 相关Java类

###### **`InetAddress`类**

```java
public class InetAddress extends Object implements Serializable
```

- **Java中专门用来表示IP地址的类，它可以代表`IPv4`和`IPv6`两种类型的地址**
- **`java.net.InetAddress`**

- **`InetAddress`** 是Java对IP地址（包括**`IPv4`**和**`IPv6`**）的封装。它不仅仅是一个字符串，而是一个包含了主机名和IP地址信息的对象



**构造方法**

- 无，必须通过它的**静态工厂方法**来获取实例，获取的实例是它**子类的实例**

**类中方法**

```java
public static InetAddress 	getByName(String host)
													// 在给定主机名的情况下确定主机的 IP 地址
public static InetAddress[] getAllByName(String host)
											// 在给定主机名的情况下，根据系统上配置的名称服务返回其IP地址所组成的数组
public static InetAddress 	getLoopbackAddress()		// 返回环回地址。(通常是 127.0.0.1 或 ::1)
public static InetAddress 	getByAddress(byte[] addr)	// 在给定原始 IP 地址的情况下，返回 InetAddress 对象
public static InetAddress 	getByAddress(String host, byte[] addr)
														// 根据提供的主机名和 IP 地址创建 InetAddress
```

```java
public String 				getHostName() 					// 获取此 IP 地址的主机名。
public String 				getCanonicalHostName() 			// 获取此 IP 地址的完全限定域名。
public byte[] 				getAddress() 					// 返回此 InetAddress 对象的原始 IP 地址
public String 				getHostAddress() 				// 以文本表现形式返回 IP 地址字符串
```

```java
public boolean 				isMulticastAddress() 		// 检查该 InetAddress 是否是一个多播地址
public boolean 				isAnyLocalAddress() 		// 检查该 InetAddress 是否是通配符地址 (0.0.0.0)
public boolean 				isLoopbackAddress() 		// 检查该 InetAddress 是否是环回地址
public boolean 				isLinkLocalAddress() 		// 检查该 InetAddress 是否是链路本地地址
public boolean 				isSiteLocalAddress() 		// 检查该 InetAddress 是否是站点本地地址
public boolean 				isMCGlobal() 				// 检查该多播地址是否具有全局范围
public boolean 				isMCOrgLocal() 				// 检查该多播地址是否具有组织范围
public boolean 				isMCSiteLocal() 			// 检查该多播地址是否具有站点范围
public boolean 				isMCLinkLocal() 			// 检查该多播地址是否具有链路范围
public boolean 				isMCNodeLocal() 			// 检查该多播地址是否具有节点范围
public boolean 				isReachable(int timeout) 	// 测试是否可以访问到该地址
public boolean 				isReachable(NetworkInterface netif, int ttl, int timeout)
														// 测试是否可以访问到该地址，可指定网络接口、TTL等参数
```

```java
public boolean 				equals(Object obj) 			// 将此对象与指定对象进行比较。当且仅当IP地址相同时才返回true
public int 					hashCode() 					// 返回此 IP 地址的哈希码。
public String 				toString() 					
    									// 将此 IP 地址转换为 String。格式通常是：hostname / literal-IP-address
```

```java
public static InetAddress 	getLocalHost() 
    							// 返回本地主机。这通常是通过从操作系统检索主机名，然后将该名称解析为InetAddress来完成的
```



###### **`Inet4Address`类**

- **`InetAddress`类的子类**
- **此类表示 Internet 协议版本 4 (`IPv4`) 地址**

**构造方法**

- 无，实例是通过它的**父类`InetAddress`的静态工厂方法**来获取的

**类中方法**

```java
public boolean 		isMulticastAddress() 
    					// 检查该 InetAddress 是否是一个 IPv4 多播地址 (范围在 224.0.0.0 到 239.255.255.255 之间)
public boolean 		isAnyLocalAddress() // 检查该 InetAddress 是否是通配符地址 ("0.0.0.0")
public boolean 		isLoopbackAddress() 	// 检查该 InetAddress 是否是环回地址 (范围在 127.0.0.0/8 之内)
public boolean 		isLinkLocalAddress() 	// 检查该 InetAddress 是否是链路本地地址 (范围在 169.254.0.0/16 之内)
public boolean 		isSiteLocalAddress() 
    					//检查该InetAddress是否是站点本地地址(范围在10.0.0.0/8,172.16.0.0/12,192.168.0.0/16之内)
public boolean 		isMCGlobal() 			// 检查该多播地址是否具有全局范围。
public boolean 		isMCOrgLocal() 			// 检查该多播地址是否具有组织范围。
public boolean 		isMCSiteLocal() 		// 检查该多播地址是否具有站点范围。
public boolean 		isMCLinkLocal() 		// 检查该多播地址是否具有链路范围。
public boolean 		isMCNodeLocal() 		// 检查该多播地址是否具有节点范围。
```

```java
public int 			hashCode() 				// 返回此 IP 地址的哈希码。对于 IPv4 地址，其哈希码就是其32位整数表示
public boolean 		equals(Object obj) 		// 将此对象与指定对象进行比较
public String 		getHostAddress() 		// 以点分四段式 "d.d.d.d" 的文本表现形式返回 IP 地址字符串
public byte[] 		getAddress() 					// 返回此 InetAddress 对象的原始 IP 地址
```



###### **`Inet6Address`类**

- **`InetAddress`类的子类**
- **此类表示 Internet 协议版本 6 (`IPv6`) 地址**



**构造方法**

- 无，实例是通过它的**父类`InetAddress`或自己的静态工厂方法**来获取的

**类中方法**

```java
public static Inet6Address  getByAddress(String  host, byte[] addr, int scope_id)
    						//以与 InetAddress.getByAddress(String,byte[]) 完全相同的方式创建一个 Inet6Address
public static Inet6Address  getByAddress(String  host, byte[] addr, NetworkInterface  nif)
    						//以 InetAddress.getByAddress(String,byte[]) 的确切方式创建 Inet6Address
```

```java
public byte[] 				getAddress() 					// 返回此 InetAddress 对象的原始 IP 地址
public String 				getHostAddress() 				
    									// 以 RFC 2732 规范定义的文本表示形式返回 IP 地址字符串(例如 2001:db8::1)
public int 					getScopeId()
    								//对于一个有范围(scoped)的IPv6地址，返回其数字范围标识符。如果地址没有范围，则返回0
public NetworkInterface 	getScopedInterface() 	
    								// 对于一个有范围（scoped）的IPv6地址，返回其关联的网络接口
```

```JAVA
public boolean 				isIPv4CompatibleAddress()
   										//检查此InetAddress是否为IPv4兼容的IPv6地址(一种已过时的过渡地址类型)
public boolean 				isMulticastAddress() 
   										// 检查此 InetAddress 是否是一个 IPv6 多播地址 (地址以 ff00::/8 开头)
public boolean 				isAnyLocalAddress()				// 检查此 InetAddress 是否是通配符地址 (即 ::)
public boolean 				isLoopbackAddress() 			// 检查此 InetAddress 是否是环回地址 (即 ::1)
public boolean 				isLinkLocalAddress() 			
   											// 检查此 InetAddress 是否是链路本地地址 (地址以 fe80::/10 开头)
public boolean 				isSiteLocalAddress() 
   						// (已过时) 检查此 InetAddress 是否是站点本地地址。IPv6站点本地地址在 RFC 4291 中已被弃用
public boolean 				isMCGlobal() 					// 检查此多播地址是否具有全局范围
public boolean 				isMCOrgLocal() 					// 检查此多播地址是否具有组织范围
public boolean 				isMCSiteLocal() 				// 检查此多播地址是否具有站点范围
public boolean 				isMCLinkLocal() 				// 检查此多播地址是否具有链路范围
public boolean 				isMCNodeLocal() 				// 检查此多播地址是否具有节点范围
```

```JAVA
public int 					hashCode() 						// 返回此 IP 地址的哈希码
public boolean		 		equals(Object obj) 
    									// 将此对象与指定对象进行比较。当且仅当两个对象的地址字节序列完全相同时返回 true
public String 				toString() 					//将此IP地址转换为 String。通常包含主机名和IP地址的文本表示
```



##### 特殊IP

**`127.0.0.1`**

- 一个专用的 **回环地址 (Loopback Address)**，在IPv4地址空间中被特别保留，用于各种测试和本机通信



##### “IP+端口”类`InetSocketAddress`

- 表示**IP+端口**
- 将 **IP地址 和 端口号** 封装在了同一个对象
- 抽象类**`SocketAddress`**的子类

**构造方法**

```java
public 		InetSocketAddress(int port) 				// 创建一个套接字地址，其中IP地址为通配符地址，端口号为指定值
public 		InetSocketAddress(InetAddress addr, int port)		// 根据 IP 地址和端口号创建套接字地址
public 		InetSocketAddress(String host, int port)	
    										//根据主机名和端口号创建套接字地址。如果 host 为 null，则地址为通配符地址
```

**相关方法**

```java
public static InetSocketAddress createUnresolved(String host, int port)
													// 根据主机名和端口号创建未解析的套接字地址。不会立即尝试解析主机名
```

```java
public final int 				getPort() 					// 获取端口号。
public final InetAddress 		getAddress() 				// 获取 InetAddress。如果地址是未解析的，则返回 null
public final String 			getHostName() 				// 获取主机名。
public final String 			getHostString() 		
    							// 以字符串形式返回主机名，如果地址是未解析的，则返回原始主机名；否则返回IP地址的文本表示
```

```java
public final boolean 			isUnresolved() 				// 检查地址是否已经解析。
```

```java
public final boolean 	equals(Object obj) 					// 将此对象与指定对象进行比较。
public final int 		hashCode() 							// 返回此套接字地址的哈希码。
public final String 	toString() 
    							// 将此 InetSocketAddress 构造成 String。格式通常是 hostname/IP:port 或 IP:port
```



#### TCP协议

##### 相关概念

- TCP是一种**面向连接的、可靠的、基于字节流**的传输层通信协议。它的首要目标是确保数据能够准确、完整、有序地从发送方传输到接收方。
  - **面向连接**：
    - 在数据传输之前，必须先通过**“三次握手” (Three-way Handshake)** 在客户端和服务器之间建立一个可靠的连接。
    - 数据传输结束后，会通过**“四次挥手” (Four-way Wave)** 来断开连接，释放资源。
    - 这个“连接”是一个逻辑上的概念，确保了双方都准备好接收和发送数据。
  - **可靠传输** ：
    - **确认与重传机制**：每当发送方发送一个数据包，接收方收到后都会发送一个确认（ACK）消息。如果发送方在一定时间内没有收到确认，就会认为数据包丢失，并重新发送该数据包。
    - **数据校验**：TCP头部包含校验和（Checksum），用于检测数据在传输过程中是否出错。如果出错，该数据包会被丢弃（然后由重传机制保证重新发送）。
  - **有序传输**：
    - TCP会给每个数据包（段，Segment）一个**序列号 (Sequence Number)**。
    - 接收方会根据序列号对收到的数据包进行排序，即使它们因为网络原因乱序到达，TCP也能将它们重新组合成正确的顺序再交给上层应用。
  - **流量控制**：
    - TCP使用**滑动窗口 (Sliding Window)** 机制。接收方会告诉发送方自己还能接收多少数据，发送方则根据这个信息来调整发送速度，防止过快的数据流淹没接收方。
  - **拥塞控制**：
    - 当网络发生拥堵时，TCP会自动降低发送速率，以缓解网络压力，避免造成网络瘫痪。

- **应用场景：**
  对数据完整性和顺序性要求极高的场景。
  - **Web浏览** (HTTP, HTTPS)
  - **文件传输** (FTP)
  - **电子邮件** (SMTP, POP3, IMAP)
  - **数据库连接**
- **缺点：**
  - 由于需要建立连接、发送确认、进行重传等，开销较大，**传输速度相对较慢**
  - 协议头部信息多，增加了网络负载



##### 相关Java类

- **`Socket`**类和**`ServerSocket`**类
- **"点和大点？"**

> 理解：
>
> **`Socket`**的中文意思是”插座“，但是我目前倾向于把它理解为一个”点“，或者是”连接点“，它只是一个点，然后对于服务端和客户端，也是两个点，只不过**`ServerSocket`**是一个大点。**在客户端创建一个你自己写的Socket对象，把目标服务器的IP地址和它正在监听的端口号传进去，以发起连接请求，`ServerSocket`这个大点对象，通过`accept()`处理这个请求，返回一个已经和你客户端的`Socket`对象建立好连接的服务器端`Socket`对象**

###### `Socket`类

- 倾向于把它理解为一个点



**构造方法**

```java
public 		Socket() 								// 创建一个未连接的套接字，使用系统默认的 SocketImpl
public 		Socket(String host, int port) 			// 创建一个流套接字并将其连接到指定主机上的指定端口号
public 		Socket(InetAddress address, int port) 	// 创建一个流套接字并将其连接到指定 IP 地址的指定端口号
public 		Socket(String host, int port, InetAddress localAddr, int localPort)
					//创建一个套接字并将其连接到指定远程主机上的指定远程端口.在返回之前，套接字将绑定到给定的本地地址和端口号
public 		Socket(InetAddress address, int port, InetAddress localAddr, int localPort)
													// 创建一个套接字并将其连接到指定远程地址上的指定远程端口
public 		Socket(Proxy proxy) 					// 创建一个未连接的套接字，并指定代理类型（如果有）
protected 	Socket(SocketImpl impl) 				// 使用用户指定的 SocketImpl 创建一个未连接的 Socket
```

**相关方法**

```java
public void 	connect(SocketAddress endpoint) 			// 将此套接字连接到服务器
public void 	connect(SocketAddress endpoint, int timeout)// 将此套接字连接到服务器，并指定一个超时值(以毫秒为单位)
public void 	bind(SocketAddress bindpoint) 				// 将套接字绑定到本地地址
public void 	close() 									// 关闭此套接字。一旦关闭，它将不可再用
public void 	shutdownInput() 							// 将此套接字的输入流置于“流的末尾”
public void 	shutdownOutput() 							// 禁用此套接字的输出流
```

```java
public InputStream 			getInputStream() 				// (最核心) 返回此套接字的输入流。用于从服务器读取数据
public OutputStream 		getOutputStream() 				// (最核心) 返回此套接字的输出流。用于向服务器写入数据
```

```java
public InetAddress 			getInetAddress() 				// 返回套接字连接的远程 IP 地址。
public int 					getPort() 						// 返回此套接字连接到的远程端口。
public InetAddress 			getLocalAddress() 				// 获取套接字绑定的本地地址。
public int 					getLocalPort() 					// 返回此套接字绑定到的本地端口。
public SocketAddress 		getRemoteSocketAddress()		// 返回此套接字连接的端点的地址。
public SocketAddress 		getLocalSocketAddress()			// 返回此套接字绑定的端点的地址。
public SocketChannel 		getChannel() 
    									//返回与此套接字关联的唯一java.nio.channels.SocketChannel对象(如果存在)
```

```java
public void 		setTcpNoDelay(boolean on) 				// 启用/禁用 TCP_NODELAY（禁用 Nagle 算法）。
public boolean 		getTcpNoDelay() 						// 测试是否启用 TCP_NODELAY。
public void 		setSoLinger(boolean on, int linger)		// 启用/禁用具有指定逗留时间(以秒为单位)的SO_LINGER
public int 			getSoLinger() 							// 返回 SO_LINGER 的设置
public void 		setSoTimeout(int timeout) 
   								// 启用/禁用带有指定超时值的 SO_TIMEOUT（以毫秒为单位）。读取操作将阻塞最多此时间
public int 			getSoTimeout() 							// 返回 SO_TIMEOUT 的设置
public void 		setSendBufferSize(int size) 			// 设置此 Socket 的 SO_SNDBUF 选项的值
public int 			getSendBufferSize() 					// 获取此 Socket 的 SO_SNDBUF 选项的值
public void 		setReceiveBufferSize(int size)			// 设置此 Socket 的 SO_RCVBUF 选项的值
public int 			getReceiveBufferSize() 					// 获取此 Socket 的 SO_RCVBUF 选项的值
public void 		setKeepAlive(boolean on) 				// 启用/禁用 SO_KEEPALIVE
public boolean 		getKeepAlive() 							// 测试是否启用 SO_KEEPALIVE
public void 		setTrafficClass(int tc) 
   	// 在从此Socket发送的IP数据报的IP头中为流逝的字节设置流量类别(traffic class)或服务类型(type-of-service)八位组
public int 			getTrafficClass() 						//获取从此Socket上发送的包的IP头中的流量类别或服务类型
public void 		setReuseAddress(boolean on) 			// 启用/禁用 SO_REUSEADDR 套接字选项
public boolean 		getReuseAddress() 						// 测试是否启用 SO_REUSEADDR
public void 		setOOBInline(boolean on) 				// 启用/禁用 OOBINLINE（接收 TCP 紧急数据）
public boolean 		getOOBInline() 							// 测试是否启用 OOBINLINE
public void 		sendUrgentData(int data) 				// 在套接字上发送一个紧急数据字节
public <T> T 		getOption(SocketOption <T> name)		//返回套接字选项的值。
public <T> Socket  	setOption(SocketOption <T> name, T value)//设置套接字选项的值
public void 		setPerformancePreferences(int connectionTime, int latency, int bandwidth)
    														//为此套接字设置性能首选项
```

```java
public boolean 		isConnected() 							// 返回套接字的连接状态
public boolean 		isBound() 								// 返回套接字的绑定状态	
public boolean 		isClosed() 								// 返回套接字的关闭状态
public boolean 		isInputShutdown() 						// 返回是否关闭了套接字连接的读取半部分
public boolean 		isOutputShutdown() 						// 返回是否关闭了套接字连接的写入半部分
```

```java
public static synchronized void setSocketImplFactory(SocketImplFactory fac)   //为应用程序设置客户端套接字实现工厂
```

```JAVA
public Set <SocketOption <?>> 	supportedOptions()							  //返回此套接字支持的一组套接字选项
```



###### `ServerSocket`类

- 也倾向于理解为一个点，是一个大点



**构造方法**

```java
public 			ServerSocket() 						// 创建一个未绑定的服务器套接字。
public 			ServerSocket(int port) 				// 创建绑定到特定端口的服务器套接字。
public 			ServerSocket(int port, int backlog) 
    				// 利用指定的backlog创建服务器套接字并将其绑定到指定的本地端口号。backlog 参数是请求连接的最大队列长度
public 			ServerSocket(int port, int backlog, InetAddress bindAddr)
													// 使用指定端口、侦听 backlog 和要绑定到的本地 IP 地址创建服务器
protected 		ServerSocket(SocketImpl  impl)		// 使用用户指定的 SocketImpl 创建服务套接字
```

**相关方法**

```java
public Socket 		accept() 			//(最核心, 阻塞方法) 侦听并接受到此套接字的连接.此方法在连接传入之前一直阻塞
public void 		bind(SocketAddress endpoint) // 将 ServerSocket 绑定到特定地址（IP 地址和端口号）
public void 		bind(SocketAddress endpoint, int backlog)
												// 将 ServerSocket 绑定到特定地址（IP 地址和端口号），并设置backlog
public void 		close() 					// 关闭此套接字。
```

```java
public InetAddress 		getInetAddress() 		// 返回此服务器套接字的本地地址。
public int 				getLocalPort() 			// 返回此套接字在其上侦听的端口。
public SocketAddress 	getLocalSocketAddress()	// 返回此套接字绑定的端点的地址。
public SocketChannel 	getChannel() 			
   								// 返回与此套接字关联的唯一java.nio.channels.ServerSocketChannel对象(如果存在)
public boolean 			isBound() 				// 返回 ServerSocket 的绑定状态
public boolean 			isClosed() 				// 返回 ServerSocket 的关闭状态
```

```java
public void 			setSoTimeout(int timeout) 
   							// 启用/禁用带有指定超时值的 SO_TIMEOUT(以毫秒为单位).accept() 方法将阻塞最多此时间
public int 				getSoTimeout() 					// 获取 SO_TIMEOUT 的设置
public void 			setReuseAddress(boolean on) 	// 启用/禁用 SO_REUSEADDR 套接字选项
public boolean 			getReuseAddress() 				// 测试是否启用 SO_REUSEADDR
public void 			setReceiveBufferSize(int size)
   											// 为从此 ServerSocket 接受的套接字设置 SO_RCVBUF 选项的默认建议值
public int 				getReceiveBufferSize() 	//获取将用于从此ServerSocket接受的套接字的 SO_RCVBUF 选项的默认值
public void 			setPerformancePreferences(int connectionTime, int latency, int bandwidth)
												// 设置此 ServerSocket 的性能偏好
```

```java
public static synchronized void setSocketFactory(SocketImplFactory fac)		// 为应用程序设置服务器套接字实现工厂
public String 					toString() 						// 返回此套接字的实现地址和实现端口的字符串表示形式
```

```JAVA
public <T> T 					getOption(SocketOption <T> name)				//返回套接字选项的值
public <T> ServerSocket  		setOption(SocketOption <T> name, T value)		//设置套接字选项的值
protected final void 			implAccept(Socket  s)				
    											//ServerSocket 的子类使用此方法重写 accept() 以返回自己的套接字子类
public Set <SocketOption <?>> 	supportedOptions()		
    									//返回此服务套接字支持的一组套接字选项。即使套接字已关闭，此方法仍将继续返回选项集
```



#### UDP协议

##### 相关概念

- UDP是一种**无连接的、不可靠的**传输层协议。它追求的是极致的简单和高效，只负责把数据包（数据报，Datagram）发送出去，不保证后续的任何事情。

  - **无连接**：

    - 发送数据前不需要建立连接（没有“三次握手”）。
    - 发送方直接将数据打包成数据报，加上目标地址和端口就扔到网络里，不管接收方是否准备好。

  - **不可靠传输**：

    - UDP不提供任何可靠性保证。它只是“尽力而为” (Best-Effort) 地发送数据。
    - 没有确认机制，没有重传机制，没有超时机制。数据包丢了就丢了。
    - 不保证数据包是否会到达、何时到达。

  - **无序传输**：

    - UDP不保证数据包的到达顺序。后发的数据包完全可能先于先发的数据包到达。
    - 如果应用需要保证顺序，必须在应用层自己实现排序逻辑。

  - **传输速度快**：

    - 因为它没有TCP那些复杂的控制机制，协议头部简单（只有8个字节，TCP头部至少20字节），所以打包和发送的速度非常快，网络开销小

  - **应用场景：**

    对速度要求高，但能容忍少量数据丢失的场景。

    - **实时音视频通话/直播** (VoIP, WebRTC)：丢失一两帧画面或短暂的声音，比为了等待重传而造成整个画面卡顿要好。
    - **在线游戏**：需要快速响应，玩家位置等信息快速同步，偶尔丢一个包影响不大。

    - **DNS (域名系统)**：一次查询请求和响应非常小，用UDP速度快。如果失败了，由应用本身（比如操作系统）发起重试即可。

    - **广播和多播**：向网络中的多个设备发送信息，不需要一一确认它们是否收到。

  - **缺点：**

    - 不可靠，不稳定。
    - 没有流量控制和拥塞控制，容易在网络拥堵时加剧状况。



##### 相关Java类

- **`DatagramPacket`**和**`DatagramSocket`**
- **”包裹和邮局(点)？“**

> 理解：
>
> 理解为邮局发送包裹，**`DatagramPacket`**是包裹，**`DatagramSocket`**是邮局，把详细处理好一切的包裹通过**`DatagramSocket`**(邮局)的**`send()`**发送到包裹上写的地址上，不100%保证一定发到
>
> 在去取包裹的时候，自己拿个空包，把取到的包裹放进来
>
> - 箱到箱？包到包？



###### `DatagramPacket`

- 倾向于把它理解为一个”包裹“或“包”，在寄数据的时候，是把包裹寄过去；在取数据的时候，是把包裹放到包里拿回来。
- 取数据的时候，传参类似于之前的“传进去空篮子”
- 箱到箱？包到包？



**构造方法**

```java
public 		DatagramPacket(byte[] buf, int length, InetAddress address, int port)
												// 构造数据报包，用来将长度为 length 的包发送到指定主机上的指定端口号
public 		DatagramPacket(byte[] buf, int offset, int length, InetAddress address, int port)
												// 构造数据报包，用来将长度为 length 的包发送到指定主机上的指定端口号
public 		DatagramPacket(byte[] buf, int length, SocketAddress address)
													// 构造数据报包，用来将长度为 length 的包发送到指定套接字地址
public 		DatagramPacket(byte[] buf, int length) 	// 构造 DatagramPacket，用来接收长度为 length 的数据包
public 		DatagramPacket(byte[] buf, int offset, int length)
													//构造DatagramPacket,用来接收长度为length的数据包,并指定偏移量
    												//偏移量就是要跳过几个，如果是0，就是从0开始接收
public 		DatagramPacket(byte[] buf, int offset, int length, SocketAddress  address)
    						//构造一个数据报包，用于将长度为 length、偏移量为 offset 的数据包发送到指定主机上的指定端口号
```

**相关方法**

```java
public InetAddress 		getAddress() 					// 返回此包将要发往或刚刚来自的机器的 IP 地址。
public void 			setAddress(InetAddress iaddr) 	// 设置此数据报将要发往的机器的 IP 地址。
public int 				getPort() 						// 返回此包将要发往或刚刚来自的远程主机上的端口号
public void 			setPort(int iport) 				// 设置此数据报将要发往的远程主机上的端口号
public SocketAddress 	getSocketAddress() 				// 获取此包将要发往或刚刚来自的远程主机的 SocketAddress
public void 			setSocketAddress(SocketAddress address)// 设置此数据报将要发往的远程主机的 SocketAddress
public byte[] 			getData() 						// 返回数据缓冲区
public void 			setData(byte[] buf, int offset, int length)// 为此包设置数据缓冲区
public void 			setData(byte[] buf) 			// 为此包设置数据缓冲区
public int 				getLength() 					// 返回将要发送或接收到的数据的长度
public void 			setLength(int length) 			// 设置此包的长度
public int 				getOffset() 					// 返回将要发送或接收到的数据的偏移量
```



###### `DatagramSocket`

- 倾向于理解为一个"邮局"，或一个"点"，寄数据或取数据
- 单播(个人感觉场景几乎100%都是单播)和广播(个人感觉不常用)



**构造方法**

```java
public 		DatagramSocket() 							// 构造数据报套接字并将其绑定到本地主机上任何可用的端口,随机?
public 		DatagramSocket(int port) 					// 构造数据报套接字并将其绑定到本地主机上的指定端口
public 		DatagramSocket(int port, InetAddress laddr)	// 创建一个数据报套接字，将其绑定到指定的本地地址和端口
public 		DatagramSocket(SocketAddress bindaddr) 		// 创建一个数据报套接字，将其绑定到指定的本地套接字地址
protected 	DatagramSocket(DatagramSocketImpl impl)
    										// 使用指定的用户提供的 DatagramSocketImpl 创建一个未绑定的数据报套接字
```

**相关方法**

```java
public void 	send(DatagramPacket p) 		// (核心发送) 从此套接字发送数据报包。
public void 	receive(DatagramPacket p) 
    									  	//(核心接收, 阻塞方法)从此套接字接收数据报包.此方法在接收到数据报前一直阻塞
```

```java
public void 	connect(InetAddress address, int port)
                      	 					// 将套接字连接到此套接字的远程地址。连接后，只能向该地址发送和从该地址接收包
public void 	connect(SocketAddress addr) // 将此数据报套接字连接到远程套接字地址
public void 	disconnect() 				// 断开套接字的连接
public void 	close() 					// 关闭此数据报套接字
public void 	bind(SocketAddress  addr)	// 将此 DatagramSocket 绑定到特定地址和端口
```

```java
public InetAddress 		getInetAddress() 		// 返回此套接字连接的地址。如果套接字未连接，则返回 null。
public int 				getPort() 				// 返回此套接字的端口。如果套接字未连接，则返回 -1。
public InetAddress 		getLocalAddress()		// 获取套接字绑定的本地地址。
public int 				getLocalPort() 			// 返回此套接字绑定到的本地端口。
public SocketAddress 	getRemoteSocketAddress()// 返回此套接字连接的端点的地址。
public SocketAddress 	getLocalSocketAddress()	// 返回此套接字绑定的端点的地址。
public DatagramChannel 	getChannel() 			// 返回与此数据报套接字关联的唯一 DatagramChannel 对象（如果存在）
public boolean 			isBound() 				// 返回套接字的绑定状态。
public boolean 			isClosed() 				// 返回套接字是否已经关闭。
public boolean 			isConnected() 			// 返回套接字的连接状态。
```

```java
public void 			setSoTimeout(int timeout) 
   											// 启用/禁用带有指定超时值的 SO_TIMEOUT。receive() 将阻塞最多此时间
public int 				getSoTimeout() 					// 获取 SO_TIMEOUT 的设置
public void 			setSendBufferSize(int size) 	// 设置 SO_SNDBUF 选项的值
public int 				getSendBufferSize() 			// 获取 SO_SNDBUF 选项的值
public void 			setReceiveBufferSize(int size)	// 设置 SO_RCVBUF 选项的值
public int 				getReceiveBufferSize() 			// 获取 SO_RCVBUF 选项的值
public void 			setReuseAddress(boolean on) 	// 启用/禁用 SO_REUSEADDR 套接字选项
public boolean 			getReuseAddress() 				// 获取 SO_REUSEADDR 的设置
public void 			setBroadcast(boolean on) 		// 启用/禁用 SO_BROADCAST。启用后，可以发送广播包
public boolean 			getBroadcast() 					// 测试是否启用 SO_BROADCAST
public void 			setTrafficClass(int tc)	 		
   												   //为从此DatagramSocket发送的包在IP头中设置流量类别或服务类型
public int 				getTrafficClass() 			   //获取从此DatagramSocket发送的包的IP头中的流量类别或服务类型
```

```JAVA
public <T> T 				getOption(SocketOption <T> name)				//返回套接字选项的值
public <T> DatagramSocket  setOption(SocketOption <T> name, T value)	//设置套接字选项的值
public void 				joinGroup(SocketAddress  mcastaddr, NetworkInterface  netIf)
    														//加入多播组
public void 				leaveGroup(SocketAddress  mcastaddr, NetworkInterface  netIf)
    														//在指定的本地接口上保留多播组
public Set <SocketOption <?>> supportedOptions()			
    									//返回此套接字支持的一组套接字选项。即使套接字已关闭，此方法仍将继续返回选项集
```



###### `MulticastSocket`

- 组播(个人感觉不常用)
- **`DatagramSocket`** 的子类

