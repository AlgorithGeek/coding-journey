# 泛型(Generic) `<T>`

- **JDK5**引入的
- **设计目标：编译时类型安全**
- 用于在**编译阶段** **约束数据类型**
- 泛型信息在**编译后**会被**擦除**，运行的时候实际上已经开始直接操作具体的类型了，不必担心，**不同的情况下有不同的擦除规则**
- 泛型是针对于**引用数据类型的**，对于**基本数据类型**，可以操作**包装类**
- 元素在放进**Java定义的集合**后，集合内部把这些元素视为**`Object`**类型，取出来后则转为**其原来的类型**
- 泛型是**不变**的，即**泛型没有继承关系**，这意味着即使 **`Son`** 是 **`Father`** 的子类，**`ArrayList<Son>`** 也不是 **`ArrayList<Father>`** 的子类型，**`ArrayList<Father>`** 也不能接收**`ArrayList<Son>`** 类型的对象，但是**`ArrayList<Father>`** 可以接收**`Son`**元素
- **Java允许在泛型变量声明和实际对象之间使用不一致的泛型类型，但必须通过通配符（`? extends` 或 `? super`）实现协变或逆变赋值，且这种赋值会引入编译期的操作限制**
- 在**声明**的时候**可以使用通配符**，在**实例化(new 的时候)** **不允许使用任何通配符**



## 泛型的擦除

- **泛型的擦除本质上是替换**，但这一过程需要结合上下文和具体规则来理解和述说

- Java 泛型是 **编译时特性**，而非**运行时特性**。编译器通过**类型擦除**将**泛型类型**转换为**原始类型**或**上界类型**，以确保与非泛型代码的兼容性
  - 上面说的**原始类型（Raw Type）** 是指 **未指定泛型类型参数** 的**泛型类或接口**，类似于**没有定义泛型的`ArrayList`**

- 如果没有定义**上界类型**，泛型类型会被擦除为**`Object`**
  如果定义了**上界类型**（例如 **`<T extends Number>`**）：泛型类型会被擦除为**上界的类型**（如 **`Number`**）
  如果泛型参数有**多个上界**（如 **`<T extends A & B>`**），擦除后会选择**第一个边界类型**（**`A`**）

- 在下面这些情况下，编译器会在编译时自动进行强转
  - **从泛型对象中读取数据时**
  - **调用泛型方法的返回值时**
  - **等......**



## 泛型类

### 相关概念

- 如果**类中**某个地方的**类型不确定**，就可以使用**泛型**指定，超级灵活
- 如果没有定义**上界类型**，泛型类型会被擦除为**`Object`**
  如果定义了**上界类型**（例如 **`<T extends Number>`**）：泛型类型会被擦除为**上界的类型**（如 **`Number`**）
  如果泛型参数有**多个上界**（如 **`<T extends A & B>`**），擦除后会选择**第一个边界类型**（**`A`**）

- 在下面这些情况下，编译器会在编译时自动进行强转
  - **从泛型对象中读取数据时**
  - **调用泛型方法的返回值时**
  - 等......

### 格式

#### 定义格式

```java
// 单个类型参数
修饰符 class 类名<T> { 
    // 成员变量和方法中使用 T
}

// 多个类型参数（逗号分隔）
修饰符 class 类名<T,U> { 
    // 成员变量和方法中使用 T 和 U
}

// 带类型边界
修饰符 class 类名<T extends 上界类型> {
    // T 必须是上界类型的子类
}
```

#### 操作格式

```java
ArrayList<String> list = new ArrayList<>();
```



### 注意事项

- 如果类中有**静态方法**，静态方法中不能使用**类上的泛型**

- 如果类中还有一个**内部类**也用了**和外部类相同的泛型**，**两者泛型并不相同**，因为作用域等相关原因



## 泛型方法

### 相关概念

- 泛型方法是**独立于类的泛型参数**的方法。它允许在方法级别定义类型参数（`<T>`），使得方法可以处理多种数据类型，而无需依赖类的泛型定义。泛型方法可以是静态或非静态的

### 格式

#### 定义格式

```java
修饰符 <T> 返回类型 方法名(T 参数) {
    // 方法体中使用 T
}

// 带类型边界的方法
修饰符 <T extends 上界类型> 返回类型 方法名(T 参数) {
    // T 必须是上界类型的子类
}

// 静态泛型方法（不能依赖类的泛型参数）
修饰符 static <T> 返回类型 方法名(T 参数) {
    // 方法体中使用 T
}
```

#### 操作格式

##### 静态方法

- 显示指定类型

  - **类名.<类型参数>方法名(参数)**

    ```java
    Box.<Integer>print(1);
    ```

- 隐式类型推断

  - 如果**方法的参数或返回值类型足够明确**，编译器可以**自动推断泛型类型**，**无需显式指定**

    ```java
    Box.print("hello world");
    ```

##### 实例方法

- 显示指定类型

  - **对象名.<类型参数>方法名(参数)**

    ```java
    b.<Integer>printA(1);
    ```

- 隐式类型推断

  - 如果**方法的参数或返回值类型足够明确**，编译器可以**自动推断泛型类型**，**无需显式指定**

    ```java
    b.printA("hello world");
    ```

    



## 泛型接口

### 相关概念

泛型接口是**在接口级别定义类型参数**（如 **`<T>`**），允许接口方法使用该类型参数。实现泛型接口时，可以选择指定具体类型或保持泛型。

### 格式

```java
修饰符 interface 接口名<T> {
    // 方法中使用 T
}

// 多个类型参数
修饰符 interface 接口名<K, V> {
    // 方法中使用 K 和 V
}

// 带类型边界
修饰符 interface 接口名<T extends 上界类型> {
    // T 必须是上界类型的子类
}
```

### 操作格式

#### 实现类直接给出具体的类型

- 直接为接口的泛型参数指定具体类型（如 **`String`**、**`Integer`**）

  ```java
  public class MyList implements List<String> {
      	......
  }
  ```

  ```java
  MyList list = new MyList();
  ```

  

#### 实现类延续泛型

- **实现类声明自己的泛型参数，但是这样的话默认List的泛型类型就是其上界或`Object`**

  ```java
  public class MyList<T> implements List{	
      ......
  }
  ```

  ```java
  MyList<String> list = new MyList();
  ```

  

- **实现类同时声明自己的泛型参数和泛型接口的类型参数，将两个泛型绑定到一起，二者必须相同**

  ```java
  public class MyList<T> implements List<T> {		//注意两个T都要写，我理解的是因为编译嘛，如果不写，那个List就被替代
      											//成上界或者Object了，写了之后就可以绑定了
      											//有的可能有两个泛型参数，如果只写一个会报错，所以要写就写好
      	......
  }
  ```

  ```java
  MyList<String> list = new MyList();
  ```

  



- **不能只写要实现的接口的泛型**

  ```java
  public class MyList implements List<T> {		//错误，不能只写要实现的接口的，原因有很多吧
      											//一方面和不写就没区别了，并且突然多了一个T,统一混淆啥啥啥的
      											//比如作用域?因为这个T没办法在MyList的类体中用
      											//我自己还有一个理解就是如果要创建这个类的对象，没法指定这个List的T
      											//	......等等原因
      ...
  }
  ```

  ```java
  上面那个写不了
  ```

  

## 泛型的不变性

### 不变性

- **泛型的不变性**是针对**泛型和泛型之间**而言的，而不是**泛型和元素之间**

- 在 Java 泛型中，**泛型类型是不变的（invariant）**，这意味着即使 **`Son`** 是 **`Father`** 的子类，**`ArrayList<Son>`** 也不是 **`ArrayList<Father>`** 的子类型，**`ArrayList<Father>`** 也不能接收**`ArrayList<Son>`** 类型的对象

  ```java
  public static void main(String[] args) {
      ArrayList<Father> a1 = new ArrayList();
      ArrayList<Son> a2 = new ArrayList();
      
      method(a1); // 正常
      method(a2); // 报错：类型不兼容
  }
  
  public static void method(ArrayList<Father> a) {}
  
  ```

- 原始类型会**绕过泛型的类型检查**，目的主要是为了兼容 JDK5 以前的历史遗留代码

  ```java
  public static void main(String[] args) {
      ArrayList<Father> a1 = new ArrayList();
      ArrayList<Son> a2 = new ArrayList();
      ArrayList a3 = new ArrayList();
      
      method(a1); // 正常
      method(a2); // 报错：类型不兼容
      method(a3);	// 绕过泛型的类型检查,正常，不报错
  }
  
  public static void method(ArrayList<Father> a) {}
  ```

- 感觉一个原因是为了防止不相同的引用(变量)接收之后肆意操作数据，但是数组没办法这样防止，所以直接禁止了创建动态数组

  - 彻底禁止才是最优做法



### 注意点

- **但是**，要注意区分**元素的多态性**，主要是**向上转型**，对于数据而言，是可以**向上转型**的，比如一个集合泛型是**`Father`**类型，但是你添加**`Son`**类型，也可以**添加成功**，这个泛型的**不变性**只是针对完整的**泛型类**而言的，而不是所要限制的数据

  ```java
  public static void main(String[] args) {
      ArrayList<Father> a1 = new ArrayList();
      ArrayList<Son> a2 = new ArrayList();
      
      method(a1); // 正常
      method(a2); // 报错：类型不兼容
      a1.add(new Father());	//正常，泛型支持
      a1.add(new Son());		//元素(或数据)的向上转型，和泛型的不变性是两个不同的概念
  }
  
  public static void method(ArrayList<Father> a) {}
  ```

  

## 通配符

- 通配符 **`?`** 用于**放宽泛型类型的限制**，允许代码更灵活地处理不同泛型类型的对象

  > 我认为通配符是突破泛型的不变性的一种方式

### 三种通配符

- 要注意通配符的写入和读取，这个好像跟编译器插入强转也有关

#### **无界通配符`<?>`**

- 无界通配符 **`<?>`** 表示**未知类型**，可以接受任何泛型类型的对象，比如**ArrayList<`People`>**

- 但它只能用于**泛型容器**的**读取数据**操作（返回 **`Object`**），**写入数据时受限**（只能写入 **`null`**）
  - 读是都能读，反正不管**强转**还是**类型擦除**，都是**Object**，肯定能读，但是没办法读子类**特有的**
  - 不能写，啥都不知道(就算知道这里也要装作不知道)，只要给**`<?>`引用**稍微给一个**限制的泛型**，就坏了
  - 比如你用**`ArrayList<?>`**接收了一个**`ArrayList<People>`(允许,因为`?`可以接收`People`的)**，但是你写入一个**`Cat`**或**`Dog`**，就完蛋了，但是读的话统一认为是**`Object`**，所以没问题



#### **上界通配符`<? extends T>`(协变)**

- **类型擦除**是会擦除为**上界**，而非**具体子类类型**

- **`<? extends T>`** 表示**未知类型是 `T` 或其子类体系中的类**，主要用于**安全的读取数据**
- 但它只能用于**泛型容器**的**读取数据**（返回 **`T`类型**），**写入数据时受限**（只能写入 **`null`**）
  - 为啥不让写，我的这个只是个引用，引用可以接收你**`new`**的容器，但如果接收的是**`Dog`**容器，你放一个用**`Animal`**接收的**`Cat`**，我不炸了嘛
  - 为什么能读，类型擦除擦除为上界，强转的话也是上界，肯定能读，就是读不了子类**特有的**
  - 这个假设是一个**`ArrayList<? extend Animal>`**,然后接收了一个**`ArrayList<Cat>`**(允许,因为**`Cat`**是**`Animal`**的子类),如果你写入一个**`Dog`**，就完蛋了，因为在编译器眼里只是**`ArrayList<? extend Animal>`**,它不知道到底确定的是哪个子类(**就算知道这里也要装作不知道，这是设计思想**)，这个你并没有指定，你写代码的时候就写的非常宽松，所以不能加，子类都不能加，更别说非子类了，强转更是不行，你又不能**`(?)`**这样强转，你也不知道该强转成什么具体类型，转了也存不进去，因为可能不一致
    上面的类也不行，什么叔叔类什么的，因为不能强转为这个**`T`**,毕竟啊，强转只能是父类引用指向子类对象才行，如果真的是父类引用指向子类对象，那到底是那个子类呢？具体哪个呢？编译器不知道，不确定，不知道强转成什么

- **`T`**就是我们一直说的**上界**



#### **下界通配符`<? super T>`(逆变)**

- **类型擦除**和**强转**是**`Object`**

- **`<? super T>`** 表示**未知类型是 `T` 或其父类线上的某一个类**，主要用于**安全的写入数据**
- 对于**泛型容器**，可以写入 **`T` 及其子类对象**，只能以 **`Object`** 类型读取
  - 为什么能写，之前的那些不能写都是因为全盘不确定，但是这个不一样，它的泛型表示的是**`T`及其父类线上的一个类**,这些类就算再不确定，体系中最低也是**`T`类**，你只要写入**`T`及其子类对象**，就一定能接收成功，兄弟，这里不管装不装做不知道，这里都是合理的
  - 为什么能读，读肯定能读，就是读不了子类特有的，只能读为**`Object`**的
  - 这个假设是一个**`ArrayList<? super Dog>`**,然后接收了一个**`ArrayList<Animal>`**,不管是**`Animal`**还是**什么别的**，你写入**`Dog`及其子类对象**，都是向上转型，就算已经有元素，也是向上转型，都是向上转型，所以写入不会出错;
    对于读取来说，为什么不能读成**`T`**，因为任何父类线上的都能接收，如果是一个**`ArrayList<? extend Integer>`**，如果接收了一个**`ArrayList<Number>`**，这个**`ArrayList<Number>`**中已经有了很多**`Double`**数据，如果想当然的觉得都可以强转为**`T`**读取，那就有问题了，那是理想情况，如果已经有无继承关系的元素呢？所以并不是为了规范和公平什么的，为了安全等原因综合考虑，规定所有只能用**`Object`**读取



## 泛型的转型

- 泛型中也是有**向上转型**和**向下转型**的，与类中的向上转型和向下转型**不同**，但又**有类似的思想**，泛型的**向上转型和向下转型**和它们表示的范围有关,**向上转型(扩张),向下转型(收缩)**，**向上转型后的范围不能没有原来的部分**，**向下转型的范围不能变到自己没有的地方**
- 相当于**向上转型你要扩张范围，向下转型你要收缩范围**，**向上转型后的范围不能没有原来的部分**，**向下转型的范围不能变到自己没有的地方**
- 类比面向对象中多态中的**向上转型和向下转型**，向下转型要**强制类型转换**
- 对于安全性嘛，看情况而定，我见到的**很多**反正都是**向下转型** **被标记警告**，但是**向上转型**似乎还没有



## 泛型相关的类型转换

- 有很多转换**虽然编译通过，但是运行可能会出错**，编译器在用泛型读取数据的时候，会**自动插入强制类型转换的代码**，有时候可能编译时不报错，**但是运行时因为类型不匹配抛出了 `ClassCastException`异常**
- 在 Java 泛型中，**泛型类型是不变的（invariant）**，这意味着即使 **`Son`** 是 **`Father`** 的子类，**`ArrayList<Son>`** 也不是 **`ArrayList<Father>`** 的子类型，**`ArrayList<Father>`** 也不能接收**`ArrayList<Son>`** 类型的对象
- 我感觉它这个是如果完全出错，编译器才禁止



### 有原始数据类型

- Java语法上**允许泛型类型和原始类型之间的类型转换，不用刻意强转**

  ```java
  Box a1 = new Box();
  Box<String> b1 = new Box<>();
  
  Box a2 = (Box)b1;					//泛型类型->原始类型
  Box a3 = b1;						//不强转也对
  Box<String> b2 = (Box<String>)a1;	//原始类型->泛型类型
  Box<String> b3 = a1;				//不强转也对
  ```



### 无原始数据类型

#### 无通配符

- **泛型类型不可变，必须完全相同才能强制类型转换**

  ```java
  //Father是Son的父类
  ArrayList<Father> a1 = new ArrayList<>();
  ArrayList<Son>    b1 = new ArrayList<>();
  
  //下面如果不写强转依然错误，泛型类型不可变
  ArrayList<Father> a2 = (ArrayList<Father>)b1;		//编译错误：类型不兼容
  ArrayList<Son>    b2 = (ArrayList<Son>)   a1;		//编译错误：类型不兼容
  ```

#### 有通配符

- 无需多言，**一篇代码说明所有**

```java
public static void main(String[] args) {
    ArrayList<?>                c1 = new ArrayList<>();     //<?>
    ArrayList<? extends Father> c2 = new ArrayList<>();     //<? extends Father>
    ArrayList<? super Father>   c3 = new ArrayList<>();     //<? super Father>
    ArrayList<Object>           c4 = new ArrayList<>();     //<Object>
    ArrayList<Son>              c5 = new ArrayList<>();     //<Son>
    ArrayList<Father>           c6 = new ArrayList<>();     //<Father>

    ArrayList<?>                d1;
    d1=c1;          //<?>-><?>                   不报错，泛型类型相同
    d1=c2;          //<? extend Father>-><?>    ↑不报错，向上转型
    d1=c3;          //<? super  Father>-><?>    ↑不报错，向上转型
    d1=c4;          //<Object>-><?>             ↑不报错，向上转型
    d1=c5;          //<Son>-><?>                ↑不报错，向上转型
    d1=c6;          //<Father>-><?>             ↑不报错，向上转型

    ArrayList<? extends Father> d2;
    d2= (ArrayList<? extends Father>) c1;  //<?>-><? extend Father>               ↓不报错，向下转型
    d2=c2;                                 //<? extend Father>-><? extend Father>  不报错，泛型类型相同(同一协变)
    d2= (ArrayList<? extends Father>) c3;  //<? super Father>-><? extend Father>   不报错，泛型双向通配符逆向转换
    d2=c4;                                 //<Object>-><? extend Father>          ↑报错，反协变方向转换
    d2=c5;                                 //<Son>-><? extend Father>             ↑不报错，安全协变转换
    d2=c6;                                 //<Father>-><? extends Father>         ↑不报错，自身协变转换

    ArrayList<? super Father> d3;
    d3= (ArrayList<? super Father>) c1;    //<?>-><? super Father>                ↓不报错，向下转型
    d3= (ArrayList<? super Father>) c2;    //<? extend Father>-><? super Father>   不报错，泛型双向通配符逆向转换
    d3=c3;                                 //<? super Father>-><? super Father>    不报错，泛型类型相同(同一逆变)
    d3=c4;                                 //<Object>-><? super Father>           ↑不报错，安全逆变转换
    d3=c5;                                 //<Son>-><? super Father>              ↑报错，反逆变方向转换
    d3=c6;                                 //<Father>-><? super Father>           ↑不报错，自身逆变转换

    ArrayList<Object> d4;
    d4= (ArrayList<Object>) c1;           //<?>-><Object>                        ↓不报错，向下转型
    d4=c2;                                //<? extend Father>-><Object>          ↓报错，违反泛型不变性的非法转换
    d4= (ArrayList<Object>) c3;           //<? super Father>-><Object>           ↓不报错，类型擦除后的危险强制转换
    d4=c4;                                //<Object>-><Object>                    不报错，泛型类型相同
    d4=c5;                                //<Son>-><Object>                       报错，泛型类型不相同
    d4=c6;                                //<Father>-><Object>                    报错，泛型类型不相同

    ArrayList<Son> d5;
    d5= (ArrayList<Son>) c1;              //<?>-><Son>                           ↓不报错，向下转型
    d5= (ArrayList<Son>) c2;              //<? extend Father>-><Son>             ↓不报错，类型擦除后的危险强制转换
    d5=c3;                                //<? super Father>-><Son>              ↓报错，违反泛型不变性的非法转换
    d5=c4;                                //<Object>-><Son>                       报错，泛型类型不相同
    d5=c5;                                //<Son>-><Son>                          不报错，泛型类型相同
    d5=c6;                                //<Father>-><Son>                       报错，泛型类型不相同

    ArrayList<Father> d6;
    d6= (ArrayList<Father>) c1;        //<?>-><Father>                           ↓不报错，向下转型
    d6= (ArrayList<Father>) c2;       //<? extend Father>-><Father>              ↓不报错，类型擦除后的危险强制转换
    d6= (ArrayList<Father>) c3;       //<? super  Father>-><Father>              ↓不报错，类型擦除后的危险强制转换
    d6=c4;                            //<Object>-><Father>                        报错，泛型类型不相同
    d6=c5;                            //<Son>-><Father>                           报错，泛型类型不相同
    d6=c6;                            //<Father>-><Father>                        不报错，泛型类型相同
}
```

