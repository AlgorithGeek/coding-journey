# String

## 一. 认识 String

在 Java 后端开发中，`String` 是没有任何争议的“出场率第一”的类。我们在第一行代码 `System.out.println("Hello World")` 就用了它

### 1. String 的本质

#### 1.1 基本定义

在 Java 中，`String` 是一个**引用类型**，而不是像 `int`、`boolean` 那样的基本数据类型。 它位于 `java.lang` 包下，无需手动导入即可直接使用



#### 1.2 内部存储结构的演变

`String` 的本质是一个 **封装了数组的对象** 。这个底层数组的实现随 JDK 版本发生了重要变化：

- **JDK 8 及以前**：内部使用 `char[]` 数组存储

  - Java 中的 `char` 是 UTF-16 编码，固定占用 **2 个字节**
  - 即使存储纯英文字符 "abc"，也需要 6 个字节

  

- **JDK 9 及以后**：为了节省内存，改成了 `byte[]` 数组。

  - 引入了 **Compact Strings（压缩字符串）** 技术
  - 如果字符串只包含 Latin-1 字符（如英文、数字），每个字符只占 **1 个字节**
  - 如果包含中文等字符，则自动回退到 UTF-16 编码（2 个字节）
  - **意义**：对于大量使用 ASCII 字符的后端应用（如日志、JSON 数据），内存占用最高可减少 50%



### 2. String 的核心特性：不可变性

这是 String 最重要的特性，也是 Java 语言设计的精髓之一



#### 2.1 什么是不可变？

**一旦一个 String 对象在内存中被创建，它的内容就永远无法被修改**

String 类被 `final` 修饰，且内部的 `value` 数组也是 `private final` 的。这意味着没有对外提供任何修改内部数组的方法



#### 2.2 代码演示：修改的错觉

很多初学者会被下面的代码迷惑，以为 String 发生了变化：

```java
public class StringImmutability {
    public static void main(String[] args) {
        String str = "Hello";
        // 看起来好像修改了 str 的内容？
        str = str + " World"; 
        
        System.out.println(str); // 输出: Hello World
    }
}
```

**底层实际发生的步骤**：

1. 内存中创建了字符串对象 `"Hello"`
2. 执行 `str + " World"` 时，JVM **并没有** 修改原来的 `"Hello"` 对象
3. JVM 在内存中 **新建** 了一个对象 `"Hello World"`
4. 将变量 `str` 的引用（指针）指向了这个**新对象**
5. 原来的 `"Hello"` 对象依然存在于内存中（直到被垃圾回收之前）



#### 2.3 验证不可变性

我们可以通过引用传递来验证这一点：

```java
String s1 = "Hello";
String s2 = s1; // s2 也指向 "Hello" 对象

s1 = "World";   // 让 s1 指向新的字符串对象 "World"

// 如果 String 是可变的，那么 s2 应该也跟着变。
// 但实际上 s2 依然指向原对象 "Hello"
System.out.println(s2); // 输出: Hello
```



### 3. 为什么设计成不可变？

Java 语言设计者将 String 设计为不可变，主要基于以下三个核心考量，这也直接关系到实际开发中的安全与性能：

#### 3.1 线程安全

在并发环境（如 Spring Boot 处理高并发请求）下，共享可变对象需要复杂的同步机制（锁）来防止数据竞争

- 因为 `String` 不可变，**它是天然线程安全的**
- **优势**：多个线程可以安全地共享同一个 String 对象，完全不需要进行同步操作，性能极高



#### 3.2 安全性

String 常用来存储敏感的系统参数，例如：

- 数据库连接 URL
- 用户名和密码
- 文件系统路径
- 类加载器的类名

**场景**：

- 如果 String 是可变的，攻击者可能在通过安全检查后，修改字符串内容，导致访问非法路径或连接恶意数据库（即“时间检查/使用时间”漏洞）

  不可变性从语言层面杜绝了这种风险



#### 3.3 HashCode 缓存 (Performance)

`String` 经常被用作 `HashMap` 或 `HashSet` 的 Key

- String 类内部有一个 `hash` 字段用于缓存哈希值
- 因为内容不变，String 的哈希值（HashCode）只需要在第一次使用时计算一次，之后就可以 **直接使用缓存值**
- **优势**：这使得 String 作为 Map 的 Key 时性能非常优异（如 Redis 客户端、配置中心等场景）



### 4. 开发中的常见“陷阱”

#### 陷阱：在循环中拼接字符串

由于 String 的不可变性，每次拼接都会产生新对象

```java
// ❌ 绝对禁止的做法（性能杀手）
String str = "";
for (int i = 0; i < 1000; i++) {
    // 每次循环都会创建一个新的 String 对象（以及内部的数组对象）
    // 这里会产生 1000 个临时垃圾对象，给垃圾回收器（GC）造成巨大压力
    str += i; 
}
```

**最佳实践**： 凡是涉及 **循环拼接** 或 **大量拼接** 操作，必须使用 `StringBuilder`



## 二. 内存

在 Java 中，String 对象的创建和管理有着独特的机制

### 1. 什么是字符串常量池 (String Pool)？

**定义**： 字符串常量池是 Java 堆内存（Heap）中一个特殊的存储区域。你可以把它理解为 JVM 为了节省内存而专门设立的一个**“字符串缓存区”**

**核心机制**： 当你使用字面量（即双引号括起来的字符串）创建 String 时，JVM 会首先检查这个字符串在池中是否已经存在：

- **如果存在**：直接返回池中该对象的引用（地址），**不再创建新对象**
- **如果不存在**：先在池中创建一个新的 String 对象，然后返回它的引用

**目的**： 避免重复创建相同的字符串对象，极大节省内存空间



### 2. 两种创建方式的内存差异

#### 2.1 方式一：字面量赋值（推荐）

```java
String s1 = "Hello";
String s2 = "Hello";
```

**内存分析**：

1. 执行 `s1 = "Hello"`：JVM 查池，发现没有 "Hello"，于是创建一个 "Hello" 对象放入池中，并把引用给 s1
2. 执行 `s2 = "Hello"`：JVM 查池，发现已经有了 "Hello"，直接把池中那个对象的引用给 s2
3. **结果**：`s1` 和 `s2` 指向内存中的 **同一个地址**



#### 2.2 方式二：使用 new 关键字（不推荐）

```java
String s3 = new String("Hello");
```

**内存分析**： 不管常量池里有没有，`new` 关键字 **强制** 在堆内存（Heap）的非池区域创建一个全新的对象

- **结果**：`s3` 指向的是堆中那个新创建的“独立对象”，而不是池里的那个



#### `new String("abc")` 创建了几个对象？⭐

```java
String s = new String("abc");
```

**答案**：**1 个或 2 个**

- **1 个**：如果常量池中**已经存在** "abc"，那么只在堆中创建一个新对象
- **2 个**：如果常量池中**不存在** "abc"，那么:
  1. 先在常量池中创建一个 "abc"（作为模板）
  2. 再在堆中创建一个新的 String 对象（内容也是 "abc"）

> **最佳实践**：在 99% 的开发场景下，请直接使用字面量 `String s = "abc";`，既简洁又节省内存



#### 注意:关于其它创建`String`对象的方式

- 其实还有很多很多创建 `String` 的方式，但是不太重要，先不写



### 3. 比较的艺术：`==` 与 `equals`

#### 3.1 `==` 的本质

在 Java 中，对于引用类型（如 String），`==` 比较的是 **内存地址**

- 也就是问：“这两个是不是**同一个对象**？”



#### 3.2 `equals()` 的本质

String 重写了 `equals()` 方法，比较的是**字符串的内容**

- 也就是问：“这两个字符串长得**是不是一样**？”



#### 3.3 代码实战：深坑演示

```java
public class StringCompareTrap {
    public static void main(String[] args) {
        String s1 = "Hello";
        String s2 = "Hello";
        String s3 = new String("Hello");

        // 场景 1：字面量 vs 字面量
        // true，因为它们都指向常量池中的同一个对象
        System.out.println("s1 == s2: " + (s1 == s2)); 

        // 场景 2：字面量 vs new 对象
        // false！虽然内容一样，但 s3 在堆中，s1 在池中，地址不同
        System.out.println("s1 == s3: " + (s1 == s3)); 

        // 场景 3：正确做法
        // true，内容完全一样
        System.out.println("s1.equals(s3): " + s1.equals(s3)); 
    }
}
```



#### ⚠️ 避坑指南（重要）

- 在实际开发中（如判断用户输入的密码是否正确），**永远不要用 `==` 比较 String，永远只用 `equals()`**
  - 哪怕你确定这两个 String 都是字面量，也不要为了省事用 `==`，养成好习惯能帮你避开隐蔽的 Bug



### 4. 进阶方法：`intern()`

`intern()` 是一个本地方法（Native Method）

**作用**： 当调用 `s.intern()` 时：

1. 如果常量池中已经包含了等于此 String 对象的字符串，则返回池中的那个字符串
2. 否则，将此 String 对象添加到池中，并返回池中对象的引用



**代码示例**：

```java
String s1 = new String("Java"); // 指向堆
String s2 = s1.intern();        // 手动入池，返回池中引用

String s3 = "Java";             // 直接指向池

System.out.println(s1 == s2);   // false (堆 vs 池)
System.out.println(s2 == s3);   // true  (池 vs 池)
```

**使用场景**： 在现代后端开发中（如 Spring Boot），你几乎不需要手动调用这个方法

- **唯一用途**：

  - 当你从数据库或文件读取了 **大量重复** 的字符串（比如 100 万个用户记录，但省份只有几十个），

    为了节省内存，可以调用 `intern()` 来让所有“广东省”都共享同一个内存对象



## 三. 高频 API 与类型转换

### 3.0 最基本

#### 获取长度 (`length`)

- **方法**：`int length()`
- **作用**：返回字符串中字符的个数。
- **注意**：新手常混淆——数组是 `.length`（属性），List 是 `.size()`（方法），String 是 `.length()`（方法）

```java
String str = "Hello";
System.out.println(str.length()); // 5
```



#### 获取指定字符 (`charAt`)

- **方法**：`char charAt(int index)`
- **作用**：获取字符串第 `index` 个位置的字符（从 0 开始）
- **坑点**：如果索引超出了 `length() - 1`，抛出 `StringIndexOutOfBoundsException`

```java
String str = "Hello";
char c = str.charAt(1); // 'e'
// char fail = str.charAt(10); // 💥 报错
```







### 3.1 基础操作：判空校验与空白处理

在处理用户输入或外部接口数据时，"判空"和"去空格"是两项最基础的前置工作

#### 1. 判空校验

**概念区分**：

- **`null`**：表示没有对象，引用指向空（内存中不存在堆空间）
- **`""` (Empty)**：表示有对象，但是长度为 0（内存中存在堆空间）
- **`"   "` (Blank)**：表示有对象，长度不为 0，但内容全是空格、制表符等不可见字符

**常用方法对比**：

| 方法        | JDK版本    | 作用                                                | 示例 (" ")                    |
| ----------- | ---------- | --------------------------------------------------- | ----------------------------- |
| `isEmpty()` | JDK 6      | 仅判断 `length() == 0`                              | 返回 `false` (空格是有长度的) |
| `isBlank()` | **JDK 11** | 判断是否为 **null**、**空串** 或 **仅包含空白字符** | 返回 `true` (推荐)            |



**实战代码示例**：

```java
public class StringCheckDemo {
    public static void main(String[] args) {
        String str1 = null;
        String str2 = "";
        String str3 = "   "; // 包含空格

        // ❌ 错误示范：直接调用方法会导致空指针异常 (NPE)
        // if (str1.isEmpty()) { ... } // 抛出 NullPointerException

        // ✅ 传统写法 (JDK 6+)
        // 必须先判断 != null，利用短路与特性
        if (str1 != null && str1.isEmpty()) {
            System.out.println("str1 是空串");
        }

        // ✅ 现代写法 (JDK 11+) —— 推荐！
        // isBlank() 能识别并过滤掉全是空格的情况，非常适合表单校验
        // 注意：这里 str3 不为 null，所以可以直接调，但为了安全建议配合 null 检查
        if (str3 != null && str3.isBlank()) {
            System.out.println("str3 是空白字符串（用户可能只敲了空格）");
        }
    }
}
```

> **最佳实践**：在实际项目（如 Spring Boot）中，我们通常使用工具类来避免手动写 `!= null`
>
> - 推荐：`org.apache.commons.lang3.StringUtils.isBlank(str)` —— 即使传入 `null` 也不会报错，直接返回 `true`
> - 推荐：`org.springframework.util.StringUtils.hasText(str)` —— Spring 自带工具



#### 2. 去除两侧空白

当用户手滑多输入了前后空格时，我们需要进行清理

**常用方法对比**：

| 方法      | JDK版本    | 作用         | 说明                                                |
| --------- | ---------- | ------------ | --------------------------------------------------- |
| `trim()`  | JDK 1.0    | 去除首尾空白 | 只能去除 ASCII 码 <= 32 的字符（传统空格）          |
| `strip()` | **JDK 11** | 去除首尾空白 | **智能去除所有 Unicode 空白**（包括中文全角空格等） |

**实战代码示例**：

```java
public class StringTrimDemo {
    public static void main(String[] args) {
        // 场景：包含全角空格（\u3000）的字符串
        String dirtyStr = "\u3000Hello World\u3000"; 

        // 1. 使用 trim() - 无法去除全角空格
        System.out.println("trim结果: [" + dirtyStr.trim() + "]");
        // 输出: [　Hello World　] (空格还在)

        // 2. 使用 strip() - 推荐
        System.out.println("strip结果: [" + dirtyStr.strip() + "]");
        // 输出: [Hello World] (干净了)
        
        // 3. 变体方法
        String s = "  Hello  ";
        System.out.println(s.stripLeading());  // "Hello  " (只去头)
        System.out.println(s.stripTrailing()); // "  Hello" (只去尾)
    }
}
```



#### ⚠️ 避坑指南

1. **NPE 陷阱**：

   - 无论是 `isEmpty()` 还是 `trim()`，如果你对一个 `null` 对象调用它们，程序会直接崩溃（抛出 `NullPointerException`）

     **永远确信变量不为 null 后再调用这些实例方法**

2. **`trim()` 的局限**：

   - 在处理国际化业务或包含特殊空白字符的数据时，老旧的 `trim()` 可能会失效，导致数据清洗不干净。**建议全面拥抱 `strip()`**



### 3.2 精准定位：查找与截取操作

在解析文件路径、URL 或处理特定格式的文本时，我们需要先“找到”目标，然后再把它“切”出来

#### 1. 查找操作

这类方法用于判断字符串中是否包含某些内容，或者获取内容所在的位置

##### 常用方法一览

| 方法                 | 作用                             | 返回值    | 说明                             |
| -------------------- | -------------------------------- | --------- | -------------------------------- |
| `contains(s)`        | 判断是否包含指定子串             | `boolean` | **最常用的检查方法**             |
| `startsWith(prefix)` | 判断是否以指定前缀开头           | `boolean` | 常用于 URL 协议判断 (http/https) |
| `endsWith(suffix)`   | 判断是否以指定后缀结尾           | `boolean` | 常用于文件扩展名判断 (.jpg/.png) |
| `indexOf(str)`       | 查找子串 **第一次** 出现的索引   | `int`     | 找不到返回 `-1`                  |
| `lastIndexOf(str)`   | 查找子串 **最后一次** 出现的索引 | `int`     | 找不到返回 `-1`                  |

##### 实战代码示例

```java
public class StringSearchDemo {
    public static void main(String[] args) {
        String filename = "report_2024.final.pdf";
        String url = "[https://www.google.com](https://www.google.com)";

        // 1. 布尔检查 (Boolean Check)
        if (url.startsWith("https")) {
            System.out.println("这是一个安全链接");
        }
        
        if (filename.endsWith(".pdf")) {
            System.out.println("这是一个 PDF 文档");
        }
        
        if (filename.contains("2024")) {
            System.out.println("这是2024年的报告");
        }

        // 2. 位置查找 (Index Finding)
        // 场景：我们需要获取文件扩展名，需要先找到最后一个 "." 的位置
        
        int dotIndex = filename.lastIndexOf("."); 
        System.out.println("最后一个点的位置: " + dotIndex); // 17
        
        int firstUnderline = filename.indexOf("_");
        System.out.println("第一个下划线的位置: " + firstUnderline); // 6
        
        // 3. 找不到的情况
        int notFound = filename.indexOf("xyz");
        System.out.println("找不到返回: " + notFound); // -1
    }
}
```



#### 2. 截取操作

找到位置后，我们通常需要把那一部分字符串提取出来

##### 核心方法：`substring`

| 方法签名                        | 作用                               | 记忆口诀                            |
| ------------------------------- | ---------------------------------- | ----------------------------------- |
| `substring(int begin)`          | 从 `begin` 开始截取到 **最后**     | "从这开始，全都要"                  |
| `substring(int begin, int end)` | 截取从 `begin` 到 `end` 之间的字符 | **"左闭右开"** (包含左边，不含右边) |

##### 重点图解："左闭右开"原则

这是 Java API 设计的通用原则（在 List.subList 等地方也适用）。 调用 `substring(1, 4)` 时：

```java
索引:   0   1   2   3   4   5
字符:   H   e   l   l   o   !
            ↑           ↑
          begin        end
          (包含)      (不含)

结果:   "ell" (长度 = end - begin = 4 - 1 = 3)
```



##### 实战代码示例

```java
public class StringSubDemo {
    public static void main(String[] args) {
        String text = "Hello World";

        // 1. 截取到末尾
        // 从索引 6 (W) 开始一直到最后
        String sub1 = text.substring(6); 
        System.out.println(sub1); // "World"

        // 2. 截取中间一段 (左闭右开)
        // 范围 [0, 5)，即索引 0,1,2,3,4
        String sub2 = text.substring(0, 5); 
        System.out.println(sub2); // "Hello"

        // 3. 结合 indexOf 实战：提取文件扩展名
        String file = "data.tar.gz";
        int lastDot = file.lastIndexOf(".");
        
        if (lastDot != -1) {
            // 从最后一个点之后的一个字符开始截取
            String ext = file.substring(lastDot + 1);
            System.out.println("扩展名: " + ext); // "gz"
        }
    }
}
```



##### ⚠️ 避坑指南：索引越界

`substring` 是极其严格的方法，一旦索引计算错误，会直接抛出 **`StringIndexOutOfBoundsException`**，导致程序崩溃

**常见的错误场景**：

1. `begin` 小于 0
2. `end` 大于字符串长度
3. `begin` 大于 `end`

**安全开发的写法**：

```java
public String safeSubstring(String str, int len) {
    if (str == null) return null;
    // 必须检查长度，防止越界
    if (str.length() <= len) {
        return str;
    }
    return str.substring(0, len);
}
```





### 3.3 内容变形：替换与正则处理

很多开发者（包括一些有经验的）都会在“替换”这个操作上栽跟头。我们先纠正一个核心概念

#### 1. 核心误区：replace vs replaceAll

请大声朗读三遍以下结论：

> **`replace()` 替换的是“所有”字符，不是“第一个”！** **`replace()` 替换的是“所有”字符，不是“第一个”！** **`replace()` 替换的是“所有”字符，不是“第一个”！**



**方法深度对比**

| 方法             | 参数类型          | 是否支持正则 | 作用范围            | 性能       | 推荐场景                 |
| ---------------- | ----------------- | ------------ | ------------------- | ---------- | ------------------------ |
| **`replace`**    | `String` (字面量) | ❌ **否**     | **所有** 匹配项     | ⭐⭐⭐⭐⭐ (高) | 普通字符串替换（首选）   |
| **`replaceAll`** | `String` (正则)   | ✅ **是**     | **所有** 匹配项     | ⭐⭐⭐ (低)   | 需要复杂规则（如去数字） |
| `replaceFirst`   | `String` (正则)   | ✅ **是**     | **仅第一个** 匹配项 | ⭐⭐⭐        | 特殊需求                 |



#### 2. `replaceXXX`实战代码演示

##### 场景一：普通替换（请只用 replace）

如果我们只是把 "a" 换成 "b"，千万别用 `replaceAll`，那是杀鸡用牛刀

```java
public class StringReplaceDemo {
    public static void main(String[] args) {
        String text = "Java is good, Java is nice";

        // ❌ 误区：很多人以为 replace 只换第一个
        // ✅ 事实：它把所有的 "Java" 都换成了 "Python"
        // 这里的参数是普通字符串，不涉及正则引擎，速度极快
        String res1 = text.replace("Java", "Python");
        
        System.out.println(res1); 
        // 输出: "Python is good, Python is nice"
    }
}
```



##### 场景二：正则替换（必须用 replaceAll）

如果我们需要把字符串里的“所有数字”都去掉，这时候普通的 `replace` 就无能为力了

```java
public class RegexReplaceDemo {
    public static void main(String[] args) {
        String msg = "User123Login456Success";

        // 需求：去掉所有数字
        // regex: \\d 代表数字
        String pureText = msg.replaceAll("\\d", "");
        
        System.out.println(pureText); 
        // 输出: "UserLoginSuccess"
        
        // 场景：敏感词脱敏 (把手机号中间4位换成 *)
        String phone = "13812345678";
        // 正则分组替换（高级用法）
        // $1 代表第1组，**** 替换第2组，$3 代表第3组
        String safePhone = phone.replaceAll("(\\d{3})\\d{4}(\\d{4})", "$1****$2");
        
        System.out.println(safePhone);
        // 输出: "138****5678"
    }
}
```



#### 3. 正则校验 (`matches`)

- **方法**：`boolean matches(String regex)`
- **作用**：判断**整个**字符串是否匹配给定的正则表达式
- **场景**：校验手机号、邮箱

```java
String phone = "13800138000";
// 简单校验：是否是 11 位数字
if (phone.matches("\\d{11}")) {
    System.out.println("手机号格式正确");
}
```





#### 4. 性能陷阱与最佳实践

##### 为什么不建议乱用 `replaceAll`？

- `replaceAll` 的底层会编译正则表达式（`Pattern.compile`），这是一个非常重的操作
  - 如果你只是想把 `.` 替换成 `/`，却写成了 `str.replaceAll(".", "/")`：
    1. **Bug**：因为 `.` 在正则里代表“任意字符”，结果你的整个字符串都会变成 `///////`
    2. **慢**：即使你转义写对了 `replaceAll("\\.", "/")`，它的速度也比 `replace(".", "/")` 慢很多倍



### 3.4 分割与合并：数组交互的重灾区

在处理 CSV 文件、日志数据或前端传来的长字符串时，我们经常需要在“字符串”和“数组/集合”之间来回转换

#### 1. 字符串分割 (Split)

`split` 的作用是根据指定的规则，将一个长字符串“切”成多个子串，并放入数组中

##### 1.1 基础方法详解

**方法签名**： `public String[] split(String regex)`

**参数说明**：

- **regex** (Regular Expression)：**正则表达式**。这是分割的规则（比如逗号 `,`、空格 `\s` 等）
  - *注意*：因为是正则，所以特殊字符（如 `.` `|` `*`）需要转义



**基本行为演示**：

```java
String str = "Java,Python,Go";
// 使用逗号分割
String[] result = str.split(","); 
// 结果: ["Java", "Python", "Go"] (长度为3)
```



##### 1.2 进阶方法：控制分割模式

这是很多开发者容易忽略的重载方法，它决定了 **是否保留末尾的空内容**

**方法签名**： `public String[] split(String regex, int limit)`

**参数 limit 详解**：

- **limit > 0**：**限制分割份数**。最多切成 `limit` 个数组元素
- **limit = 0** (默认行为)：**丢弃末尾的空字符串**
- **limit < 0** (通常用 -1)：**保留所有空字符串**（包括末尾的）



##### 1.3 实战代码：默认模式 vs 保留模式

```java
import java.util.Arrays;

public class SplitDemo {
    public static void main(String[] args) {
        // 场景：CSV数据，模拟末尾有空值的情况 "a,b,,"
        String data = "a,b,,";
        
        // 1. 默认模式 (limit = 0)
        // 行为：尾部的空字符串会被“无情丢弃”
        String[] res1 = data.split(",");
        System.out.println("默认结果: " + Arrays.toString(res1));
        System.out.println("数组长度: " + res1.length);
        // 输出: [a, b] (长度2) —— 后面两个空串没了！
        
        // 2. 保留模式 (limit = -1) —— 【推荐安全写法】
        // 行为：不管末尾是不是空的，全都要
        String[] res2 = data.split(",", -1);
        System.out.println("保留结果: " + Arrays.toString(res2));
        System.out.println("数组长度: " + res2.length);
        // 输出: [a, b, , ] (长度4) —— 安全保留
    }
}
```



##### 1.4 常见陷阱：正则转义

由于参数是正则表达式，如果分隔符是正则中的特殊字符，必须使用 `\\` 转义

| 分隔符   | 错误写法     | 正确写法       | 说明                       |
| -------- | ------------ | -------------- | -------------------------- |
| 点号 `.` | `split(".")` | `split("\\.")` | `.` 在正则代表任意字符     |
| 竖线 `|` | `split("|")` | `split("\\|")` |                            |
| 加号 `+` | `split("+")` | `split("\\+")` | `+` 在正则代表“一次或多次” |



#### 2. 字符串合并 (Join)

`join` 是 `split` 的逆操作，用于将数组或集合拼接成一个字符串

##### 2.1 基础方法详解 (Java 8+)

**方法签名**： 

- `public static String join(CharSequence delimiter, CharSequence... elements)` 

- `public static String join(CharSequence delimiter, Iterable<? extends CharSequence> elements)`



**参数说明**：

- **delimiter**：**分隔符**（连接每项中间的符号，如 `,` 或 `-`）
- **elements**：需要合并的数据源，可以是 **数组**、**可变参数** ，也可以是 **List/Set** 集合



**优点**：

- 自动处理分隔符：**只在元素之间加**，不会在开头或结尾多加一个（完美解决了以前 `for` 循环拼接时末尾多一个逗号的问题）



##### 2.2 实战代码：告别循环拼接

```java
import java.util.Arrays;
import java.util.List;

public class JoinDemo {
    public static void main(String[] args) {
        // 1. 合并数组/可变参数
        // 场景：拼接日期 "2023-11-26"
        String date = String.join("-", "2023", "11", "26");
        System.out.println(date); // 输出: 2023-11-26
        
        // 2. 合并集合 (List -> String) —— 开发中最常用！
        // 场景：拼接 SQL 查询条件 "Alice, Bob, Charlie"
        List<String> names = Arrays.asList("Alice", "Bob", "Charlie");
        
        String csv = String.join(", ", names);
        System.out.println(csv); 
        // 输出: Alice, Bob, Charlie
        // (注意：Charlie 后面没有多余的逗号，非常完美)
    }
}
```



#### 3.另一种拼接 (`concat`)

- **方法**：`String concat(String str)`
- **作用**：将参数拼接到当前字符串后面
- **对比 `+` 号**：
  - `+` 号：支持 `null`（变成 "null" 字符串），支持任意类型（自动转 String）
  - `concat`：**不支持 `null`**（报空指针），只能拼接 String 类型
  - **结论**：**绝大多数情况我们直接用 `+` 或者 `StringBuilder`**，`concat` 在实际业务中用得非常少，除非你极其在意那一点点微小的性能差异且确定不为 null

```java
String s1 = "Hello";
String s2 = s1.concat(" World"); // "Hello World"
```



#### 小结

1. **Split 时**：
   - 如果处理的数据可能包含空值（如 CSV 文件解析），**请务必习惯加上 `-1` 参数**：`str.split(",", -1)`
   - 如果按特殊符号（`.` `|` `*`）分割，**请务必加上转义**：`str.split("\\.")`。
2. **Join 时**：
   - 只要是拼接，优先使用 `String.join()`，代码简洁且不易出错



### 3.5 转换

在后端开发中，数据通常以 JSON 或数据库查询结果的形式出现。我们经常需要把“数字”转成“字符串”展示，或者把用户提交的“字符串”转成“数字”进行计算。

#### 1. 其他类型 转 String

将对象或基本类型转换为字符串，有三种常见方式，但推荐度大不相同

##### 常用方式对比

| 方式                   | 代码示例              | 安全性 (对 null) | 推荐指数 | 评价                                                         |
| ---------------------- | --------------------- | ---------------- | -------- | ------------------------------------------------------------ |
| **`String.valueOf()`** | `String.valueOf(obj)` | ✅ **安全**       | ⭐⭐⭐⭐⭐    | **首选**。如果是 `null`，它会返回字符串 `"null"`，不会报错   |
| `toString()`           | `obj.toString()`      | ❌ **不安全**     | ⭐⭐       | 如果 `obj` 是 `null`，直接抛 `NullPointerException`          |
| **字符串拼接**         | `"" + obj`            | ✅ **安全**       | ⭐⭐       | “野路子”<br />底层会创建 StringBuilder，稍微有一点点性能损耗，且代码看起来不够专业 |



##### 实战代码：空指针防御

```java
public class ToStringDemo {
    public static void main(String[] args) {
        Object obj = null;

        // ❌ 错误示范：直接调用 toString()
        // System.out.println(obj.toString()); // 💥 崩溃！NullPointerException

        // ✅ 最佳实践：使用 String.valueOf()
        // 它内部自动做了判空：return (obj == null) ? "null" : obj.toString();
        String safeStr = String.valueOf(obj);
        System.out.println("结果: " + safeStr); // 输出字符串 "null"
        
        // 场景：基本数据类型转换
        String numStr = String.valueOf(100);   // "100"
        String boolStr = String.valueOf(true); // "true"
    }
}
```



#### 2. String 转 基本类型

将字符串解析为数字，这是表单提交处理的必经之路

##### 核心方法

- **转整数**：`Integer.parseInt(str)`
- **转长整数**：`Long.parseLong(str)`
- **转浮点数**：`Double.parseDouble(str)`
- **转布尔**：`Boolean.parseBoolean(str)`



##### 巨坑：NumberFormatException

这些 `parse` 方法只要一旦字符串格式不对（比如包含字母、或者为空），会直接抛出 `NumberFormatException`

```java
public class ParseDemo {
    public static void main(String[] args) {
        // ✅ 正常转换
        String ageStr = "25";
        int age = Integer.parseInt(ageStr);
        System.out.println("年龄: " + age);

        // ❌ 异常场景 1：包含非数字字符
        try {
            int num = Integer.parseInt("25岁"); // 💥 格式不对
        } catch (NumberFormatException e) {
            System.err.println("解析失败：输入包含非数字字符");
        }

        // ❌ 异常场景 2：空字符串或 null
        // Integer.parseInt(null); // 💥 NumberFormatException
        // Integer.parseInt("");   // 💥 NumberFormatException
    }
}
```



##### 特殊技巧：安全的 Boolean 转换

`Boolean.parseBoolean(str)` 是个特例，它 **永远不会抛异常**

- 如果你传 "true" (忽略大小写)，返回 `true`
- 如果你传 `null`、""、"abc"、"123"，它统统返回 `false`

```java
boolean b1 = Boolean.parseBoolean("True"); // true
boolean b2 = Boolean.parseBoolean(null);   // false (安全！)
boolean b3 = Boolean.parseBoolean("yes");  // false
```



#### 3. String 转 数组

##### 3.1 转字符数组 (char[])

用于算法题或需要手动处理每个字符的场景

```java
String str = "Hello";
char[] chars = str.toCharArray(); 
// ['H', 'e', 'l', 'l', 'o']
```



##### 3.2 转字节数组 (byte[]) —— 乱码之源

用于 IO 流传输、加密解密。**必须显式指定字符集！**

```java
import java.nio.charset.StandardCharsets;

public class BytesDemo {
    public static void main(String[] args) {
        String str = "中文";

        // ❌ 不推荐：使用系统默认编码（Windows默认GBK，Linux默认UTF-8，导致乱码）
        byte[] risky = str.getBytes(); 

        // ✅ 最佳实践：强制指定 UTF-8
        byte[] safe = str.getBytes(StandardCharsets.UTF_8);
        System.out.println("字节数: " + safe.length); // UTF-8中，中文通常占3字节
    }
}
```



#### 4. 大小写转换

处理用户输入的验证码、搜索关键词时，通常需要统一转成大写或小写

##### 核心方法

- **`toUpperCase()`**：转全大写
- **`toLowerCase()`**：转全小写



##### 实战代码与 Locale 陷阱

```java
public class CaseDemo {
    public static void main(String[] args) {
        String input = "Java Hello";

        // 1. 转大写
        System.out.println(input.toUpperCase()); // "JAVA HELLO"

        // 2. 转小写
        System.out.println(input.toLowerCase()); // "java hello"

        // 3. ⚠️ 国际化陷阱 (Locale)
        // 在土耳其语 (tr) 环境下，"i" 的大写不是 "I"，而是 "İ"
        // 如果你的代码运行在多语言服务器上，建议强制指定 Locale.ROOT 或 English
        // System.out.println("title".toUpperCase(Locale.ROOT)); 
    }
}
```



### 3.6 字符串比较

#### `equals`最基本

- **铁律**：永远使用 `equals()`，不要使用 `==`（`==` 比较的是地址）
- **防坑**：常量写前面，如 `"admin".equals(input)`，防止 input 为 null 报错。



#### 其它

##### 方法签名

- **`equalsIgnoreCase(String another)`**：忽略大小写判断内容是否相等（比如验证码）
- **`compareTo(String another)`**：按字典顺序比较
  - 返回 `0`：相等
  - 返回 `负数`：当前字符串 < 参数字符串（排在前面）
  - 返回 `正数`：当前字符串 > 参数字符串（排在后面）
- **`compareToIgnoreCase(String another)`**：忽略大小写的字典序比较

##### 实战代码

```java
public class CompareDemo {
    public static void main(String[] args) {
        String s1 = "admin";
        String s2 = "ADMIN";

        // 1. 忽略大小写相等 (常用于验证码、用户名)
        if (s1.equalsIgnoreCase(s2)) {
            System.out.println("用户名匹配成功！");
        }

        // 2. 字典排序 (compareTo)
        String a = "apple";
        String b = "banana";
        
        // 'a' 在 'b' 前面，所以结果是负数
        System.out.println(a.compareTo(b)); // 输出 -1 (或其他负数)
        
        // 场景：List 排序
        // names.sort((x, y) -> x.compareTo(y)); 
    }
}
```





### 3.7 字符串格式化

拼接复杂字符串（如日志、提示信息）时，用 `+` 号非常丑陋且难以阅读，`format` 是最佳替代方案



#### 核心方法

- **`String.format(String format, Object... args)`**：静态方法，类似 C 语言的 printf
- **`formatted(Object... args)`**：**Java 15+** 新增的实例方法，更链式、更现代



#### 占位符速查

- `%s`：字符串 (String)
- `%d`：整数 (Digit)
- `%.2f`：浮点数 (保留2位小数)



#### 实战代码

```java
public class FormatDemo {
    public static void main(String[] args) {
        String name = "Alice";
        int score = 95;
        double price = 19.9;

        // 1. 传统静态方法 (所有版本可用)
        String msg1 = String.format("学生 %s 的分数是 %d", name, score);
        System.out.println(msg1); 
        // 输出: 学生 Alice 的分数是 95

        // 2. 金额格式化 (保留两位小数)
        String msg2 = String.format("价格：%.2f 元", price);
        System.out.println(msg2); 
        // 输出: 价格：19.90 元

        // 3. 现代写法 (Java 15+) —— 推荐！
        // 直接在字符串对象上调用 formatted
        String msg3 = "欢迎 %s，今天是第 %d 天".formatted(name, 1);
        System.out.println(msg3);
    }
}
```



### 3.8 彩蛋方法(JDK11+)

虽然简单，但在特定场景下能少写很多代码

- **`repeat(int count)`**：将字符串重复 `count` 次
  - **场景**：生成分割线、Mock 测试数据

```java
// 生成一条分割线
String line = "-".repeat(10); 
System.out.println(line); // "----------"

// 生成 Mock 数据
String mockData = "abc".repeat(3); 
System.out.println(mockData); // "abcabcabc"
```





## 四. StringBuilder 与拼接优化

在 Java 后端开发中，字符串拼接是出现频率极高的操作。但因为 String 的“不可变”特性，错误的拼接方式可能会导致程序性能下降几百倍，甚至引发内存溢出（OOM）。

### 4.1 性能杀手：`+` 号

#### 1. 场景还原：循环中的拼接

这是新手最容易犯的错误：在 `for` 或 `while` 循环中使用 `+` 号拼接字符串

```java
public class StringPerformanceDemo {
    public static void main(String[] args) {
        long start = System.currentTimeMillis();
        
        String str = "";
        // ❌ 绝对禁止：在循环中直接使用 + 拼接
        for (int i = 0; i < 50000; i++) {
            str += i; 
        }
        
        long end = System.currentTimeMillis();
        System.out.println("耗时: " + (end - start) + " ms");
    }
}
```

**运行结果预估**： 这段代码在普通电脑上运行，可能需要 **3000ms ~ 5000ms**（3-5秒）。 你可能觉得 5 秒也能接受？别急，看下面



#### 2. 原理揭秘：发生了什么？

为什么这么慢？这要回溯到 String 的 **不可变性**

当你执行 `str += i` 时，JVM 并不是在原字符串后面直接追加字符，而是经历了以下 **繁琐的步骤** ：

1. 创建一个**新**的 `StringBuilder` 对象
2. 将旧的 `str` 内容 append 进去
3. 将新的 `i` 内容 append 进去
4. 调用 `toString()` 方法，**创建一个新**的 String 对象
5. 将 `str` 指向这个新对象
6. **扔掉** 旧的 `str` 对象和中间产生的 `StringBuilder` 对象（等待垃圾回收）

**后果**：

- 循环 50000 次，就创建了 50000 个临时的 `StringBuilder` 对象和 50000 个临时的 `String` 对象
- 内存中充斥着大量的垃圾对象，导致 GC（垃圾回收器）频繁工作，CPU 狂转，性能雪崩

#### 3. 正确写法：StringBuilder

如果我们把工具换成 `StringBuilder`，奇迹就发生了

```java
public class StringBuilderDemo {
    public static void main(String[] args) {
        long start = System.currentTimeMillis();
        
        // ✅ 最佳实践：使用 StringBuilder
        StringBuilder sb = new StringBuilder();
        for (int i = 0; i < 50000; i++) {
            sb.append(i);
        }
        String str = sb.toString();
        
        long end = System.currentTimeMillis();
        System.out.println("耗时: " + (end - start) + " ms");
    }
}
```

**运行结果预估**： 耗时通常在 **2ms ~ 5ms** 之间

**性能对比**：

- 错误写法：4000ms
- 正确写法：4ms
- **差距：1000 倍！**

#### 结论

> **铁律**：凡是涉及**循环拼接**或**大量拼接**操作，必须显式使用 `StringBuilder`。`+` 号拼接仅限于非循环的简单场景（如 `String s = "a" + "b"`，这种编译器会优化，后面会讲）。



### 4.2 StringBuilder 核心 API 与用法

`StringBuilder` 是 Java 为了解决 String 拼接性能问题而专门提供的类。它就像一个**可变的容器**，你可以往里面扔各种数据，最后再一次性取出来



##### 增

这是 `StringBuilder` 存在的意义：高效地构建字符串

###### 1. 追加 (append)

**作用**：将内容添加到当前字符序列的**末尾**。 **特点**：

- 提供了海量的重载方法（支持 `int`, `char`, `boolean`, `String`, `Object` 等几乎所有类型）
- **链式调用**：方法返回 `this`（当前对象），支持连续调用

| 方法签名             | 描述                      | 示例                      |
| -------------------- | ------------------------- | ------------------------- |
| `append(String str)` | 追加字符串                | `sb.append("Hello")`      |
| `append(int i)`      | 追加整数                  | `sb.append(123)`          |
| `append(char c)`     | 追加单个字符              | `sb.append('A')`          |
| `append(Object obj)` | 追加对象 (调用其 valueOf) | `sb.append(new Object())` |

**实战代码**：

```java
StringBuilder sb = new StringBuilder();

// 链式调用：一气呵成
sb.append("Name: ")
  .append("Alice")
  .append(", Age: ")
  .append(25);

System.out.println(sb); // "Name: Alice, Age: 25"
```



###### 2. 插入 (insert)

**作用**：将内容插入到指定**索引位置**（index）。 **注意**：索引从 0 开始。如果索引等于 `length()`，则相当于 `append`

| 方法签名                         | 描述                 | 示例 (假设 sb="Hello") | 结果            |
| -------------------------------- | -------------------- | ---------------------- | --------------- |
| `insert(int offset, String str)` | 在指定位置插入字符串 | `sb.insert(1, "aa")`   | "H**aa**ello"   |
| `insert(int offset, int i)`      | 在指定位置插入数字   | `sb.insert(5, 2024)`   | "Hello**2024**" |



**实战代码**：

```java
StringBuilder sb = new StringBuilder("HelloWorld");

// 在 "Hello" 和 "World" 中间插入空格
// "Hello" 的长度是 5，所以从索引 5 开始插入
sb.insert(5, " "); 

System.out.println(sb); // "Hello World"
```

> **性能提示**：`append` 是 O(1) 操作（不考虑扩容），非常快；而 `insert` 需要移动数组中的后续元素，是 O(N) 操作。**能用 append 就别用 insert**



##### 删

在拼接字符串的过程中，我们经常会遇到“多拼了一个字符”或者“写错了一段内容”的情况，这时候就需要用到“删”的操作

###### 1. 基础方法详解

`StringBuilder` 提供了两个删除方法，分别用于删除“一段”和删除“一个”

| 方法签名                         | 描述                   | 示例 (假设 sb="012345") | 结果    |
| -------------------------------- | ---------------------- | ----------------------- | ------- |
| **`delete(int start, int end)`** | 删除指定区间的字符     | `sb.delete(2, 4)`       | "0145"  |
| **`deleteCharAt(int index)`**    | 删除指定位置的单个字符 | `sb.deleteCharAt(2)`    | "01345" |

**注意**

`delete(start, end)` 同样遵循 Java 通用的 **“左闭右开”** `[start, end)` 原则

- `start`: 起始索引（包含）
- `end`: 结束索引（不包含）
- **示例**：`sb.delete(2, 4)` 实际上删除的是索引为 `2` 和 `3` 的字符



###### 2. 实战场景：移除循环末尾多余的逗号

这是后端开发中拼接 JSON、SQL 或者 CSV 数据时最经典的操作。我们经常在循环里 `append(item).append(",")`，结果导致字符串最后多了一个讨厌的逗号



**❌ 笨办法：判断是否是最后一个元素**

```java
StringBuilder sb = new StringBuilder();
for (int i = 0; i < list.size(); i++) {
    sb.append(list.get(i));
    // 每次都要判断是不是最后一个，代码啰嗦且效率略低
    if (i < list.size() - 1) {
        sb.append(",");
    }
}
```



**✅ 优雅办法：先拼再删**

直接无脑拼逗号，循环结束后，一刀砍掉最后一个字符。这种写法代码更简洁，逻辑更清晰

```java
public class DeleteDemo {
    public static void main(String[] args) {
        StringBuilder sb = new StringBuilder();
        
        // 模拟循环拼接
        for (int i = 0; i < 3; i++) {
            sb.append(i).append(",");
        }
        // 此时 sb 的内容是 "0,1,2," —— 注意最后多了一个逗号
        
        // 【核心操作】删除最后一个字符
        if (sb.length() > 0) { // 也就是防止 sb 本身为空导致越界
             sb.deleteCharAt(sb.length() - 1);
        }
       
        System.out.println(sb); // 输出: "0,1,2"
    }
}
```

> **最佳实践**：
>
> 1. 在处理类似拼接任务时，优先考虑 `deleteCharAt` 来处理尾部字符
> 2. 调用前最好判断 `length() > 0`，防止空字符串导致 `StringIndexOutOfBoundsException`



##### 查

`StringBuilder` 提供了类似 `String` 的查询方法，让我们在拼接过程中能随时获取当前的“状态”或“内容”

###### 1. 基础查询方法

这些方法与 `String` 类几乎一模一样，学习成本极低

| 方法签名                  | 描述                       | 示例 (假设 sb="Hello") | 结果 |
| ------------------------- | -------------------------- | ---------------------- | ---- |
| **`length()`**            | 获取当前字符个数           | `sb.length()`          | 5    |
| `charAt(int index)`       | 获取指定位置字符           | `sb.charAt(1)`         | 'e'  |
| `indexOf(String str)`     | 查找子串第一次出现的位置   | `sb.indexOf("l")`      | 2    |
| `lastIndexOf(String str)` | 查找子串最后一次出现的位置 | `sb.lastIndexOf("l")`  | 3    |



###### 2. 截取内容 —— ⚠️ 易错点

这是 `StringBuilder` 中最容易产生误解的方法



**方法签名**：

- `String substring(int start)`
- `String substring(int start, int end)`



**⚠️ 核心坑点**： 

- `StringBuilder` 的大多数方法（如 `append`, `insert`, `delete`, `reverse`）都会 **改变** `StringBuilder` 自身的内容

  **但是！** `substring` 方法 **不会改变** `StringBuilder` 自身，它只是把截取的结果作为一个新的 `String` 对象返回



❌ **错误写法**

```java
StringBuilder sb = new StringBuilder("012345");
// 很多新手以为这行代码会把 sb 变成 "23"
sb.substring(2, 4); 

System.out.println(sb); 
// 输出: "012345" —— sb 根本没变！因为你没接收返回值
```



✅ **正确写法**

```java
StringBuilder sb = new StringBuilder("012345");

// 必须用一个 String 变量去接收它的返回值
String sub = sb.substring(2, 4);

System.out.println(sub); // 输出: "23"
System.out.println(sb);  // 输出: "012345" (原对象保持原样)
```

> **总结**： 如果你想**修改**自身，请用 `delete`。 如果你只想**读取**一段内容而不改变自身，请用 `substring`。



##### 改

- 除了追加和删除，我们经常需要修改字符串中间的某个内容，或者对整个字符串进行变换

###### 1. 局部修改

- 这两个方法用于修改字符串中的某一部分

| 方法签名                                  | 描述                           | 示例 (假设 sb="Hello")   | 结果        |
| ----------------------------------------- | ------------------------------ | ------------------------ | ----------- |
| `replace(int start, int end, String str)` | 将指定区间的字符替换为新字符串 | `sb.replace(0, 5, "Hi")` | "Hi"        |
| `setCharAt(int index, char ch)`           | 修改指定位置的 **单个** 字符   | `sb.setCharAt(1, 'a')`   | "H**a**llo" |



- **实战场景：脱敏处理** 比如把手机号中间四位变成 `****`

```
StringBuilder phone = new StringBuilder("13812345678");
// 替换索引 [3, 7) 的内容
phone.replace(3, 7, "****"); 
System.out.println(phone); // "138****5678"
```



###### 2. 全局变换：反转 —— ⭐ 算法神器

这是 `String` 类没有、但 `StringBuilder` 独有的超级方法。在做“回文串”、“数字反转”等算法题时，它是绝对的杀手锏

| 方法签名        | 描述                   | 示例 (假设 sb="abc") | 结果  |
| --------------- | ---------------------- | -------------------- | ----- |
| **`reverse()`** | 将字符序列及其顺序反转 | `sb.reverse()`       | "cba" |



**实战场景：判断回文串** 

判断一个字符串正读和反读是否一样（如 "上海自来水来自海上"）

```java
public boolean isPalindrome(String str) {
    if (str == null) return false;
    
    // 1. 放入 StringBuilder
    StringBuilder sb = new StringBuilder(str);
    
    // 2. 调用 reverse() 反转，并转回 String
    String reversed = sb.reverse().toString();
    
    // 3. 比较原字符串和反转后的字符串
    return str.equals(reversed);
}
```



###### 3. 全局重置：清空

如果你需要在循环中重复利用同一个 `StringBuilder` 对象（为了省内存，不每次 new 新的），那么“清空”操作非常重要

| 方法签名                   | 描述               | 说明                |
| -------------------------- | ------------------ | ------------------- |
| `setLength(int newLength)` | 设置字符序列的长度 | 设为 0 即为**清空** |

**实战场景：高性能复用**

```java
StringBuilder sb = new StringBuilder();

for (String item : items) {
    // 1. 清空容器 (比 new StringBuilder() 快得多)
    sb.setLength(0);
    
    // 2. 重新拼接
    sb.append("Prefix_").append(item);
    
    // 3. 使用结果
    System.out.println(sb.toString());
}
```



##### 其他操作：容量与扩容

`StringBuilder` 的底层是一个**可变的数组**（JDK 9 前是 `char[]`，JDK 9 后是 `byte[]`）。既然是数组，就涉及到一个核心问题：**如果数组装满了怎么办？**

###### 1. 长度 vs 容量

首先要区分两个概念：

- **长度 (`length`)**：已经装了多少个字符
- **容量 (`capacity`)**：底层数组总共能装多少个字符（不用扩容的情况下）

| 方法签名                  | 描述                             | 示例                     |
| ------------------------- | -------------------------------- | ------------------------ |
| `capacity()`              | 返回当前底层数组的总容量         | `sb.capacity()`          |
| `ensureCapacity(int min)` | 确保容量至少为 `min`，不够则扩容 | `sb.ensureCapacity(100)` |
| `trimToSize()`            | 将容量缩减到实际长度 (省内存)    | `sb.trimToSize()`        |



###### 2. 扩容机制

当你创建一个空的 `new StringBuilder()` 时，默认容量通常是 **16**

当你 append 的字符超过当前容量时，`StringBuilder` 会被迫进行 **扩容**

- **扩容的代价非常大**：
  1. 计算新的容量（通常是 `旧容量 * 2 + 2`）
  2. **创建一个全新的大数组**
  3. **将旧数组的数据全部复制到新数组** (System.arraycopy)
  4. 扔掉旧数组（等待 GC）

如果你的字符串很长，中间可能会触发多次扩容，产生大量的内存碎片和 CPU 开销



###### 3. 性能优化：预分配

如果你大概知道最终字符串的长度（比如大概 100 个字符），请 **一定要在构造时指定容量**



❌ **性能一般的写法**

```java
// 默认容量 16
StringBuilder sb = new StringBuilder(); 

// 假设我们要拼 1000 次，中间会触发多次 "新建数组 -> 复制数据" 的过程
for (int i = 0; i < 1000; i++) {
    sb.append("a");
}
```



**✅ 高性能写法 (推荐)**

```java
// 预估大约需要 1000 个字符，直接申请够用
// 中间不会触发任何扩容，性能最高
StringBuilder sb = new StringBuilder(1024); 

for (int i = 0; i < 1000; i++) {
    sb.append("a");
}
```



###### 4. 内存优化：瘦身 (Trim)

如果一个 `StringBuilder` 经历过大量追加，容量变得很大（比如 10MB），但后来被 `delete` 或 `setLength` 删成了很短的字符串（比如 1KB），底层的 10MB 数组依然占用着内存

此时调用 `trimToSize()` 可以创建一个大小刚好的新数组，释放多余的内存

```java
StringBuilder sb = new StringBuilder(1000000); // 申请大空间
sb.append("hello"); // 只用了几个字符
sb.trimToSize();    // 释放多余空间，容量变为 5
```



### 三剑客

- `String` vs `StringBuilder` vs `StringBuffer`
  - 这三个类是 Java 字符串体系的“三剑客”




#### 1. 对比表格

一张表讲透核心区别

| 特性         | String                        | StringBuilder                 | StringBuffer                  |
| ------------ | ----------------------------- | ----------------------------- | ----------------------------- |
| **可变性**   | ❌ **不可变** (Immutable)      | ✅ **可变**                    | ✅ **可变**                    |
| **线程安全** | ✅ **安全** (天然安全)         | ❌ **不安全**                  | ✅ **安全** (synchronized)     |
| **性能**     | ⭐ (差，每次创建新对象)        | ⭐⭐⭐⭐⭐ (最快)                  | ⭐⭐⭐⭐ (中等，有锁开销)         |
| **适用场景** | 少量字符串操作、常量、Map Key | **单线程**大量拼接 (99% 场景) | **多线程**共享变量拼接 (极少) |
| **底层实现** | `final byte[]`                | `byte[]` + 扩容机制           | `byte[]` + 扩容机制           |



#### 2. 为什么这么设计？

##### 2.1 String：为了安全与共享

- **原理**：因为不可变，所以可以放心地放在“常量池”里共享，也天然不用担心多线程竞争问题
- **代价**：每次修改（拼接、裁剪）都要创建新对象，内存和 CPU 开销大



##### 2.2 StringBuilder：为了极致性能 (JDK 5 引入)

- **原理**：为了解决 String 拼接慢的问题，它直接在底层数组上修改，不创建新对象
- **取舍**：去掉了所有的锁（synchronization），**牺牲了线程安全性**来换取**最快的速度**
- **现状**：这是后端开发（Spring Boot 等）中最常用的拼接工具。因为在方法内部（局部变量），每个线程都有自己独立的 StringBuilder，根本不需要锁



##### 2.3 StringBuffer：历史的眼泪 (JDK 1.0)

- **原理**：JDK 1.0 时就有了。为了保证线程安全，它的几乎所有方法（append, delete 等）都加了 `synchronized` 关键字
- **尴尬**：
  - 在单线程环境下，这些锁是多余的负担，导致它比 StringBuilder 慢
  - 在多线程复杂逻辑下，简单的原子方法锁往往又不够用（通常需要业务层加更大的锁）
  - **结论**：**地位极其尴尬，现代开发中几乎被 StringBuilder 全面取代**



#### 3. StringBuffer 真的完全没用了吗？

虽然我们说它“被弃用”，但要严谨

**场景：多线程共享的可变字符串** 

- 如果你定义了一个 `static` 的字符串构建器，并且有几十个线程同时往里面 `append` 日志：

```JAVA
// 这种极端场景下，必须用 StringBuffer
public static StringBuffer sharedLogBuffer = new StringBuffer();

public void log(String msg) {
    // 多个线程同时调这个方法
    // 如果用 StringBuilder，可能会导致数据覆盖或报错
    // 用 StringBuffer 则能保证 append 操作的原子性
    sharedLogBuffer.append(msg).append("\n");
}
```

> **注**：即使是这种场景，现在的架构也更倾向于使用 `ThreadLocal` 或者专门的日志框架（Log4j/Slf4j），而不是自己维护一个 StringBuffer



#### 4. 决策指南

在实际写代码时，如何选择？

1. **是字符串常量吗？** (如 "Hello", 配置项)
   - 👉 用 **String**。
2. **需要循环拼接、或者拼接操作很多吗？**
   - 👉 **必须**用 StringBuilder 或 StringBuffer
   - 👉 **继续判断**：这个变量是**局部变量**（在方法里定义）还是**全局共享变量**？
     - 如果是局部变量（99.9% 的情况） -> 用 **StringBuilder**
     - 如果是全局共享（极少） -> 用 **StringBuffer**



## 五. 现代Java新特性

主要介绍 Java 8 之后引入的提高开发效率的新特性

### 5.1 Text Blocks —— 写 SQL/JSON 神器

在 Java 13 预览、Java 15 正式发布之前，如何在 Java 代码中写一个多行的字符串（比如一段复杂的 SQL 语句），是所有 Java 开发者的噩梦

#### 1. 痛点：传统写法的“丑陋”

假设我们要写一段 JSON 数据

**❌ JDK 15 之前的写法**： 我们需要手动处理换行符 `\n`，还要对双引号进行转义 `\"`，最后还要用 `+` 号拼接。代码不仅难写，而且几乎无法阅读

```java
String json = "{\n" +
              "  \"name\": \"Alice\",\n" +
              "  \"age\": 25\n" +
              "}";
```



#### 2. 解决：文本块 (JDK 15+)

文本块使用三个双引号 `"""` 作为界定符。它可以自动保留格式，无需显式转义双引号

**✅ 现代写法**： 所见即所得，直接复制粘贴即可

```java
public class TextBlockDemo {
    public static void main(String[] args) {
        // 起始的 """ 后面必须紧跟一个换行符
        // ⚠️ 注意：文本块会保留代码中的换行！
        // 下面这个 json 字符串在内存中实际包含 3 个 \n 换行符
        String json = """
                {
                    "name": "Alice",
                    "age": 25
                }
                """;
        
        System.out.println(json);
    }
}

```



#### 3. 核心规则：智能缩进

你可能会担心：*“我在代码里为了排版缩进了代码，生成的字符串前面会不会也有一大堆空格？”*

Java 编译器非常聪明，它会 **自动去除所有行的公共前导空格**

```java
public void sqlDemo() {
    // 即使代码缩进了，实际字符串内容是顶格的
    String sql = """
            SELECT id, username
            FROM users
            WHERE status = 'ACTIVE'
            """;
            
    // 实际值相当于：
    // "SELECT id, username\nFROM users\nWHERE status = 'ACTIVE'\n"
}
```

**控制缩进的技巧**： 缩进的基准线取决于**结束分隔符 `"""` 的位置**

- 如果结束符 `"""` 另起一行并向左对齐，不仅能保留原有缩进，还能更清晰地界定文本块的范围



#### 4. 实战技巧：配合 formatted 使用

文本块最强大的场景是作为**模板**。结合 Java 15 新增的 `formatted()` 方法，可以非常优雅地生成动态内容

```java
public String generateHtml(String title, String content) {
    // 看起来就像原本的 HTML 文件一样清晰
    return """
           <html>
               <body>
                   <h1>%s</h1>
                   <p>%s</p>
               </body>
           </html>
           """.formatted(title, content);
}
```



#### 5. 特殊转义字符

虽然文本块自动处理了换行，但有时我们需要特殊控制：

- **`\` (行尾反斜杠)**：**取消换行**。如果你希望代码里换行方便阅读，但实际字符串里不换行（比如超长的 SQL），就在行尾加 `\`
- **`\s`**：**保留尾部空格**。默认情况下，每行末尾的空格会被自动裁剪。如果必须保留（比如 Markdown 格式），请使用 `\s`

```java
String longText = """
        This is a very long line that \
        I want to split in source code \
        but treat as single line in runtime.
        """;
// 结果："This is a very long line that I want to split..." (没有换行)
```



### 5.2 现代流式操作

Java 8 引入了 Stream API，让集合处理变得非常优雅

到了 Java 11，String 类终于也拥抱了 Stream，提供了直接处理多行文本和链式操作的能力



#### 1. 行流处理：lines() (JDK 11+)

在以前，处理多行文本（如读取文件、日志）通常要用 `split("\n")`，这会创建一个巨大的数组，既费内存又麻烦

##### 1.1 方法详解

- **方法签名**：`Stream<String> lines()`
- **参数**：无
- **返回值**：`Stream<String>`
  - 返回一个 **字符串流**
  - 流中的每个元素就是原字符串的一行
  - **智能识别换行符**：自动处理 `\n` (Linux)、`\r\n` (Windows) 等各种换行符



##### 1.2 实战场景：日志分析

假设我们有一段日志数据，需要：

1. **去除空行**
2. **筛选** 出包含 "ERROR" 的行
3. **收集** 到一个 List 中

```java
import java.util.stream.Collectors;
import java.util.List;

public class LinesDemo {
    public static void main(String[] args) {
        // 模拟一段多行文本
        String logs = """
                [INFO] System started
                
                [ERROR] Database connection failed
                [INFO] Retrying...
                [ERROR] Timeout
                """;
        
        // ✅ 现代写法 (流式处理)
        // 1. logs.lines() -> 返回 Stream<String>
        List<String> errorLogs = logs.lines()
            .filter(line -> !line.isBlank())      // 2. 中间操作：过滤掉空行
            .filter(line -> line.contains("ERROR")) // 3. 中间操作：只保留错误日志
            .collect(Collectors.toList());        // 4. 终端操作：转为 List
            
        errorLogs.forEach(System.out::println);
        // 输出:
        // [ERROR] Database connection failed
        // [ERROR] Timeout
    }
}
```



#### 2. 链式变换：transform() (JDK 12+)

这个方法是为了解决“嵌套调用”导致代码难以阅读的问题。它的核心作用是 **把一个函数应用到字符串上，并返回转换后的结果**



##### 2.1 方法详解

- **方法签名**：`<R> R transform(Function<? super String, ? extends R> f)`
- **参数**：`Function` 函数式接口
  - 你需要传入一个 Lambda 表达式：`(String s) -> Result`
  - 输入必须是 String，但 **输出可以是任何类型** (Integer, List, User对象等)
- **返回值**：`R` (自定义类型)
  - 返回的是你的函数执行完后的结果



##### 2.2 为什么要用它？

**场景**：把一个字符串 "  123  " 去掉空格，转成整数，然后加 10



**❌ 传统写法 (洋葱式/嵌套式)** 

阅读顺序必须从里向外看，非常反直觉

```java
String s = "  123  ";
// 必须先看最里面 strip()，再看 parseInt，最后看 + 10
int num = Integer.parseInt(s.strip()) + 10;
```



**✅ 现代写法 (链式调用)** 

阅读顺序从上到下，逻辑线性流动。

```java
public class TransformDemo {
    public static void main(String[] args) {
        String input = "  123  ";
        
        int result = input
            .strip()                        // 1. 返回 String: "123"
            .transform(Integer::parseInt)   // 2. 传入 String, 返回 Integer: 123
            .intValue() + 10;               // 3. 现在的类型已经是 int 了
            
        System.out.println(result); // 133
    }
}
```



##### 2.3 进阶实战：解析 ID

假设有一个字符串 `"User:1001"`, 我们想直接提取出 ID 并转为整数

```java
String data = "User:1001";

Integer userId = data
    .transform(s -> s.split(":")[1]) // Step 1: 传入 "User:1001", 返回 String "1001"
    .transform(Integer::parseInt);   // Step 2: 传入 "1001", 返回 Integer 1001

System.out.println(userId); // 1001
```



#### 本节总结

1. **`lines()`**：专门对付多行文本，返回 `Stream`，方便做过滤和统计。
2. **`transform()`**：让 String 可以像流一样“链式调用”，允许你在中间插入自定义的处理逻辑，**并且可以改变返回值类型**



### 5.3 避坑

三个在生产环境中极其隐蔽、杀伤力极大的“巨坑”



#### 1. MyBatis 动态 SQL 陷阱

这是 Java 后端开发中最经典的 Bug 之一，很多经验丰富的老手也会翻车

##### 场景还原

在 MyBatis 的 XML 文件中，我们经常用 `<if>` 标签判断参数值

```xml
<!-- ❌ 错误写法 -->
<!-- 需求：如果参数 status 是 "Y"，则拼接 SQL -->
<if test="status == 'Y'">
    AND status = 'Y'
</if>
```



##### 为什么会报错？

- **预期**：判断 `status` 字符串是否等于 `"Y"`
- **实际**：MyBatis 底层使用 OGNL 表达式引擎。在 OGNL 中：
  - `"Y"` (双引号) 是 **String**
  - `'Y'` (单引号) 是 **Character (char)**
- **结果**：Java 中 `String` 和 `Character` 是无法 `equals` 的（即使内容一样）
  - `"Y".equals('Y')` 返回 `false`
  - 结果导致这个 SQL 条件**永远不生效**，怎么测都测不通



##### ✅ 正确写法

必须强制让两者类型一致

```xml
<!-- 写法 1：外层用单引号，内层用双引号 (推荐，最直观) -->
<if test='status == "Y"'>

<!-- 写法 2：调用 toString() 强转 -->
<if test="status == 'Y'.toString()">
```



#### 2. 编码地狱

**原则：永远不要相信操作系统的默认编码**

##### 场景还原

你在 Windows 上开发，代码跑得好好的。一部署到 Linux 服务器（Docker 容器），生成的中文文件全是乱码，或者加密验签一直失败

##### 原因分析

- `str.getBytes()` 无参方法会使用 **操作系统默认编码**
  - Windows 中文版默认是 **GBK**
  - Linux/Docker 容器默认通常是 **UTF-8**
- 导致同样的字符串，在不同环境下生成的 `byte[]` 不一样！



##### ✅ 最佳实践

在任何涉及到 `String` 和 `byte[]` 互转的地方，**必须显式指定字符集**

```java
import java.nio.charset.StandardCharsets;

public class EncodingDemo {
    public static void main(String[] args) {
        String data = "中文";

        // ❌ 绝对禁止：依赖环境，甚至可能抛出 UnsupportedEncodingException
        byte[] bad = data.getBytes(); 

        // ✅ 强制指定：使用 JDK 自带的常量 (推荐)
        byte[] good = data.getBytes(StandardCharsets.UTF_8);
    }
}
```



#### 3. 内存泄露谣言 (The Substring Myth)

你可能在一些老旧的博客（2012年以前）看到过这样的警告：

> *“千万别乱用 `substring`！它会导致严重的内存泄露！”*



##### 真相辟谣

- **JDK 6 及以前**：

  - 是的，旧版 `substring` 为了性能，直接共享原字符串的 `char[]` 数组

    如果你从一个 100MB 的大字符串里截取了 2 个字符，这 2 个字符会强引用那个 100MB 的大数组，导致内存无法回收



- **JDK 7 Update 6 及以后**：**逻辑变了！**

  - 现在的 `substring` 会 **拷贝** 你需要的那部分字符，创建一个全新的数组
  - 原字符串如果不被使用，会被立刻垃圾回收 (GC)



在现代 JDK（8, 11, 17, 21）中，**请放心大胆地使用 `substring`**，完全不需要像以前那样写 `new String(str.substring(...))` 来防泄露了